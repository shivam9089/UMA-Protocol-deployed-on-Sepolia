{
  "language": "Solidity",
  "sources": {
    "@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"./ICrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainEnabled\n * @dev Helper contract for contracts performing cross-domain communications\n *\n * Compiler used: defined by inheriting contract\n */\ncontract CrossDomainEnabled {\n    /*************\n     * Variables *\n     *************/\n\n    // Messenger contract used to send and recieve messages from the other domain.\n    address public messenger;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\n     */\n    constructor(address _messenger) {\n        messenger = _messenger;\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Enforces that the modified function is only callable by a specific cross-domain account.\n     * @param _sourceDomainAccount The only account on the originating domain which is\n     *  authenticated to call this function.\n     */\n    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {\n        require(\n            msg.sender == address(getCrossDomainMessenger()),\n            \"OVM_XCHAIN: messenger contract unauthenticated\"\n        );\n\n        require(\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\n            \"OVM_XCHAIN: wrong sender of cross-domain message\"\n        );\n\n        _;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\n     * needs to override.\n     * @return The address of the cross-domain messenger contract which should be used.\n     */\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\n        return ICrossDomainMessenger(messenger);\n    }\n\n    /**q\n     * Sends a message to an account on another domain\n     * @param _crossDomainTarget The intended recipient on the destination domain\n     * @param _message The data to send to the target (usually calldata to a function with\n     *  `onlyFromCrossDomainAccount()`)\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\n     */\n    function sendCrossDomainMessage(\n        address _crossDomainTarget,\n        uint32 _gasLimit,\n        bytes memory _message\n    ) internal {\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_PredeployAddresses\n */\nlibrary Lib_PredeployAddresses {\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000007;\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\n        0x4200000000000000000000000000000000000012;\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/core/Module.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Module Interface - A contract that can pass messages to a Module Manager contract if enabled by that contract.\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../interfaces/IAvatar.sol\";\nimport \"../factory/FactoryFriendly.sol\";\nimport \"../guard/Guardable.sol\";\n\nabstract contract Module is FactoryFriendly, Guardable {\n    /// @dev Address that will ultimately execute function calls.\n    address public avatar;\n    /// @dev Address that this module will pass transactions to.\n    address public target;\n\n    /// @dev Emitted each time the avatar is set.\n    event AvatarSet(address indexed previousAvatar, address indexed newAvatar);\n    /// @dev Emitted each time the Target is set.\n    event TargetSet(address indexed previousTarget, address indexed newTarget);\n\n    /// @dev Sets the avatar to a new avatar (`newAvatar`).\n    /// @notice Can only be called by the current owner.\n    function setAvatar(address _avatar) public onlyOwner {\n        address previousAvatar = avatar;\n        avatar = _avatar;\n        emit AvatarSet(previousAvatar, _avatar);\n    }\n\n    /// @dev Sets the target to a new target (`newTarget`).\n    /// @notice Can only be called by the current owner.\n    function setTarget(address _target) public onlyOwner {\n        address previousTarget = target;\n        target = _target;\n        emit TargetSet(previousTarget, _target);\n    }\n\n    /// @dev Passes a transaction to be executed by the avatar.\n    /// @notice Can only be called by this contract.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function exec(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) internal returns (bool success) {\n        address currentGuard = guard;\n        if (currentGuard != address(0)) {\n            IGuard(currentGuard).checkTransaction(\n                /// Transaction info used by module transactions.\n                to,\n                value,\n                data,\n                operation,\n                /// Zero out the redundant transaction information only used for Safe multisig transctions.\n                0,\n                0,\n                0,\n                address(0),\n                payable(0),\n                bytes(\"0x\"),\n                msg.sender\n            );\n            success = IAvatar(target).execTransactionFromModule(\n                to,\n                value,\n                data,\n                operation\n            );\n            IGuard(currentGuard).checkAfterExecution(bytes32(\"0x\"), success);\n        } else {\n            success = IAvatar(target).execTransactionFromModule(\n                to,\n                value,\n                data,\n                operation\n            );\n        }\n        return success;\n    }\n\n    /// @dev Passes a transaction to be executed by the target and returns data.\n    /// @notice Can only be called by this contract.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execAndReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) internal returns (bool success, bytes memory returnData) {\n        address currentGuard = guard;\n        if (currentGuard != address(0)) {\n            IGuard(currentGuard).checkTransaction(\n                /// Transaction info used by module transactions.\n                to,\n                value,\n                data,\n                operation,\n                /// Zero out the redundant transaction information only used for Safe multisig transctions.\n                0,\n                0,\n                0,\n                address(0),\n                payable(0),\n                bytes(\"0x\"),\n                msg.sender\n            );\n            (success, returnData) = IAvatar(target)\n                .execTransactionFromModuleReturnData(\n                    to,\n                    value,\n                    data,\n                    operation\n                );\n            IGuard(currentGuard).checkAfterExecution(bytes32(\"0x\"), success);\n        } else {\n            (success, returnData) = IAvatar(target)\n                .execTransactionFromModuleReturnData(\n                    to,\n                    value,\n                    data,\n                    operation\n                );\n        }\n        return (success, returnData);\n    }\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac FactoryFriendly - A contract that allows other contracts to be initializable and pass bytes as arguments to define contract state\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract FactoryFriendly is OwnableUpgradeable {\n    function setUp(bytes memory initializeParams) public virtual;\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/factory/ModuleProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ModuleProxyFactory {\n    event ModuleProxyCreation(\n        address indexed proxy,\n        address indexed masterCopy\n    );\n\n    /// `target` can not be zero.\n    error ZeroAddress(address target);\n\n    /// `target` has no code deployed.\n    error TargetHasNoCode(address target);\n\n    /// `address_` is already taken.\n    error TakenAddress(address address_);\n\n    /// @notice Initialization failed.\n    error FailedInitialization();\n\n    function createProxy(address target, bytes32 salt)\n        internal\n        returns (address result)\n    {\n        if (address(target) == address(0)) revert ZeroAddress(target);\n        if (address(target).code.length == 0) revert TargetHasNoCode(target);\n        bytes memory deployment = abi.encodePacked(\n            hex\"602d8060093d393df3363d3d373d3d3d363d73\",\n            target,\n            hex\"5af43d82803e903d91602b57fd5bf3\"\n        );\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := create2(0, add(deployment, 0x20), mload(deployment), salt)\n        }\n        if (result == address(0)) revert TakenAddress(result);\n    }\n\n    function deployModule(\n        address masterCopy,\n        bytes memory initializer,\n        uint256 saltNonce\n    ) public returns (address proxy) {\n        proxy = createProxy(\n            masterCopy,\n            keccak256(abi.encodePacked(keccak256(initializer), saltNonce))\n        );\n        (bool success, ) = proxy.call(initializer);\n        if (!success) revert FailedInitialization();\n\n        emit ModuleProxyCreation(proxy, masterCopy);\n    }\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/guard/BaseGuard.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../interfaces/IGuard.sol\";\n\nabstract contract BaseGuard is IERC165 {\n    function supportsInterface(bytes4 interfaceId)\n        external\n        pure\n        override\n        returns (bool)\n    {\n        return\n            interfaceId == type(IGuard).interfaceId || // 0xe6d7a83a\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    /// @dev Module transactions only use the first four parameters: to, value, data, and operation.\n    /// Module.sol hardcodes the remaining parameters as 0 since they are not used for module transactions.\n    /// @notice This interface is used to maintain compatibilty with Gnosis Safe transaction guards.\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external virtual;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external virtual;\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/guard/Guardable.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./BaseGuard.sol\";\n\n/// @title Guardable - A contract that manages fallback calls made to this contract\ncontract Guardable is OwnableUpgradeable {\n    address public guard;\n\n    event ChangedGuard(address guard);\n\n    /// `guard_` does not implement IERC165.\n    error NotIERC165Compliant(address guard_);\n\n    /// @dev Set a guard that checks transactions before execution.\n    /// @param _guard The address of the guard to be used or the 0 address to disable the guard.\n    function setGuard(address _guard) external onlyOwner {\n        if (_guard != address(0)) {\n            if (!BaseGuard(_guard).supportsInterface(type(IGuard).interfaceId))\n                revert NotIERC165Compliant(_guard);\n        }\n        guard = _guard;\n        emit ChangedGuard(guard);\n    }\n\n    function getGuard() external view returns (address _guard) {\n        return guard;\n    }\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/interfaces/IAvatar.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac Avatar - A contract that manages modules that can execute transactions via this contract.\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IAvatar {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    /// @dev Enables a module on the avatar.\n    /// @notice Can only be called by the avatar.\n    /// @notice Modules should be stored as a linked list.\n    /// @notice Must emit EnabledModule(address module) if successful.\n    /// @param module Module to be enabled.\n    function enableModule(address module) external;\n\n    /// @dev Disables a module on the avatar.\n    /// @notice Can only be called by the avatar.\n    /// @notice Must emit DisabledModule(address module) if successful.\n    /// @param prevModule Address that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) external;\n\n    /// @dev Allows a Module to execute a transaction.\n    /// @notice Can only be called by an enabled module.\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success);\n\n    /// @dev Allows a Module to execute a transaction and return data\n    /// @notice Can only be called by an enabled module.\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success, bytes memory returnData);\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) external view returns (bool);\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize)\n        external\n        view\n        returns (address[] memory array, address next);\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/interfaces/IGuard.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IGuard {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n}\n"
    },
    "@maticnetwork/fx-portal/contracts/lib/ExitPayloadReader.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport {RLPReader} from \"./RLPReader.sol\";\n\nlibrary ExitPayloadReader {\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct ExitPayload {\n        RLPReader.RLPItem[] data;\n    }\n\n    struct Receipt {\n        RLPReader.RLPItem[] data;\n        bytes raw;\n        uint256 logIndex;\n    }\n\n    struct Log {\n        RLPReader.RLPItem data;\n        RLPReader.RLPItem[] list;\n    }\n\n    struct LogTopics {\n        RLPReader.RLPItem[] data;\n    }\n\n    // copy paste of private copy() from RLPReader to avoid changing of existing contracts\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n        \n        if (len == 0) return;\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function toExitPayload(bytes memory data) internal pure returns (ExitPayload memory) {\n        RLPReader.RLPItem[] memory payloadData = data.toRlpItem().toList();\n\n        return ExitPayload(payloadData);\n    }\n\n    function getHeaderNumber(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[0].toUint();\n    }\n\n    function getBlockProof(ExitPayload memory payload) internal pure returns (bytes memory) {\n        return payload.data[1].toBytes();\n    }\n\n    function getBlockNumber(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[2].toUint();\n    }\n\n    function getBlockTime(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[3].toUint();\n    }\n\n    function getTxRoot(ExitPayload memory payload) internal pure returns (bytes32) {\n        return bytes32(payload.data[4].toUint());\n    }\n\n    function getReceiptRoot(ExitPayload memory payload) internal pure returns (bytes32) {\n        return bytes32(payload.data[5].toUint());\n    }\n\n    function getReceipt(ExitPayload memory payload) internal pure returns (Receipt memory receipt) {\n        receipt.raw = payload.data[6].toBytes();\n        RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\n\n        if (receiptItem.isList()) {\n            // legacy tx\n            receipt.data = receiptItem.toList();\n        } else {\n            // pop first byte before parsting receipt\n            bytes memory typedBytes = receipt.raw;\n            bytes memory result = new bytes(typedBytes.length - 1);\n            uint256 srcPtr;\n            uint256 destPtr;\n            assembly {\n                srcPtr := add(33, typedBytes)\n                destPtr := add(0x20, result)\n            }\n\n            copy(srcPtr, destPtr, result.length);\n            receipt.data = result.toRlpItem().toList();\n        }\n\n        receipt.logIndex = getReceiptLogIndex(payload);\n        return receipt;\n    }\n\n    function getReceiptProof(ExitPayload memory payload) internal pure returns (bytes memory) {\n        return payload.data[7].toBytes();\n    }\n\n    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns (bytes memory) {\n        return payload.data[8].toBytes();\n    }\n\n    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[8].toUint();\n    }\n\n    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[9].toUint();\n    }\n\n    // Receipt methods\n    function toBytes(Receipt memory receipt) internal pure returns (bytes memory) {\n        return receipt.raw;\n    }\n\n    function getLog(Receipt memory receipt) internal pure returns (Log memory) {\n        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\n        return Log(logData, logData.toList());\n    }\n\n    // Log methods\n    function getEmitter(Log memory log) internal pure returns (address) {\n        return RLPReader.toAddress(log.list[0]);\n    }\n\n    function getTopics(Log memory log) internal pure returns (LogTopics memory) {\n        return LogTopics(log.list[1].toList());\n    }\n\n    function getData(Log memory log) internal pure returns (bytes memory) {\n        return log.list[2].toBytes();\n    }\n\n    function toRlpBytes(Log memory log) internal pure returns (bytes memory) {\n        return log.data.toRlpBytes();\n    }\n\n    // LogTopics methods\n    function getField(LogTopics memory topics, uint256 index) internal pure returns (RLPReader.RLPItem memory) {\n        return topics.data[index];\n    }\n}\n"
    },
    "@maticnetwork/fx-portal/contracts/lib/Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Merkle {\n    function checkMembership(\n        bytes32 leaf,\n        uint256 index,\n        bytes32 rootHash,\n        bytes memory proof\n    ) internal pure returns (bool) {\n        require(proof.length % 32 == 0, \"Invalid proof length\");\n        uint256 proofHeight = proof.length / 32;\n        // Proof of size n means, height of the tree is n+1.\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\n        require(index < 2**proofHeight, \"Leaf index is too big\");\n\n        bytes32 proofElement;\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n            assembly {\n                proofElement := mload(add(proof, i))\n            }\n\n            if (index % 2 == 0) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n\n            index = index / 2;\n        }\n        return computedHash == rootHash;\n    }\n}\n"
    },
    "@maticnetwork/fx-portal/contracts/lib/MerklePatriciaProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {RLPReader} from \"./RLPReader.sol\";\n\nlibrary MerklePatriciaProof {\n    /*\n     * @dev Verifies a merkle patricia proof.\n     * @param value The terminating value in the trie.\n     * @param encodedPath The path in the trie leading to value.\n     * @param rlpParentNodes The rlp encoded stack of nodes.\n     * @param root The root hash of the trie.\n     * @return The boolean validity of the proof.\n     */\n    function verify(\n        bytes memory value,\n        bytes memory encodedPath,\n        bytes memory rlpParentNodes,\n        bytes32 root\n    ) internal pure returns (bool) {\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\n\n        bytes memory currentNode;\n        RLPReader.RLPItem[] memory currentNodeList;\n\n        bytes32 nodeKey = root;\n        uint256 pathPtr = 0;\n\n        bytes memory path = _getNibbleArray(encodedPath);\n        if (path.length == 0) {\n            return false;\n        }\n\n        for (uint256 i = 0; i < parentNodes.length; i++) {\n            if (pathPtr > path.length) {\n                return false;\n            }\n\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\n            if (nodeKey != keccak256(currentNode)) {\n                return false;\n            }\n            currentNodeList = RLPReader.toList(parentNodes[i]);\n\n            if (currentNodeList.length == 17) {\n                if (pathPtr == path.length) {\n                    if (keccak256(RLPReader.toBytes(currentNodeList[16])) == keccak256(value)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n\n                uint8 nextPathNibble = uint8(path[pathPtr]);\n                if (nextPathNibble > 16) {\n                    return false;\n                }\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[nextPathNibble]));\n                pathPtr += 1;\n            } else if (currentNodeList.length == 2) {\n                uint256 traversed = _nibblesToTraverse(RLPReader.toBytes(currentNodeList[0]), path, pathPtr);\n                if (pathPtr + traversed == path.length) {\n                    //leaf node\n                    if (keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n\n                //extension node\n                if (traversed == 0) {\n                    return false;\n                }\n\n                pathPtr += traversed;\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\n            } else {\n                return false;\n            }\n        }\n    }\n\n    function _nibblesToTraverse(\n        bytes memory encodedPartialPath,\n        bytes memory path,\n        uint256 pathPtr\n    ) private pure returns (uint256) {\n        uint256 len = 0;\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\n        // and slicedPath have elements that are each one hex character (1 nibble)\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\n        bytes memory slicedPath = new bytes(partialPath.length);\n\n        // pathPtr counts nibbles in path\n        // partialPath.length is a number of nibbles\n        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\n            bytes1 pathNibble = path[i];\n            slicedPath[i - pathPtr] = pathNibble;\n        }\n\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\n            len = partialPath.length;\n        } else {\n            len = 0;\n        }\n        return len;\n    }\n\n    // bytes b must be hp encoded\n    function _getNibbleArray(bytes memory b) internal pure returns (bytes memory) {\n        bytes memory nibbles = \"\";\n        if (b.length > 0) {\n            uint8 offset;\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\n            if (hpNibble == 1 || hpNibble == 3) {\n                nibbles = new bytes(b.length * 2 - 1);\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\n                nibbles[0] = oddNibble;\n                offset = 1;\n            } else {\n                nibbles = new bytes(b.length * 2 - 2);\n                offset = 0;\n            }\n\n            for (uint256 i = offset; i < nibbles.length; i++) {\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\n            }\n        }\n        return nibbles;\n    }\n\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {\n        return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\n    }\n}\n"
    },
    "@maticnetwork/fx-portal/contracts/lib/RLPReader.sol": {
      "content": "/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\npragma solidity ^0.8.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    /*\n     * @param item RLP encoded list in bytes\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset;\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\n        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\n        else if (byte0 < LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len == 0) return;\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\n\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "@maticnetwork/fx-portal/contracts/tunnel/FxBaseChildTunnel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// IFxMessageProcessor represents interface to process message\ninterface IFxMessageProcessor {\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @notice Mock child tunnel contract to receive and send message from L2\n */\nabstract contract FxBaseChildTunnel is IFxMessageProcessor {\n    // MessageTunnel on L1 will get data from this event\n    event MessageSent(bytes message);\n\n    // fx child\n    address public fxChild;\n\n    // fx root tunnel\n    address public fxRootTunnel;\n\n    constructor(address _fxChild) {\n        fxChild = _fxChild;\n    }\n\n    // Sender must be fxRootTunnel in case of ERC20 tunnel\n    modifier validateSender(address sender) {\n        require(sender == fxRootTunnel, \"FxBaseChildTunnel: INVALID_SENDER_FROM_ROOT\");\n        _;\n    }\n\n    // set fxRootTunnel if not set already\n    function setFxRootTunnel(address _fxRootTunnel) external virtual {\n        require(fxRootTunnel == address(0x0), \"FxBaseChildTunnel: ROOT_TUNNEL_ALREADY_SET\");\n        fxRootTunnel = _fxRootTunnel;\n    }\n\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external override {\n        require(msg.sender == fxChild, \"FxBaseChildTunnel: INVALID_SENDER\");\n        _processMessageFromRoot(stateId, rootMessageSender, data);\n    }\n\n    /**\n     * @notice Emit message that can be received on Root Tunnel\n     * @dev Call the internal function when need to emit message\n     * @param message bytes message that will be sent to Root Tunnel\n     * some message examples -\n     *   abi.encode(tokenId);\n     *   abi.encode(tokenId, tokenMetadata);\n     *   abi.encode(messageType, messageData);\n     */\n    function _sendMessageToRoot(bytes memory message) internal {\n        emit MessageSent(message);\n    }\n\n    /**\n     * @notice Process message received from Root Tunnel\n     * @dev function needs to be implemented to handle message as per requirement\n     * This is called by onStateReceive function.\n     * Since it is called via a system call, any event will not be emitted during its execution.\n     * @param stateId unique state id\n     * @param sender root message sender\n     * @param message bytes message that was sent from Root Tunnel\n     */\n    function _processMessageFromRoot(\n        uint256 stateId,\n        address sender,\n        bytes memory message\n    ) internal virtual;\n}\n"
    },
    "@maticnetwork/fx-portal/contracts/tunnel/FxBaseRootTunnel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {RLPReader} from \"../lib/RLPReader.sol\";\nimport {MerklePatriciaProof} from \"../lib/MerklePatriciaProof.sol\";\nimport {Merkle} from \"../lib/Merkle.sol\";\nimport \"../lib/ExitPayloadReader.sol\";\n\ninterface IFxStateSender {\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\n}\n\ncontract ICheckpointManager {\n    struct HeaderBlock {\n        bytes32 root;\n        uint256 start;\n        uint256 end;\n        uint256 createdAt;\n        address proposer;\n    }\n\n    /**\n     * @notice mapping of checkpoint header numbers to block details\n     * @dev These checkpoints are submited by plasma contracts\n     */\n    mapping(uint256 => HeaderBlock) public headerBlocks;\n}\n\nabstract contract FxBaseRootTunnel {\n    using RLPReader for RLPReader.RLPItem;\n    using Merkle for bytes32;\n    using ExitPayloadReader for bytes;\n    using ExitPayloadReader for ExitPayloadReader.ExitPayload;\n    using ExitPayloadReader for ExitPayloadReader.Log;\n    using ExitPayloadReader for ExitPayloadReader.LogTopics;\n    using ExitPayloadReader for ExitPayloadReader.Receipt;\n\n    // keccak256(MessageSent(bytes))\n    bytes32 public constant SEND_MESSAGE_EVENT_SIG = 0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\n\n    // state sender contract\n    IFxStateSender public fxRoot;\n    // root chain manager\n    ICheckpointManager public checkpointManager;\n    // child tunnel contract which receives and sends messages\n    address public fxChildTunnel;\n\n    // storage to avoid duplicate exits\n    mapping(bytes32 => bool) public processedExits;\n\n    constructor(address _checkpointManager, address _fxRoot) {\n        checkpointManager = ICheckpointManager(_checkpointManager);\n        fxRoot = IFxStateSender(_fxRoot);\n    }\n\n    // set fxChildTunnel if not set already\n    function setFxChildTunnel(address _fxChildTunnel) public virtual {\n        require(fxChildTunnel == address(0x0), \"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\");\n        fxChildTunnel = _fxChildTunnel;\n    }\n\n    /**\n     * @notice Send bytes message to Child Tunnel\n     * @param message bytes message that will be sent to Child Tunnel\n     * some message examples -\n     *   abi.encode(tokenId);\n     *   abi.encode(tokenId, tokenMetadata);\n     *   abi.encode(messageType, messageData);\n     */\n    function _sendMessageToChild(bytes memory message) internal {\n        fxRoot.sendMessageToChild(fxChildTunnel, message);\n    }\n\n    function _validateAndExtractMessage(bytes memory inputData) internal returns (bytes memory) {\n        ExitPayloadReader.ExitPayload memory payload = inputData.toExitPayload();\n\n        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();\n        uint256 blockNumber = payload.getBlockNumber();\n        // checking if exit has already been processed\n        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\n        bytes32 exitHash = keccak256(\n            abi.encodePacked(\n                blockNumber,\n                // first 2 nibbles are dropped while generating nibble array\n                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\n                // so converting to nibble array and then hashing it\n                MerklePatriciaProof._getNibbleArray(branchMaskBytes),\n                payload.getReceiptLogIndex()\n            )\n        );\n        require(processedExits[exitHash] == false, \"FxRootTunnel: EXIT_ALREADY_PROCESSED\");\n        processedExits[exitHash] = true;\n\n        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();\n        ExitPayloadReader.Log memory log = receipt.getLog();\n\n        // check child tunnel\n        require(fxChildTunnel == log.getEmitter(), \"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\");\n\n        bytes32 receiptRoot = payload.getReceiptRoot();\n        // verify receipt inclusion\n        require(\n            MerklePatriciaProof.verify(receipt.toBytes(), branchMaskBytes, payload.getReceiptProof(), receiptRoot),\n            \"FxRootTunnel: INVALID_RECEIPT_PROOF\"\n        );\n\n        // verify checkpoint inclusion\n        _checkBlockMembershipInCheckpoint(\n            blockNumber,\n            payload.getBlockTime(),\n            payload.getTxRoot(),\n            receiptRoot,\n            payload.getHeaderNumber(),\n            payload.getBlockProof()\n        );\n\n        ExitPayloadReader.LogTopics memory topics = log.getTopics();\n\n        require(\n            bytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\n            \"FxRootTunnel: INVALID_SIGNATURE\"\n        );\n\n        // received message data\n        bytes memory message = abi.decode(log.getData(), (bytes)); // event decodes params again, so decoding bytes to get message\n        return message;\n    }\n\n    function _checkBlockMembershipInCheckpoint(\n        uint256 blockNumber,\n        uint256 blockTime,\n        bytes32 txRoot,\n        bytes32 receiptRoot,\n        uint256 headerNumber,\n        bytes memory blockProof\n    ) private view returns (uint256) {\n        (bytes32 headerRoot, uint256 startBlock, , uint256 createdAt, ) = checkpointManager.headerBlocks(headerNumber);\n\n        require(\n            keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)).checkMembership(\n                blockNumber - startBlock,\n                headerRoot,\n                blockProof\n            ),\n            \"FxRootTunnel: INVALID_HEADER\"\n        );\n        return createdAt;\n    }\n\n    /**\n     * @notice receive message from  L2 to L1, validated by proof\n     * @dev This function verifies if the transaction actually happened on child chain\n     *\n     * @param inputData RLP encoded data of the reference tx containing following list of fields\n     *  0 - headerNumber - Checkpoint header block number containing the reference tx\n     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\n     *  2 - blockNumber - Block number containing the reference tx on child chain\n     *  3 - blockTime - Reference tx block time\n     *  4 - txRoot - Transactions root of block\n     *  5 - receiptRoot - Receipts root of block\n     *  6 - receipt - Receipt of the reference transaction\n     *  7 - receiptProof - Merkle proof of the reference receipt\n     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\n     *  9 - receiptLogIndex - Log Index to read from the receipt\n     */\n    function receiveMessage(bytes memory inputData) public virtual {\n        bytes memory message = _validateAndExtractMessage(inputData);\n        _processMessageFromChild(message);\n    }\n\n    /**\n     * @notice Process message received from Child Tunnel\n     * @dev function needs to be implemented to handle message as per requirement\n     * This is called by onStateReceive function.\n     * Since it is called via a system call, any event will not be emitted during its execution.\n     * @param message bytes message that was sent from Child Tunnel\n     */\n    function _processMessageFromChild(bytes memory message) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Snapshot.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Arrays.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\n *\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\n * alternative consider {ERC20Votes}.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\n\nabstract contract ERC20Snapshot is ERC20 {\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n    // https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n    using Arrays for uint256[];\n    using Counters for Counters.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    Counters.Counter private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _getCurrentSnapshotId();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Get the current snapshotId\n     */\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n        require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n        uint256 currentId = _getCurrentSnapshotId();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./StorageSlot.sol\";\nimport \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getUint256Slot();\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint8).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LiquidityMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/common/implementation/AddressWhitelist.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/AddressWhitelistInterface.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./Lockable.sol\";\r\n\r\n/**\r\n * @title A contract to track a whitelist of addresses.\r\n */\r\ncontract AddressWhitelist is AddressWhitelistInterface, Ownable, Lockable {\r\n    enum Status { None, In, Out }\r\n    mapping(address => Status) public whitelist;\r\n\r\n    address[] public whitelistIndices;\r\n\r\n    event AddedToWhitelist(address indexed addedAddress);\r\n    event RemovedFromWhitelist(address indexed removedAddress);\r\n\r\n    /**\r\n     * @notice Adds an address to the whitelist.\r\n     * @param newElement the new address to add.\r\n     */\r\n    function addToWhitelist(address newElement) external override nonReentrant() onlyOwner {\r\n        // Ignore if address is already included\r\n        if (whitelist[newElement] == Status.In) {\r\n            return;\r\n        }\r\n\r\n        // Only append new addresses to the array, never a duplicate\r\n        if (whitelist[newElement] == Status.None) {\r\n            whitelistIndices.push(newElement);\r\n        }\r\n\r\n        whitelist[newElement] = Status.In;\r\n\r\n        emit AddedToWhitelist(newElement);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes an address from the whitelist.\r\n     * @param elementToRemove the existing address to remove.\r\n     */\r\n    function removeFromWhitelist(address elementToRemove) external override nonReentrant() onlyOwner {\r\n        if (whitelist[elementToRemove] != Status.Out) {\r\n            whitelist[elementToRemove] = Status.Out;\r\n            emit RemovedFromWhitelist(elementToRemove);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks whether an address is on the whitelist.\r\n     * @param elementToCheck the address to check.\r\n     * @return True if `elementToCheck` is on the whitelist, or False.\r\n     */\r\n    function isOnWhitelist(address elementToCheck) external view override nonReentrantView() returns (bool) {\r\n        return whitelist[elementToCheck] == Status.In;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets all addresses that are currently included in the whitelist.\r\n     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out\r\n     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we\r\n     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to\r\n     * the empty index.\r\n     * @return activeWhitelist the list of addresses on the whitelist.\r\n     */\r\n    function getWhitelist() external view override nonReentrantView() returns (address[] memory activeWhitelist) {\r\n        // Determine size of whitelist first\r\n        uint256 activeCount = 0;\r\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\r\n            if (whitelist[whitelistIndices[i]] == Status.In) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        // Populate whitelist\r\n        activeWhitelist = new address[](activeCount);\r\n        activeCount = 0;\r\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\r\n            address addr = whitelistIndices[i];\r\n            if (whitelist[addr] == Status.In) {\r\n                activeWhitelist[activeCount] = addr;\r\n                activeCount++;\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/AncillaryData.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Library for encoding and decoding ancillary data for DVM price requests.\r\n * @notice  We assume that on-chain ancillary data can be formatted directly from bytes to utf8 encoding via\r\n * web3.utils.hexToUtf8, and that clients will parse the utf8-encoded ancillary data as a comma-delimitted key-value\r\n * dictionary. Therefore, this library provides internal methods that aid appending to ancillary data from Solidity\r\n * smart contracts. More details on UMA's ancillary data guidelines below:\r\n * https://docs.google.com/document/d/1zhKKjgY1BupBGPPrY_WOJvui0B6DMcd-xDR8-9-SPDw/edit\r\n */\r\nlibrary AncillaryData {\r\n    // This converts the bottom half of a bytes32 input to hex in a highly gas-optimized way.\r\n    // Source: the brilliant implementation at https://gitter.im/ethereum/solidity?at=5840d23416207f7b0ed08c9b.\r\n    function toUtf8Bytes32Bottom(bytes32 bytesIn) private pure returns (bytes32) {\r\n        unchecked {\r\n            uint256 x = uint256(bytesIn);\r\n\r\n            // Nibble interleave\r\n            x = x & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\r\n            x = (x | (x * 2**64)) & 0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff;\r\n            x = (x | (x * 2**32)) & 0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff;\r\n            x = (x | (x * 2**16)) & 0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;\r\n            x = (x | (x * 2**8)) & 0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff;\r\n            x = (x | (x * 2**4)) & 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\r\n\r\n            // Hex encode\r\n            uint256 h = (x & 0x0808080808080808080808080808080808080808080808080808080808080808) / 8;\r\n            uint256 i = (x & 0x0404040404040404040404040404040404040404040404040404040404040404) / 4;\r\n            uint256 j = (x & 0x0202020202020202020202020202020202020202020202020202020202020202) / 2;\r\n            x = x + (h & (i | j)) * 0x27 + 0x3030303030303030303030303030303030303030303030303030303030303030;\r\n\r\n            // Return the result.\r\n            return bytes32(x);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns utf8-encoded bytes32 string that can be read via web3.utils.hexToUtf8.\r\n     * @dev Will return bytes32 in all lower case hex characters and without the leading 0x.\r\n     * This has minor changes from the toUtf8BytesAddress to control for the size of the input.\r\n     * @param bytesIn bytes32 to encode.\r\n     * @return utf8 encoded bytes32.\r\n     */\r\n    function toUtf8Bytes(bytes32 bytesIn) internal pure returns (bytes memory) {\r\n        return abi.encodePacked(toUtf8Bytes32Bottom(bytesIn >> 128), toUtf8Bytes32Bottom(bytesIn));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns utf8-encoded address that can be read via web3.utils.hexToUtf8.\r\n     * Source: https://ethereum.stackexchange.com/questions/8346/convert-address-to-string/8447#8447\r\n     * @dev Will return address in all lower case characters and without the leading 0x.\r\n     * @param x address to encode.\r\n     * @return utf8 encoded address bytes.\r\n     */\r\n    function toUtf8BytesAddress(address x) internal pure returns (bytes memory) {\r\n        return\r\n            abi.encodePacked(toUtf8Bytes32Bottom(bytes32(bytes20(x)) >> 128), bytes8(toUtf8Bytes32Bottom(bytes20(x))));\r\n    }\r\n\r\n    /**\r\n     * @notice Converts a uint into a base-10, UTF-8 representation stored in a `string` type.\r\n     * @dev This method is based off of this code: https://stackoverflow.com/a/65707309.\r\n     */\r\n    function toUtf8BytesUint(uint256 x) internal pure returns (bytes memory) {\r\n        if (x == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 j = x;\r\n        uint256 len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint256 k = len;\r\n        while (x != 0) {\r\n            k = k - 1;\r\n            uint8 temp = (48 + uint8(x - (x / 10) * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            x /= 10;\r\n        }\r\n        return bstr;\r\n    }\r\n\r\n    function appendKeyValueBytes32(\r\n        bytes memory currentAncillaryData,\r\n        bytes memory key,\r\n        bytes32 value\r\n    ) internal pure returns (bytes memory) {\r\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\r\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8Bytes(value));\r\n    }\r\n\r\n    /**\r\n     * @notice Adds \"key:value\" to `currentAncillaryData` where `value` is an address that first needs to be converted\r\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\"k1:v1\"`, then this function will return\r\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\r\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\r\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\r\n     * @param value An address to set as the value in the key:value pair to append to `currentAncillaryData`.\r\n     * @return Newly appended ancillary data.\r\n     */\r\n    function appendKeyValueAddress(\r\n        bytes memory currentAncillaryData,\r\n        bytes memory key,\r\n        address value\r\n    ) internal pure returns (bytes memory) {\r\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\r\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesAddress(value));\r\n    }\r\n\r\n    /**\r\n     * @notice Adds \"key:value\" to `currentAncillaryData` where `value` is a uint that first needs to be converted\r\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\"k1:v1\"`, then this function will return\r\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\r\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\r\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\r\n     * @param value A uint to set as the value in the key:value pair to append to `currentAncillaryData`.\r\n     * @return Newly appended ancillary data.\r\n     */\r\n    function appendKeyValueUint(\r\n        bytes memory currentAncillaryData,\r\n        bytes memory key,\r\n        uint256 value\r\n    ) internal pure returns (bytes memory) {\r\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\r\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesUint(value));\r\n    }\r\n\r\n    /**\r\n     * @notice Helper method that returns the left hand side of a \"key:value\" pair plus the colon \":\" and a leading\r\n     * comma \",\" if the `currentAncillaryData` is not empty. The return value is intended to be prepended as a prefix to\r\n     * some utf8 value that is ultimately added to a comma-delimited, key-value dictionary.\r\n     */\r\n    function constructPrefix(bytes memory currentAncillaryData, bytes memory key) internal pure returns (bytes memory) {\r\n        if (currentAncillaryData.length > 0) {\r\n            return abi.encodePacked(\",\", key, \":\");\r\n        } else {\r\n            return abi.encodePacked(key, \":\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/dsproxy/DSGuardFactory.sol": {
      "content": "// This file was originally taken from dapphub DSGuard and modified. Original source code can be found\r\n// here: https://github.com/dapphub/ds-guard/blob/master/src/guard.sol\r\n// Changes are limited to updating the Solidity version and some stylistic modifications.\r\n\r\n// guard.sol -- simple whitelist implementation of DSAuthority\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract DSAuthority {\r\n    function canCall(\r\n        address src,\r\n        address dst,\r\n        bytes4 sig\r\n    ) public view virtual returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority(address indexed authority);\r\n    event LogSetOwner(address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority public authority;\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_) public auth {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_) public auth {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(address(0))) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSGuardEvents {\r\n    event LogPermit(bytes32 indexed src, bytes32 indexed dst, bytes32 indexed sig);\r\n\r\n    event LogForbid(bytes32 indexed src, bytes32 indexed dst, bytes32 indexed sig);\r\n}\r\n\r\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\r\n    bytes32 public constant ANY = bytes32(type(uint256).max);\r\n\r\n    mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => bool))) acl;\r\n\r\n    function canCall(\r\n        address src_,\r\n        address dst_,\r\n        bytes4 sig\r\n    ) public view override returns (bool) {\r\n        bytes32 src = bytes32(bytes20(src_));\r\n        bytes32 dst = bytes32(bytes20(dst_));\r\n\r\n        return\r\n            acl[src][dst][sig] ||\r\n            acl[src][dst][ANY] ||\r\n            acl[src][ANY][sig] ||\r\n            acl[src][ANY][ANY] ||\r\n            acl[ANY][dst][sig] ||\r\n            acl[ANY][dst][ANY] ||\r\n            acl[ANY][ANY][sig] ||\r\n            acl[ANY][ANY][ANY];\r\n    }\r\n\r\n    function permit(\r\n        bytes32 src,\r\n        bytes32 dst,\r\n        bytes32 sig\r\n    ) public auth {\r\n        acl[src][dst][sig] = true;\r\n        emit LogPermit(src, dst, sig);\r\n    }\r\n\r\n    function forbid(\r\n        bytes32 src,\r\n        bytes32 dst,\r\n        bytes32 sig\r\n    ) public auth {\r\n        acl[src][dst][sig] = false;\r\n        emit LogForbid(src, dst, sig);\r\n    }\r\n\r\n    function permit(\r\n        address src,\r\n        address dst,\r\n        bytes32 sig\r\n    ) public {\r\n        permit(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\r\n    }\r\n\r\n    function forbid(\r\n        address src,\r\n        address dst,\r\n        bytes32 sig\r\n    ) public {\r\n        forbid(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\r\n    }\r\n}\r\n\r\ncontract DSGuardFactory {\r\n    mapping(address => bool) public isGuard;\r\n\r\n    function newGuard() public returns (DSGuard guard) {\r\n        guard = new DSGuard();\r\n        guard.setOwner(msg.sender);\r\n        isGuard[address(guard)] = true;\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/dsproxy/DSProxyFactory.sol": {
      "content": "// This file was originally taken from the Maker DS Proxy Factory and modified. The original source code can be found\r\n// here: https://etherscan.io/address/0xa26e15c895efc0616177b7c1e7270a4c7d51c997#code\r\n// Changes are limited to updating the Solidity version and some stylistic modifications.\r\n\r\n// proxy.sol - execute actions atomically through the proxy's identity\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract DSAuthority {\r\n    function canCall(\r\n        address src,\r\n        address dst,\r\n        bytes4 sig\r\n    ) public view virtual returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority(address indexed authority);\r\n    event LogSetOwner(address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority public authority;\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_) public auth {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_) public auth {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(address(0))) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4 indexed sig,\r\n        address indexed guy,\r\n        bytes32 indexed foo,\r\n        bytes32 indexed bar,\r\n        bytes fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n// DSProxy\r\n// Allows code execution using a persistant identity This can be very\r\n// useful to execute a sequence of atomic actions. Since the owner of\r\n// the proxy can be changed, this allows for dynamic ownership models\r\n// i.e. a multisig\r\ncontract DSProxy is DSAuth, DSNote {\r\n    DSProxyCache public cache; // global cache for contracts\r\n\r\n    constructor(address _cacheAddr) {\r\n        require(setCache(_cacheAddr));\r\n    }\r\n\r\n    fallback() external payable {}\r\n\r\n    // use the proxy to execute calldata _data on contract _code\r\n    function execute(bytes memory _code, bytes memory _data) public payable returns (address target, bytes32 response) {\r\n        target = cache.read(_code);\r\n        if (target == address(0x0)) {\r\n            // deploy contract & store its address in cache\r\n            target = cache.write(_code);\r\n        }\r\n\r\n        response = execute(target, _data);\r\n    }\r\n\r\n    function execute(address _target, bytes memory _data) public payable auth note returns (bytes32 response) {\r\n        require(_target != address(0x0), \"Target cant be 0x address\");\r\n\r\n        // call contract in current context\r\n        assembly {\r\n            let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 32)\r\n            response := mload(0) // load delegatecall output\r\n            switch iszero(succeeded)\r\n                case 1 {\r\n                    // throw if delegatecall failed\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n    }\r\n\r\n    //set new cache\r\n    function setCache(address _cacheAddr) public payable auth note returns (bool) {\r\n        require(_cacheAddr != address(0x0)); // invalid cache address\r\n        cache = DSProxyCache(_cacheAddr); // overwrite cache\r\n        return true;\r\n    }\r\n}\r\n\r\n// DSProxyFactory\r\n// This factory deploys new proxy instances through build()\r\n// Deployed proxy addresses are logged\r\ncontract DSProxyFactory {\r\n    event Created(address indexed sender, address indexed owner, address proxy, address cache);\r\n    mapping(address => bool) public isProxy;\r\n    DSProxyCache public cache = new DSProxyCache();\r\n\r\n    // deploys a new proxy instance\r\n    // sets owner of proxy to caller\r\n    function build() public returns (DSProxy proxy) {\r\n        proxy = build(msg.sender);\r\n    }\r\n\r\n    // deploys a new proxy instance\r\n    // sets custom owner of proxy\r\n    function build(address owner) public returns (DSProxy proxy) {\r\n        proxy = new DSProxy(address(cache));\r\n        emit Created(msg.sender, owner, address(proxy), address(cache));\r\n        proxy.setOwner(owner);\r\n        isProxy[address(proxy)] = true;\r\n    }\r\n}\r\n\r\n// DSProxyCache\r\n// This global cache stores addresses of contracts previously deployed\r\n// by a proxy. This saves gas from repeat deployment of the same\r\n// contracts and eliminates blockchain bloat.\r\n\r\n// By default, all proxies deployed from the same factory store\r\n// contracts in the same cache. The cache a proxy instance uses can be\r\n// changed.  The cache uses the sha3 hash of a contract's bytecode to\r\n// lookup the address\r\ncontract DSProxyCache {\r\n    mapping(bytes32 => address) cache;\r\n\r\n    function read(bytes memory _code) public view returns (address) {\r\n        bytes32 hash = keccak256(_code);\r\n        return cache[hash];\r\n    }\r\n\r\n    function write(bytes memory _code) public returns (address target) {\r\n        assembly {\r\n            target := create(0, add(_code, 0x20), mload(_code))\r\n            switch iszero(extcodesize(target))\r\n                case 1 {\r\n                    // throw if contract failed to deploy\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        bytes32 hash = keccak256(_code);\r\n        cache[hash] = target;\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/ExpandedERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"./MultiRole.sol\";\r\nimport \"../interfaces/ExpandedIERC20.sol\";\r\n\r\n/**\r\n * @title An ERC20 with permissioned burning and minting. The contract deployer will initially\r\n * be the owner who is capable of adding new roles.\r\n */\r\ncontract ExpandedERC20 is ExpandedIERC20, ERC20, MultiRole {\r\n    enum Roles {\r\n        // Can set the minter and burner.\r\n        Owner,\r\n        // Addresses that can mint new tokens.\r\n        Minter,\r\n        // Addresses that can burn tokens that address owns.\r\n        Burner\r\n    }\r\n\r\n    uint8 _decimals;\r\n\r\n    /**\r\n     * @notice Constructs the ExpandedERC20.\r\n     * @param _tokenName The name which describes the new token.\r\n     * @param _tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.\r\n     * @param _tokenDecimals The number of decimals to define token precision.\r\n     */\r\n    constructor(\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        uint8 _tokenDecimals\r\n    ) ERC20(_tokenName, _tokenSymbol) {\r\n        _decimals = _tokenDecimals;\r\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\r\n        _createSharedRole(uint256(Roles.Minter), uint256(Roles.Owner), new address[](0));\r\n        _createSharedRole(uint256(Roles.Burner), uint256(Roles.Owner), new address[](0));\r\n    }\r\n\r\n    function decimals() public view virtual override(ERC20) returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `value` tokens to `recipient`, returning true on success.\r\n     * @param recipient address to mint to.\r\n     * @param value amount of tokens to mint.\r\n     * @return True if the mint succeeded, or False.\r\n     */\r\n    function mint(address recipient, uint256 value)\r\n        external\r\n        override\r\n        onlyRoleHolder(uint256(Roles.Minter))\r\n        returns (bool)\r\n    {\r\n        _mint(recipient, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Burns `value` tokens owned by `msg.sender`.\r\n     * @param value amount of tokens to burn.\r\n     */\r\n    function burn(uint256 value) external override onlyRoleHolder(uint256(Roles.Burner)) {\r\n        _burn(msg.sender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns `value` tokens owned by `recipient`.\r\n     * @param recipient address to burn tokens from.\r\n     * @param value amount of tokens to burn.\r\n     * @return True if the burn succeeded, or False.\r\n     */\r\n    function burnFrom(address recipient, uint256 value)\r\n        external\r\n        override\r\n        onlyRoleHolder(uint256(Roles.Burner))\r\n        returns (bool)\r\n    {\r\n        _burn(recipient, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Add Minter role to account.\r\n     * @dev The caller must have the Owner role.\r\n     * @param account The address to which the Minter role is added.\r\n     */\r\n    function addMinter(address account) external virtual override {\r\n        addMember(uint256(Roles.Minter), account);\r\n    }\r\n\r\n    /**\r\n     * @notice Add Burner role to account.\r\n     * @dev The caller must have the Owner role.\r\n     * @param account The address to which the Burner role is added.\r\n     */\r\n    function addBurner(address account) external virtual override {\r\n        addMember(uint256(Roles.Burner), account);\r\n    }\r\n\r\n    /**\r\n     * @notice Reset Owner role to account.\r\n     * @dev The caller must have the Owner role.\r\n     * @param account The new holder of the Owner role.\r\n     */\r\n    function resetOwner(address account) external virtual override {\r\n        resetMember(uint256(Roles.Owner), account);\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\r\n\r\n/**\r\n * @title Library for fixed point arithmetic on uints\r\n */\r\nlibrary FixedPoint {\r\n    using SafeMath for uint256;\r\n    using SignedSafeMath for int256;\r\n\r\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\r\n    // For unsigned values:\r\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\r\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\r\n\r\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\r\n    struct Unsigned {\r\n        uint256 rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\r\n     * @param a uint to convert into a FixedPoint.\r\n     * @return the converted FixedPoint.\r\n     */\r\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if equal, or False.\r\n     */\r\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue == fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if equal, or False.\r\n     */\r\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue == b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue > b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue > fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue > b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue >= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue < b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue < fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue < b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue <= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice The minimum of `a` and `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the minimum of `a` and `b`.\r\n     */\r\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return a.rawValue < b.rawValue ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice The maximum of `a` and `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the maximum of `a` and `b`.\r\n     */\r\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return a.rawValue > b.rawValue ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds two `Unsigned`s, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the sum of `a` and `b`.\r\n     */\r\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.add(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return the sum of `a` and `b`.\r\n     */\r\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return add(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.sub(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return sub(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return sub(fromUnscaledUint(a), b);\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\r\n     * @dev This will \"floor\" the product.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\r\n        // stored internally as a uint256 ~10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\r\n        // would round to 3, but this computation produces the result 2.\r\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\r\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\r\n     * @dev This will \"floor\" the product.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.mul(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\r\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\r\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\r\n        if (mod != 0) {\r\n            return Unsigned(mulFloor.add(1));\r\n        } else {\r\n            return Unsigned(mulFloor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        // Since b is an uint, there is no risk of truncation and we can just mul it normally\r\n        return Unsigned(a.rawValue.mul(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\r\n        // 10^41 is stored internally as a uint256 10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\r\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\r\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a uint256 denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.div(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a uint256 numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return div(fromUnscaledUint(a), b);\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\r\n        uint256 divFloor = aScaled.div(b.rawValue);\r\n        uint256 mod = aScaled.mod(b.rawValue);\r\n        if (mod != 0) {\r\n            return Unsigned(divFloor.add(1));\r\n        } else {\r\n            return Unsigned(divFloor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a uint256 denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\r\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\r\n        // This creates the possibility of overflow if b is very large.\r\n        return divCeil(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\r\n     * @dev This will \"floor\" the result.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a uint256 denominator.\r\n     * @return output is `a` to the power of `b`.\r\n     */\r\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\r\n        output = fromUnscaledUint(1);\r\n        for (uint256 i = 0; i < b; i = i.add(1)) {\r\n            output = mul(output, a);\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\r\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\r\n    // For signed values:\r\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\r\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\r\n\r\n    struct Signed {\r\n        int256 rawValue;\r\n    }\r\n\r\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\r\n        require(a.rawValue >= 0, \"Negative value provided\");\r\n        return Unsigned(uint256(a.rawValue));\r\n    }\r\n\r\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\r\n        require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\r\n        return Signed(int256(a.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\r\n     * @param a int to convert into a FixedPoint.Signed.\r\n     * @return the converted FixedPoint.Signed.\r\n     */\r\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\r\n        return Signed(a.mul(SFP_SCALING_FACTOR));\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a int256.\r\n     * @return True if equal, or False.\r\n     */\r\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\r\n        return a.rawValue == fromUnscaledInt(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if equal, or False.\r\n     */\r\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\r\n        return a.rawValue == b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\r\n        return a.rawValue > b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\r\n        return a.rawValue > fromUnscaledInt(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a an int256.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\r\n        return fromUnscaledInt(a).rawValue > b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\r\n        return a.rawValue >= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\r\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a an int256.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\r\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\r\n        return a.rawValue < b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\r\n        return a.rawValue < fromUnscaledInt(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a an int256.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\r\n        return fromUnscaledInt(a).rawValue < b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\r\n        return a.rawValue <= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\r\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a an int256.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\r\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice The minimum of `a` and `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the minimum of `a` and `b`.\r\n     */\r\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        return a.rawValue < b.rawValue ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice The maximum of `a` and `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the maximum of `a` and `b`.\r\n     */\r\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        return a.rawValue > b.rawValue ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds two `Signed`s, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the sum of `a` and `b`.\r\n     */\r\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        return Signed(a.rawValue.add(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return the sum of `a` and `b`.\r\n     */\r\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        return add(a, fromUnscaledInt(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts two `Signed`s, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        return Signed(a.rawValue.sub(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        return sub(a, fromUnscaledInt(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\r\n     * @param a an int256.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\r\n        return sub(fromUnscaledInt(a), b);\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies two `Signed`s, reverting on overflow.\r\n     * @dev This will \"floor\" the product.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\r\n        // stored internally as an int256 ~10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\r\n        // would round to 3, but this computation produces the result 2.\r\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\r\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\r\n     * @dev This will \"floor\" the product.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        return Signed(a.rawValue.mul(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\r\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\r\n        // Manual mod because SignedSafeMath doesn't support it.\r\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\r\n        if (mod != 0) {\r\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\r\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\r\n            return Signed(mulTowardsZero.add(valueToAdd));\r\n        } else {\r\n            return Signed(mulTowardsZero);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\r\n        return Signed(a.rawValue.mul(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\r\n        // 10^41 is stored internally as an int256 10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\r\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\r\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b an int256 denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        return Signed(a.rawValue.div(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a an int256 numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\r\n        return div(fromUnscaledInt(a), b);\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\r\n        int256 divTowardsZero = aScaled.div(b.rawValue);\r\n        // Manual mod because SignedSafeMath doesn't support it.\r\n        int256 mod = aScaled % b.rawValue;\r\n        if (mod != 0) {\r\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\r\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\r\n            return Signed(divTowardsZero.add(valueToAdd));\r\n        } else {\r\n            return Signed(divTowardsZero);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b an int256 denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\r\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\r\n        // This creates the possibility of overflow if b is very large.\r\n        return divAwayFromZero(a, fromUnscaledInt(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\r\n     * @dev This will \"floor\" the result.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a uint256 (negative exponents are not allowed).\r\n     * @return output is `a` to the power of `b`.\r\n     */\r\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\r\n        output = fromUnscaledInt(1);\r\n        for (uint256 i = 0; i < b; i = i.add(1)) {\r\n            output = mul(output, a);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/HasFinder.sol": {
      "content": "pragma solidity ^0.8.9;\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\n\r\n// Contract stores a reference to the DVM Finder contract which can be used to locate other important DVM contracts.\r\ncontract HasFinder {\r\n    FinderInterface public finder;\r\n\r\n    constructor(address _finder) {\r\n        finder = FinderInterface(_finder);\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/Lockable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\r\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\r\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\r\n */\r\ncontract Lockable {\r\n    bool private _notEntered;\r\n\r\n    constructor() {\r\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\r\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\r\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\r\n        // refund coming into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\r\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\r\n     * function that does the actual state modification.\r\n     */\r\n    modifier nonReentrant() {\r\n        _preEntranceCheck();\r\n        _preEntranceSet();\r\n        _;\r\n        _postEntranceReset();\r\n    }\r\n\r\n    /**\r\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\r\n     */\r\n    modifier nonReentrantView() {\r\n        _preEntranceCheck();\r\n        _;\r\n    }\r\n\r\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\r\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\r\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\r\n    // then call `_postEntranceReset()`.\r\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\r\n    function _preEntranceCheck() internal view {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n\r\n    function _preEntranceSet() internal {\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n    }\r\n\r\n    function _postEntranceReset() internal {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n\r\n    // These functions are intended to be used by child contracts to temporarily disable and re-enable the guard.\r\n    // Intended use:\r\n    // _startReentrantGuardDisabled();\r\n    // ...\r\n    // _endReentrantGuardDisabled();\r\n    //\r\n    // IMPORTANT: these should NEVER be used in a method that isn't inside a nonReentrant block. Otherwise, it's\r\n    // possible to permanently lock your contract.\r\n    function _startReentrantGuardDisabled() internal {\r\n        _notEntered = true;\r\n    }\r\n\r\n    function _endReentrantGuardDisabled() internal {\r\n        _notEntered = false;\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/Multicall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/// Source: https://github.com/mds1/multicall\r\n/// @title Multicall3\r\n/// @notice Aggregate results from multiple function calls\r\n/// @dev Multicall & Multicall2 backwards-compatible\r\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\r\n/// @author Michael Elliot <mike@makerdao.com>\r\n/// @author Joshua Levine <joshua@makerdao.com>\r\n/// @author Nick Johnson <arachnid@notdot.net>\r\n/// @author Andreas Bigger <andreas@nascent.xyz>\r\n/// @author Matt Solomon <matt@mattsolomon.dev>\r\ncontract Multicall3 {\r\n    struct Call {\r\n        address target;\r\n        bytes callData;\r\n    }\r\n\r\n    struct Call3 {\r\n        address target;\r\n        bool allowFailure;\r\n        bytes callData;\r\n    }\r\n\r\n    struct Call3Value {\r\n        address target;\r\n        bool allowFailure;\r\n        uint256 value;\r\n        bytes callData;\r\n    }\r\n\r\n    struct Result {\r\n        bool success;\r\n        bytes returnData;\r\n    }\r\n\r\n    /// @notice Backwards-compatible call aggregation with Multicall\r\n    /// @param calls An array of Call structs\r\n    /// @return blockNumber The block number where the calls were executed\r\n    /// @return returnData An array of bytes containing the responses\r\n    function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {\r\n        blockNumber = block.number;\r\n        uint256 length = calls.length;\r\n        returnData = new bytes[](length);\r\n        Call calldata call;\r\n        for (uint256 i = 0; i < length; ) {\r\n            bool success;\r\n            call = calls[i];\r\n            (success, returnData[i]) = call.target.call(call.callData);\r\n            require(success, \"Multicall3: call failed\");\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /// @notice Backwards-compatible with Multicall2\r\n    /// @notice Aggregate calls without requiring success\r\n    /// @param requireSuccess If true, require all calls to succeed\r\n    /// @param calls An array of Call structs\r\n    /// @return returnData An array of Result structs\r\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\r\n        public\r\n        payable\r\n        returns (Result[] memory returnData)\r\n    {\r\n        uint256 length = calls.length;\r\n        returnData = new Result[](length);\r\n        Call calldata call;\r\n        for (uint256 i = 0; i < length; ) {\r\n            Result memory result = returnData[i];\r\n            call = calls[i];\r\n            (result.success, result.returnData) = call.target.call(call.callData);\r\n            if (requireSuccess) require(result.success, \"Multicall3: call failed\");\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /// @notice Backwards-compatible with Multicall2\r\n    /// @notice Aggregate calls and allow failures using tryAggregate\r\n    /// @param calls An array of Call structs\r\n    /// @return blockNumber The block number where the calls were executed\r\n    /// @return blockHash The hash of the block where the calls were executed\r\n    /// @return returnData An array of Result structs\r\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\r\n        public\r\n        payable\r\n        returns (\r\n            uint256 blockNumber,\r\n            bytes32 blockHash,\r\n            Result[] memory returnData\r\n        )\r\n    {\r\n        blockNumber = block.number;\r\n        blockHash = blockhash(block.number);\r\n        returnData = tryAggregate(requireSuccess, calls);\r\n    }\r\n\r\n    /// @notice Backwards-compatible with Multicall2\r\n    /// @notice Aggregate calls and allow failures using tryAggregate\r\n    /// @param calls An array of Call structs\r\n    /// @return blockNumber The block number where the calls were executed\r\n    /// @return blockHash The hash of the block where the calls were executed\r\n    /// @return returnData An array of Result structs\r\n    function blockAndAggregate(Call[] calldata calls)\r\n        public\r\n        payable\r\n        returns (\r\n            uint256 blockNumber,\r\n            bytes32 blockHash,\r\n            Result[] memory returnData\r\n        )\r\n    {\r\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\r\n    }\r\n\r\n    /// @notice Aggregate calls, ensuring each returns success if required\r\n    /// @param calls An array of Call3 structs\r\n    /// @return returnData An array of Result structs\r\n    function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\r\n        uint256 length = calls.length;\r\n        returnData = new Result[](length);\r\n        Call3 calldata calli;\r\n        for (uint256 i = 0; i < length; ) {\r\n            Result memory result = returnData[i];\r\n            calli = calls[i];\r\n            (result.success, result.returnData) = calli.target.call(calli.callData);\r\n            assembly {\r\n                // Revert if the call fails and failure is not allowed\r\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\r\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\r\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\r\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                    // set data offset\r\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\r\n                    // set length of revert string\r\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\r\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\r\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\r\n                    revert(0x00, 0x64)\r\n                }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /// @notice Aggregate calls with a msg value\r\n    /// @notice Reverts if msg.value is less than the sum of the call values\r\n    /// @param calls An array of Call3Value structs\r\n    /// @return returnData An array of Result structs\r\n    function aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {\r\n        uint256 valAccumulator;\r\n        uint256 length = calls.length;\r\n        returnData = new Result[](length);\r\n        Call3Value calldata calli;\r\n        for (uint256 i = 0; i < length; ) {\r\n            Result memory result = returnData[i];\r\n            calli = calls[i];\r\n            uint256 val = calli.value;\r\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\r\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\r\n            unchecked { valAccumulator += val; }\r\n            (result.success, result.returnData) = calli.target.call{ value: val }(calli.callData);\r\n            assembly {\r\n                // Revert if the call fails and failure is not allowed\r\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\r\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\r\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\r\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                    // set data offset\r\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\r\n                    // set length of revert string\r\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\r\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\r\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\r\n                    revert(0x00, 0x84)\r\n                }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\r\n        require(msg.value == valAccumulator, \"Multicall3: value mismatch\");\r\n    }\r\n\r\n    /// @notice Returns the block hash for the given block number\r\n    /// @param blockNumber The block number\r\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\r\n        blockHash = blockhash(blockNumber);\r\n    }\r\n\r\n    /// @notice Returns the block number\r\n    function getBlockNumber() public view returns (uint256 blockNumber) {\r\n        blockNumber = block.number;\r\n    }\r\n\r\n    /// @notice Returns the block coinbase\r\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\r\n        coinbase = block.coinbase;\r\n    }\r\n\r\n    /// @notice Returns the block difficulty\r\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\r\n        difficulty = block.difficulty;\r\n    }\r\n\r\n    /// @notice Returns the block gas limit\r\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\r\n        gaslimit = block.gaslimit;\r\n    }\r\n\r\n    /// @notice Returns the block timestamp\r\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\r\n        timestamp = block.timestamp;\r\n    }\r\n\r\n    /// @notice Returns the (ETH) balance of a given address\r\n    function getEthBalance(address addr) public view returns (uint256 balance) {\r\n        balance = addr.balance;\r\n    }\r\n\r\n    /// @notice Returns the block hash of the last block\r\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\r\n        unchecked { blockHash = blockhash(block.number - 1); }\r\n    }\r\n\r\n    /// @notice Gets the base fee of the given block\r\n    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\r\n    function getBasefee() public view returns (uint256 basefee) {\r\n        basefee = block.basefee;\r\n    }\r\n\r\n    /// @notice Returns the chain id\r\n    function getChainId() public view returns (uint256 chainid) {\r\n        chainid = block.chainid;\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/MultiCaller.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n// This contract is taken from Uniswap's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\r\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\r\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\r\n\r\n/// @title MultiCaller\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\ncontract MultiCaller {\r\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n            if (!success) {\r\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\r\n                if (result.length < 68) revert();\r\n                assembly {\r\n                    result := add(result, 0x04)\r\n                }\r\n                revert(abi.decode(result, (string)));\r\n            }\r\n\r\n            results[i] = result;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/MultiRole.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Exclusive {\r\n    struct RoleMembership {\r\n        address member;\r\n    }\r\n\r\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\r\n        return roleMembership.member == memberToCheck;\r\n    }\r\n\r\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\r\n        require(newMember != address(0x0), \"Cannot set an exclusive role to 0x0\");\r\n        roleMembership.member = newMember;\r\n    }\r\n\r\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\r\n        return roleMembership.member;\r\n    }\r\n\r\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\r\n        resetMember(roleMembership, initialMember);\r\n    }\r\n}\r\n\r\nlibrary Shared {\r\n    struct RoleMembership {\r\n        mapping(address => bool) members;\r\n    }\r\n\r\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\r\n        return roleMembership.members[memberToCheck];\r\n    }\r\n\r\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\r\n        require(memberToAdd != address(0x0), \"Cannot add 0x0 to a shared role\");\r\n        roleMembership.members[memberToAdd] = true;\r\n    }\r\n\r\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\r\n        roleMembership.members[memberToRemove] = false;\r\n    }\r\n\r\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\r\n        for (uint256 i = 0; i < initialMembers.length; i++) {\r\n            addMember(roleMembership, initialMembers[i]);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title Base class to manage permissions for the derived class.\r\n */\r\nabstract contract MultiRole {\r\n    using Exclusive for Exclusive.RoleMembership;\r\n    using Shared for Shared.RoleMembership;\r\n\r\n    enum RoleType { Invalid, Exclusive, Shared }\r\n\r\n    struct Role {\r\n        uint256 managingRole;\r\n        RoleType roleType;\r\n        Exclusive.RoleMembership exclusiveRoleMembership;\r\n        Shared.RoleMembership sharedRoleMembership;\r\n    }\r\n\r\n    mapping(uint256 => Role) private roles;\r\n\r\n    event ResetExclusiveMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\r\n    event AddedSharedMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\r\n    event RemovedSharedMember(uint256 indexed roleId, address indexed oldMember, address indexed manager);\r\n\r\n    /**\r\n     * @notice Reverts unless the caller is a member of the specified roleId.\r\n     */\r\n    modifier onlyRoleHolder(uint256 roleId) {\r\n        require(holdsRole(roleId, msg.sender), \"Sender does not hold required role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\r\n     */\r\n    modifier onlyRoleManager(uint256 roleId) {\r\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \"Can only be called by a role manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\r\n     */\r\n    modifier onlyExclusive(uint256 roleId) {\r\n        require(roles[roleId].roleType == RoleType.Exclusive, \"Must be called on an initialized Exclusive role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\r\n     */\r\n    modifier onlyShared(uint256 roleId) {\r\n        require(roles[roleId].roleType == RoleType.Shared, \"Must be called on an initialized Shared role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `memberToCheck` is a member of roleId.\r\n     * @dev Reverts if roleId does not correspond to an initialized role.\r\n     * @param roleId the Role to check.\r\n     * @param memberToCheck the address to check.\r\n     * @return True if `memberToCheck` is a member of `roleId`.\r\n     */\r\n    function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\r\n        Role storage role = roles[roleId];\r\n        if (role.roleType == RoleType.Exclusive) {\r\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\r\n        } else if (role.roleType == RoleType.Shared) {\r\n            return role.sharedRoleMembership.isMember(memberToCheck);\r\n        }\r\n        revert(\"Invalid roleId\");\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\r\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\r\n     * initialized, ExclusiveRole.\r\n     * @param roleId the ExclusiveRole membership to modify.\r\n     * @param newMember the new ExclusiveRole member.\r\n     */\r\n    function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\r\n        emit ResetExclusiveMember(roleId, newMember, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current holder of the exclusive role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\r\n     * @param roleId the ExclusiveRole membership to check.\r\n     * @return the address of the current ExclusiveRole member.\r\n     */\r\n    function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\r\n        return roles[roleId].exclusiveRoleMembership.getMember();\r\n    }\r\n\r\n    /**\r\n     * @notice Adds `newMember` to the shared role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\r\n     * managing role for `roleId`.\r\n     * @param roleId the SharedRole membership to modify.\r\n     * @param newMember the new SharedRole member.\r\n     */\r\n    function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].sharedRoleMembership.addMember(newMember);\r\n        emit AddedSharedMember(roleId, newMember, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\r\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\r\n     * managing role for `roleId`.\r\n     * @param roleId the SharedRole membership to modify.\r\n     * @param memberToRemove the current SharedRole member to remove.\r\n     */\r\n    function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\r\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\r\n        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes caller from the role, `roleId`.\r\n     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\r\n     * initialized, SharedRole.\r\n     * @param roleId the SharedRole membership to modify.\r\n     */\r\n    function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\r\n        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\r\n        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if `roleId` is not initialized.\r\n     */\r\n    modifier onlyValidRole(uint256 roleId) {\r\n        require(roles[roleId].roleType != RoleType.Invalid, \"Attempted to use an invalid roleId\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if `roleId` is initialized.\r\n     */\r\n    modifier onlyInvalidRole(uint256 roleId) {\r\n        require(roles[roleId].roleType == RoleType.Invalid, \"Cannot use a pre-existing role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\r\n     * `initialMembers` will be immediately added to the role.\r\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\r\n     * initialized.\r\n     */\r\n    function _createSharedRole(\r\n        uint256 roleId,\r\n        uint256 managingRoleId,\r\n        address[] memory initialMembers\r\n    ) internal onlyInvalidRole(roleId) {\r\n        Role storage role = roles[roleId];\r\n        role.roleType = RoleType.Shared;\r\n        role.managingRole = managingRoleId;\r\n        role.sharedRoleMembership.init(initialMembers);\r\n        require(\r\n            roles[managingRoleId].roleType != RoleType.Invalid,\r\n            \"Attempted to use an invalid role to manage a shared role\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to initialize an exclusive role, `roleId`, which will be managed by `managingRoleId`.\r\n     * `initialMember` will be immediately added to the role.\r\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\r\n     * initialized.\r\n     */\r\n    function _createExclusiveRole(\r\n        uint256 roleId,\r\n        uint256 managingRoleId,\r\n        address initialMember\r\n    ) internal onlyInvalidRole(roleId) {\r\n        Role storage role = roles[roleId];\r\n        role.roleType = RoleType.Exclusive;\r\n        role.managingRole = managingRoleId;\r\n        role.exclusiveRoleMembership.init(initialMember);\r\n        require(\r\n            roles[managingRoleId].roleType != RoleType.Invalid,\r\n            \"Attempted to use an invalid role to manage an exclusive role\"\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/Stakeable.sol": {
      "content": "/**\r\n * Stakeable contract.\r\n */\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../data-verification-mechanism/interfaces/StakerInterface.sol\";\r\nimport \"./Withdrawable.sol\";\r\n\r\n/**\r\n * @title Base contract that extends the Withdrawable contract enabling a specific role to stake ERC20 tokens against the\r\n * Voting contract. Voting contract is fed in as a param rather than fetched from the finder to enable upgradability.\r\n */\r\nabstract contract Stakeable is Withdrawable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 private roleId;\r\n\r\n    /**\r\n     * @notice Stake ERC20 tokens from this contract to the votingContract.\r\n     * @param amount amount of tokens to stake.\r\n     * @param votingContract Address of the voting contract to stake into.\r\n     */\r\n    function stake(uint128 amount, address votingContract) external onlyRoleHolder(roleId) {\r\n        StakerInterface voting = StakerInterface(votingContract);\r\n        IERC20 votingToken = IERC20(voting.votingToken());\r\n        votingToken.approve(votingContract, amount);\r\n        voting.stake(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Request unstaking of ERC20 tokens from this contract to the votingContract.\r\n     * @param amount amount of tokens to unstake.\r\n     * @param votingContract Address of the voting contract to unstake from.\r\n     */\r\n    function requestUnstake(uint128 amount, address votingContract) external onlyRoleHolder(roleId) {\r\n        StakerInterface voting = StakerInterface(votingContract);\r\n        voting.requestUnstake(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Execute an unstake request that has passed liveness on the voting contract.\r\n     * @param votingContract Address of the voting contract to execute the unstake from.\r\n     */\r\n    function executeUnstake(address votingContract) external onlyRoleHolder(roleId) {\r\n        StakerInterface voting = StakerInterface(votingContract);\r\n        voting.executeUnstake();\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method that allows derived contracts to choose the role for stakeable.\r\n     * @dev The role `setRoleId` must exist. Either this method or `_setStakeRole` must be\r\n     * called by the derived class for this contract to function properly.\r\n     * @param setRoleId ID corresponding to role whose members can stakeable.\r\n     */\r\n    function _setStakeRole(uint256 setRoleId) internal onlyValidRole(setRoleId) {\r\n        roleId = setRoleId;\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/Testable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Timer.sol\";\r\n\r\n/**\r\n * @title Base class that provides time overrides, but only if being run in test mode.\r\n */\r\nabstract contract Testable {\r\n    // If the contract is being run in production, then `timerAddress` will be the 0x0 address.\r\n    // Note: this variable should be set on construction and never modified.\r\n    address public timerAddress;\r\n\r\n    /**\r\n     * @notice Constructs the Testable contract. Called by child contracts.\r\n     * @param _timerAddress Contract that stores the current time in a testing environment.\r\n     * Must be set to 0x0 for production environments that use live time.\r\n     */\r\n    constructor(address _timerAddress) {\r\n        timerAddress = _timerAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if not running in test mode.\r\n     */\r\n    modifier onlyIfTest {\r\n        require(timerAddress != address(0x0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the current time.\r\n     * @dev Will revert if not running in test mode.\r\n     * @param time timestamp to set current Testable time to.\r\n     */\r\n    function setCurrentTime(uint256 time) external onlyIfTest {\r\n        Timer(timerAddress).setCurrentTime(time);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\r\n     * Otherwise, it will return the block timestamp.\r\n     * @return uint for the current Testable timestamp.\r\n     */\r\n    function getCurrentTime() public view virtual returns (uint256) {\r\n        if (timerAddress != address(0x0)) {\r\n            return Timer(timerAddress).getCurrentTime();\r\n        } else {\r\n            return block.timestamp; // solhint-disable-line not-rely-on-time\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/TestnetERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * @title An implementation of ERC20 with the same interface as the Compound project's testnet tokens (mainly DAI)\r\n * @dev This contract can be deployed or the interface can be used to communicate with Compound's ERC20 tokens.  Note:\r\n * this token should never be used to store real value since it allows permissionless minting.\r\n */\r\n\r\ncontract TestnetERC20 is ERC20 {\r\n    uint8 _decimals;\r\n\r\n    /**\r\n     * @notice Constructs the TestnetERC20.\r\n     * @param _name The name which describes the new token.\r\n     * @param _symbol The ticker abbreviation of the name. Ideally < 5 chars.\r\n     * @param _tokenDecimals The number of decimals to define token precision.\r\n     */\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _tokenDecimals\r\n    ) ERC20(_name, _symbol) {\r\n        _decimals = _tokenDecimals;\r\n    }\r\n\r\n    function decimals() public view virtual override(ERC20) returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    // Sample token information.\r\n\r\n    /**\r\n     * @notice Mints value tokens to the owner address.\r\n     * @param ownerAddress the address to mint to.\r\n     * @param value the amount of tokens to mint.\r\n     */\r\n    function allocateTo(address ownerAddress, uint256 value) external {\r\n        _mint(ownerAddress, value);\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/Timer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Universal store of current contract time for testing environments.\r\n */\r\ncontract Timer {\r\n    uint256 private currentTime;\r\n\r\n    constructor() {\r\n        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the current time.\r\n     * @dev Will revert if not running in test mode.\r\n     * @param time timestamp to set `currentTime` to.\r\n     */\r\n    function setCurrentTime(uint256 time) external {\r\n        currentTime = time;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the currentTime variable set in the Timer.\r\n     * @return uint256 for the current Testable timestamp.\r\n     */\r\n    function getCurrentTime() public view returns (uint256) {\r\n        return currentTime;\r\n    }\r\n}\r\n"
    },
    "contracts/common/implementation/Withdrawable.sol": {
      "content": "/**\r\n * Withdrawable contract.\r\n */\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"./MultiRole.sol\";\r\n\r\n/**\r\n * @title Base contract that allows a specific role to withdraw any ETH and/or ERC20 tokens that the contract holds.\r\n */\r\nabstract contract Withdrawable is MultiRole {\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 private roleId;\r\n\r\n    /**\r\n     * @notice Withdraws ETH from the contract.\r\n     */\r\n    function withdraw(uint256 amount) external onlyRoleHolder(roleId) {\r\n        Address.sendValue(payable(msg.sender), amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws ERC20 tokens from the contract.\r\n     * @param erc20Address ERC20 token to withdraw.\r\n     * @param amount amount of tokens to withdraw.\r\n     */\r\n    function withdrawErc20(address erc20Address, uint256 amount) external onlyRoleHolder(roleId) {\r\n        IERC20 erc20 = IERC20(erc20Address);\r\n        erc20.safeTransfer(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method that allows derived contracts to create a role for withdrawal.\r\n     * @dev Either this method or `_setWithdrawRole` must be called by the derived class for this contract to function\r\n     * properly.\r\n     * @param newRoleId ID corresponding to role whose members can withdraw.\r\n     * @param managingRoleId ID corresponding to managing role who can modify the withdrawable role's membership.\r\n     * @param withdrawerAddress new manager of withdrawable role.\r\n     */\r\n    function _createWithdrawRole(\r\n        uint256 newRoleId,\r\n        uint256 managingRoleId,\r\n        address withdrawerAddress\r\n    ) internal {\r\n        roleId = newRoleId;\r\n        _createExclusiveRole(newRoleId, managingRoleId, withdrawerAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method that allows derived contracts to choose the role for withdrawal.\r\n     * @dev The role `setRoleId` must exist. Either this method or `_createWithdrawRole` must be\r\n     * called by the derived class for this contract to function properly.\r\n     * @param setRoleId ID corresponding to role whose members can withdraw.\r\n     */\r\n    function _setWithdrawRole(uint256 setRoleId) internal onlyValidRole(setRoleId) {\r\n        roleId = setRoleId;\r\n    }\r\n}\r\n"
    },
    "contracts/common/interfaces/AddressWhitelistInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\ninterface AddressWhitelistInterface {\r\n    function addToWhitelist(address newElement) external;\r\n\r\n    function removeFromWhitelist(address newElement) external;\r\n\r\n    function isOnWhitelist(address newElement) external view returns (bool);\r\n\r\n    function getWhitelist() external view returns (address[] memory);\r\n}\r\n"
    },
    "contracts/common/interfaces/Balancer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Interface for Balancer.\r\n * @dev This only contains the methods/events that we use in our contracts or offchain infrastructure.\r\n */\r\nabstract contract Balancer {\r\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view virtual returns (uint256 spotPrice);\r\n}\r\n"
    },
    "contracts/common/interfaces/ExpandedIERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title ERC20 interface that includes burn and mint methods.\r\n */\r\nabstract contract ExpandedIERC20 is IERC20 {\r\n    /**\r\n     * @notice Burns a specific amount of the caller's tokens.\r\n     * @dev Only burns the caller's tokens, so it is safe to leave this method permissionless.\r\n     */\r\n    function burn(uint256 value) external virtual;\r\n\r\n    /**\r\n     * @dev Burns `value` tokens owned by `recipient`.\r\n     * @param recipient address to burn tokens from.\r\n     * @param value amount of tokens to burn.\r\n     */\r\n    function burnFrom(address recipient, uint256 value) external virtual returns (bool);\r\n\r\n    /**\r\n     * @notice Mints tokens and adds them to the balance of the `to` address.\r\n     * @dev This method should be permissioned to only allow designated parties to mint tokens.\r\n     */\r\n    function mint(address to, uint256 value) external virtual returns (bool);\r\n\r\n    function addMinter(address account) external virtual;\r\n\r\n    function addBurner(address account) external virtual;\r\n\r\n    function resetOwner(address account) external virtual;\r\n}\r\n"
    },
    "contracts/common/interfaces/HarvestVaultInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title Interface for Harvest-style vaults.\r\n * @dev This only contains the methods/events that we use in our contracts or offchain infrastructure.\r\n */\r\nabstract contract HarvestVaultInterface {\r\n    // Return the underlying token.\r\n    function underlying() external view virtual returns (IERC20);\r\n\r\n    // Gets the number of return tokens that a \"share\" of this vault is worth.\r\n    function getPricePerFullShare() external view virtual returns (uint256);\r\n}\r\n"
    },
    "contracts/common/interfaces/IERC20Standard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title ERC20 interface that includes the decimals read only method.\r\n */\r\ninterface IERC20Standard is IERC20 {\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05`\r\n     * (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value\r\n     * {ERC20} uses, unless {_setupDecimals} is called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic\r\n     * of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/common/interfaces/Multicall.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.5.0;\r\n\r\n/**\r\n * @title interface for MakerDao's Multicall contract.\r\n * @dev This only contains the methods/events that we use in our contracts or offchain infrastructure.\r\n */\r\ncontract Multicall {\r\n    struct Call {\r\n        address target;\r\n        bytes callData;\r\n    }\r\n\r\n    function aggregate(Call[] memory calls) public virtual returns (uint256 blockNumber, bytes[] memory returnData) {}\r\n}\r\n"
    },
    "contracts/common/interfaces/Multicall2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.5.0;\r\n\r\n/**\r\n * @title interface for MakerDao's Multicall2 contract.\r\n * @dev This adds method to allow calls within the batch to fail\r\n * @dev Full implementation can be found here: https://github.com/makerdao/multicall/blob/16ec5e2859b3a4829ceed4ee1ef609e6e9a744ee/src/Multicall2.sol\r\n */\r\nabstract contract Multicall2 {\r\n    struct Call {\r\n        address target;\r\n        bytes callData;\r\n    }\r\n    struct Result {\r\n        bool success;\r\n        bytes returnData;\r\n    }\r\n\r\n    function aggregate(Call[] memory calls) public virtual returns (uint256 blockNumber, bytes[] memory returnData);\r\n\r\n    function tryBlockAndAggregate(bool requireSuccess, Call[] memory calls)\r\n        public\r\n        virtual\r\n        returns (\r\n            uint256 blockNumber,\r\n            bytes32 blockHash,\r\n            Result[] memory returnData\r\n        );\r\n}\r\n"
    },
    "contracts/common/interfaces/TransactionBatcher.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n// This is an interface to interact with a deployed implementation by https://github.com/kleros/action-callback-bots for\r\n// batching on-chain transactions.\r\n// See deployed implementation here: https://etherscan.io/address/0x82458d1c812d7c930bb3229c9e159cbabd9aa8cb.\r\nabstract contract TransactionBatcher {\r\n    function batchSend(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory datas\r\n    ) public payable virtual;\r\n}\r\n"
    },
    "contracts/common/interfaces/UniswapV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Interface for Uniswap v2.\r\n * @dev This only contains the methods/events that we use in our contracts or offchain infrastructure.\r\n */\r\nabstract contract UniswapV2 {\r\n    // Called after every swap showing the new uniswap \"price\" for this token pair.\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n    // Base currency.\r\n    address public token0;\r\n    // Quote currency.\r\n    address public token1;\r\n}\r\n"
    },
    "contracts/common/interfaces/UniswapV3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Interface for Uniswap v3.\r\n * @dev This only contains the methods/events that we use in our contracts or offchain infrastructure.\r\n */\r\nabstract contract UniswapV3 {\r\n    // Called after every swap showing the new uniswap price for this token pair.\r\n    event Swap(\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        int256 amount0,\r\n        int256 amount1,\r\n        uint160 sqrtPriceX96,\r\n        uint128 liquidity,\r\n        int24 tick\r\n    );\r\n    // Base currency.\r\n    address public token0;\r\n    // Quote currency.\r\n    address public token1;\r\n}\r\n"
    },
    "contracts/common/interfaces/VaultInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title Interface for Yearn-style vaults.\r\n * @dev This only contains the methods/events that we use in our contracts or offchain infrastructure.\r\n */\r\nabstract contract VaultInterface {\r\n    // Return the underlying token.\r\n    function token() external view virtual returns (IERC20);\r\n\r\n    // Gets the number of return tokens that a \"share\" of this vault is worth.\r\n    function getPricePerFullShare() external view virtual returns (uint256);\r\n}\r\n"
    },
    "contracts/common/test/AncillaryDataTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../implementation/AncillaryData.sol\";\r\n\r\ncontract AncillaryDataTest {\r\n    function toUtf8BytesAddress(address x) external pure returns (bytes memory) {\r\n        return AncillaryData.toUtf8BytesAddress(x);\r\n    }\r\n\r\n    function toUtf8BytesUint(uint256 v) external pure returns (bytes memory) {\r\n        return AncillaryData.toUtf8BytesUint(v);\r\n    }\r\n\r\n    function appendKeyValueAddress(\r\n        bytes memory currentAncillaryData,\r\n        bytes memory key,\r\n        address value\r\n    ) external pure returns (bytes memory) {\r\n        return AncillaryData.appendKeyValueAddress(currentAncillaryData, key, value);\r\n    }\r\n\r\n    function appendKeyValueBytes32(\r\n        bytes memory currentAncillaryData,\r\n        bytes memory key,\r\n        bytes32 value\r\n    ) external pure returns (bytes memory) {\r\n        return AncillaryData.appendKeyValueBytes32(currentAncillaryData, key, value);\r\n    }\r\n\r\n    function appendKeyValueUint(\r\n        bytes memory currentAncillaryData,\r\n        bytes memory key,\r\n        uint256 value\r\n    ) external pure returns (bytes memory) {\r\n        return AncillaryData.appendKeyValueUint(currentAncillaryData, key, value);\r\n    }\r\n\r\n    function constructPrefix(bytes memory currentAncillaryData, bytes memory key) external pure returns (bytes memory) {\r\n        return AncillaryData.constructPrefix(currentAncillaryData, key);\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/BalancerMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/Balancer.sol\";\r\n\r\n/**\r\n * @title Balancer Mock\r\n */\r\ncontract BalancerMock is Balancer {\r\n    uint256 price = 0;\r\n\r\n    // these params arent used in the mock, but this is to maintain compatibility with balancer API\r\n    function getSpotPriceSansFee(address, address) external view virtual override returns (uint256 spotPrice) {\r\n        return price;\r\n    }\r\n\r\n    // this is not a balancer call, but for testing for changing price.\r\n    function setPrice(uint256 newPrice) external {\r\n        price = newPrice;\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/BasicERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title Implements only the required ERC20 methods. This contract is used\r\n * test how contracts handle ERC20 contracts that have not implemented `decimals()`\r\n * @dev Mostly copied from Consensys EIP-20 implementation:\r\n * https://github.com/ConsenSys/Tokens/blob/fdf687c69d998266a95f15216b1955a4965a0a6d/contracts/eip20/EIP20.sol\r\n */\r\ncontract BasicERC20 is IERC20 {\r\n    uint256 private constant MAX_UINT256 = 2**256 - 1;\r\n    mapping(address => uint256) public balances;\r\n    mapping(address => mapping(address => uint256)) public allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    constructor(uint256 _initialAmount) {\r\n        balances[msg.sender] = _initialAmount;\r\n        _totalSupply = _initialAmount;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public override returns (bool success) {\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && _allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (_allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view override returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/HarvestVaultMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/HarvestVaultInterface.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title Mock for Harvest-style vaults for use in tests.\r\n */\r\ncontract HarvestVaultMock is HarvestVaultInterface {\r\n    IERC20 public override underlying;\r\n    uint256 private pricePerFullShare = 0;\r\n\r\n    constructor(IERC20 _underlying) {\r\n        underlying = _underlying;\r\n    }\r\n\r\n    function getPricePerFullShare() external view override returns (uint256) {\r\n        return pricePerFullShare;\r\n    }\r\n\r\n    function setPricePerFullShare(uint256 _pricePerFullShare) external {\r\n        pricePerFullShare = _pricePerFullShare;\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/MintableERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\n\r\n// Test ERC721 contract that allows free minting\r\ncontract MintableERC721 is ERC721 {\r\n    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {}\r\n\r\n    function mint(address to, uint256 tokenId) public {\r\n        _safeMint(to, tokenId);\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/MultiCallerTest.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\nimport \"../implementation/MultiCaller.sol\";\r\n\r\ncontract MultiCallerTest is MultiCaller {\r\n    uint256 public value;\r\n\r\n    function call(bool shouldFail) public pure {\r\n        require(shouldFail, \"shouldFail set to true\");\r\n    }\r\n\r\n    function add(uint256 amount) public {\r\n        value += amount;\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/MulticallMock.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\n/// @title Multicall - Aggregate results from multiple read-only function calls\r\n/// @author Michael Elliot <mike@makerdao.com>\r\n/// @author Joshua Levine <joshua@makerdao.com>\r\n/// @author Nick Johnson <arachnid@notdot.net>\r\n\r\ncontract MulticallMock {\r\n    struct Call {\r\n        address target;\r\n        bytes callData;\r\n    }\r\n\r\n    function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory returnData) {\r\n        blockNumber = block.number;\r\n        returnData = new bytes[](calls.length);\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\r\n            require(success);\r\n            returnData[i] = ret;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/MultiRoleTest.sol": {
      "content": "/*\r\n  MultiRoleTest contract.\r\n*/\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../implementation/MultiRole.sol\";\r\n\r\n// The purpose of this contract is to make the MultiRole creation methods externally callable for testing purposes.\r\ncontract MultiRoleTest is MultiRole {\r\n    function createSharedRole(\r\n        uint256 roleId,\r\n        uint256 managingRoleId,\r\n        address[] calldata initialMembers\r\n    ) external {\r\n        _createSharedRole(roleId, managingRoleId, initialMembers);\r\n    }\r\n\r\n    function createExclusiveRole(\r\n        uint256 roleId,\r\n        uint256 managingRoleId,\r\n        address initialMember\r\n    ) external {\r\n        _createExclusiveRole(roleId, managingRoleId, initialMember);\r\n    }\r\n\r\n    // solhint-disable-next-line no-empty-blocks\r\n    function revertIfNotHoldingRole(uint256 roleId) external view onlyRoleHolder(roleId) {}\r\n}\r\n"
    },
    "contracts/common/test/PerpetualMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n/**\r\n * @title Simple Perpetual Mock to serve trivial functions\r\n */\r\ncontract PerpetualMock {\r\n    struct FundingRate {\r\n        FixedPoint.Signed rate;\r\n        bytes32 identifier;\r\n        FixedPoint.Unsigned cumulativeMultiplier;\r\n        uint256 updateTime;\r\n        uint256 applicationTime;\r\n        uint256 proposalTime;\r\n    }\r\n\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using FixedPoint for FixedPoint.Signed;\r\n\r\n    FundingRate public fundingRate;\r\n\r\n    // Interface functions required to be implemented in order for an instance of this contract to be passed into the\r\n    // off-chain FinancialContractClient helper module:\r\n    FixedPoint.Unsigned public collateralRequirement;\r\n    uint256 public liquidationLiveness;\r\n    FixedPoint.Unsigned public cumulativeFeeMultiplier;\r\n    mapping(address => uint256) public positions;\r\n    mapping(address => uint256) public liquidations;\r\n    event NewSponsor(address indexed sponsor);\r\n    event EndedSponsorPosition();\r\n    event LiquidationCreated();\r\n\r\n    function getCurrentTime() public view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    // Public methods that are useful for tests:\r\n    function setFundingRate(FundingRate memory _fundingRate) external {\r\n        fundingRate = _fundingRate;\r\n    }\r\n\r\n    function applyFundingRate() external {\r\n        fundingRate.applicationTime = block.timestamp;\r\n        // Simplified rate calcualtion.\r\n        // multiplier = multiplier * (1 + rate)\r\n        fundingRate.cumulativeMultiplier = fundingRate.cumulativeMultiplier.mul(\r\n            FixedPoint.fromSigned(FixedPoint.fromUnscaledInt(1).add(fundingRate.rate))\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/ReentrancyAttack.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n// Tests reentrancy guards defined in Lockable.sol.\r\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/mocks/ReentrancyAttack.sol.\r\ncontract ReentrancyAttack {\r\n    function callSender(bytes4 data) public {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, ) = msg.sender.call(abi.encodeWithSelector(data));\r\n        require(success, \"ReentrancyAttack: failed call\");\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/ReentrancyChecker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n// The Reentrancy Checker causes failures if it is successfully able to re-enter a contract.\r\n// How to use:\r\n// 1. Call setTransactionData with the transaction data you want the Reentrancy Checker to reenter the calling\r\n//    contract with.\r\n// 2. Get the calling contract to call into the reentrancy checker with any call. The fallback function will receive\r\n//    this call and reenter the contract with the transaction data provided in 1. If that reentrancy call does not\r\n//    revert, then the reentrancy checker reverts the initial call, likely causeing the entire transaction to revert.\r\n//\r\n// Note: the reentrancy checker has a guard to prevent an infinite cycle of reentrancy. Inifinite cycles will run out\r\n// of gas in all cases, potentially causing a revert when the contract is adequately protected from reentrancy.\r\ncontract ReentrancyChecker {\r\n    bytes public txnData;\r\n    bool hasBeenCalled;\r\n\r\n    // Used to prevent infinite cycles where the reentrancy is cycled forever.\r\n    modifier skipIfReentered {\r\n        if (hasBeenCalled) {\r\n            return;\r\n        }\r\n        hasBeenCalled = true;\r\n        _;\r\n        hasBeenCalled = false;\r\n    }\r\n\r\n    function setTransactionData(bytes memory _txnData) public {\r\n        txnData = _txnData;\r\n    }\r\n\r\n    function _executeCall(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) private returns (bool success) {\r\n        // Mostly copied from:\r\n        // solhint-disable-next-line max-line-length\r\n        // https://github.com/gnosis/safe-contracts/blob/59cfdaebcd8b87a0a32f87b50fead092c10d3a05/contracts/base/Executor.sol#L23-L31\r\n        // solhint-disable-next-line no-inline-assembly\r\n\r\n        assembly {\r\n            let inputData := add(data, 0x20)\r\n            let inputDataSize := mload(data)\r\n            success := call(gas(), to, value, inputData, inputDataSize, 0, 0)\r\n        }\r\n    }\r\n\r\n    fallback() external skipIfReentered {\r\n        // Attampt to re-enter with the set txnData.\r\n        bool success = _executeCall(msg.sender, 0, txnData);\r\n\r\n        // Fail if the call succeeds because that means the re-entrancy was successful.\r\n        require(!success, \"Re-entrancy was successful\");\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/ReentrancyMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../implementation/Lockable.sol\";\r\nimport \"./ReentrancyAttack.sol\";\r\n\r\n// Tests reentrancy guards defined in Lockable.sol.\r\n// Extends https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/mocks/ReentrancyMock.sol.\r\ncontract ReentrancyMock is Lockable {\r\n    uint256 public counter;\r\n\r\n    constructor() {\r\n        counter = 0;\r\n    }\r\n\r\n    function callback() external nonReentrant {\r\n        _count();\r\n    }\r\n\r\n    function countAndSend(ReentrancyAttack attacker) external nonReentrant {\r\n        _count();\r\n        bytes4 func = bytes4(keccak256(\"callback()\"));\r\n        attacker.callSender(func);\r\n    }\r\n\r\n    function countAndCall(ReentrancyAttack attacker) external nonReentrant {\r\n        _count();\r\n        bytes4 func = bytes4(keccak256(\"getCount()\"));\r\n        attacker.callSender(func);\r\n    }\r\n\r\n    function countLocalRecursive(uint256 n) public nonReentrant {\r\n        if (n > 0) {\r\n            _count();\r\n            countLocalRecursive(n - 1);\r\n        }\r\n    }\r\n\r\n    function countThisRecursive(uint256 n) public nonReentrant {\r\n        if (n > 0) {\r\n            _count();\r\n            // solhint-disable-next-line avoid-low-level-calls\r\n            (bool success, ) = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));\r\n            require(success, \"ReentrancyMock: failed call\");\r\n        }\r\n    }\r\n\r\n    function countLocalCall() public nonReentrant {\r\n        getCount();\r\n    }\r\n\r\n    function countThisCall() public nonReentrant {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, ) = address(this).call(abi.encodeWithSignature(\"getCount()\"));\r\n        require(success, \"ReentrancyMock: failed call\");\r\n    }\r\n\r\n    function getCount() public view nonReentrantView returns (uint256) {\r\n        return counter;\r\n    }\r\n\r\n    function _count() private {\r\n        counter += 1;\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/SignedFixedPointTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../implementation/FixedPoint.sol\";\r\n\r\n// Wraps the FixedPoint library for testing purposes.\r\ncontract SignedFixedPointTest {\r\n    using FixedPoint for FixedPoint.Signed;\r\n    using FixedPoint for int256;\r\n    using SafeMath for int256;\r\n\r\n    function wrapFromSigned(int256 a) external pure returns (uint256) {\r\n        return FixedPoint.fromSigned(FixedPoint.Signed(a)).rawValue;\r\n    }\r\n\r\n    function wrapFromUnsigned(uint256 a) external pure returns (int256) {\r\n        return FixedPoint.fromUnsigned(FixedPoint.Unsigned(a)).rawValue;\r\n    }\r\n\r\n    function wrapFromUnscaledInt(int256 a) external pure returns (int256) {\r\n        return FixedPoint.fromUnscaledInt(a).rawValue;\r\n    }\r\n\r\n    function wrapIsEqual(int256 a, int256 b) external pure returns (bool) {\r\n        return FixedPoint.Signed(a).isEqual(FixedPoint.Signed(b));\r\n    }\r\n\r\n    function wrapMixedIsEqual(int256 a, int256 b) external pure returns (bool) {\r\n        return FixedPoint.Signed(a).isEqual(b);\r\n    }\r\n\r\n    function wrapIsGreaterThan(int256 a, int256 b) external pure returns (bool) {\r\n        return FixedPoint.Signed(a).isGreaterThan(FixedPoint.Signed(b));\r\n    }\r\n\r\n    function wrapIsGreaterThanOrEqual(int256 a, int256 b) external pure returns (bool) {\r\n        return FixedPoint.Signed(a).isGreaterThanOrEqual(FixedPoint.Signed(b));\r\n    }\r\n\r\n    function wrapMixedIsGreaterThan(int256 a, int256 b) external pure returns (bool) {\r\n        return FixedPoint.Signed(a).isGreaterThan(b);\r\n    }\r\n\r\n    function wrapMixedIsGreaterThanOrEqual(int256 a, int256 b) external pure returns (bool) {\r\n        return FixedPoint.Signed(a).isGreaterThanOrEqual(b);\r\n    }\r\n\r\n    function wrapMixedIsGreaterThanOpposite(int256 a, int256 b) external pure returns (bool) {\r\n        return a.isGreaterThan(FixedPoint.Signed(b));\r\n    }\r\n\r\n    function wrapMixedIsGreaterThanOrEqualOpposite(int256 a, int256 b) external pure returns (bool) {\r\n        return a.isGreaterThanOrEqual(FixedPoint.Signed(b));\r\n    }\r\n\r\n    function wrapIsLessThan(int256 a, int256 b) external pure returns (bool) {\r\n        return FixedPoint.Signed(a).isLessThan(FixedPoint.Signed(b));\r\n    }\r\n\r\n    function wrapIsLessThanOrEqual(int256 a, int256 b) external pure returns (bool) {\r\n        return FixedPoint.Signed(a).isLessThanOrEqual(FixedPoint.Signed(b));\r\n    }\r\n\r\n    function wrapMixedIsLessThan(int256 a, int256 b) external pure returns (bool) {\r\n        return FixedPoint.Signed(a).isLessThan(b);\r\n    }\r\n\r\n    function wrapMixedIsLessThanOrEqual(int256 a, int256 b) external pure returns (bool) {\r\n        return FixedPoint.Signed(a).isLessThanOrEqual(b);\r\n    }\r\n\r\n    function wrapMixedIsLessThanOpposite(int256 a, int256 b) external pure returns (bool) {\r\n        return a.isLessThan(FixedPoint.Signed(b));\r\n    }\r\n\r\n    function wrapMixedIsLessThanOrEqualOpposite(int256 a, int256 b) external pure returns (bool) {\r\n        return a.isLessThanOrEqual(FixedPoint.Signed(b));\r\n    }\r\n\r\n    function wrapMin(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).min(FixedPoint.Signed(b)).rawValue;\r\n    }\r\n\r\n    function wrapMax(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).max(FixedPoint.Signed(b)).rawValue;\r\n    }\r\n\r\n    function wrapAdd(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).add(FixedPoint.Signed(b)).rawValue;\r\n    }\r\n\r\n    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedAdd(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).add(b).rawValue;\r\n    }\r\n\r\n    function wrapSub(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).sub(FixedPoint.Signed(b)).rawValue;\r\n    }\r\n\r\n    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedSub(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).sub(b).rawValue;\r\n    }\r\n\r\n    // The second int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedSubOpposite(int256 a, int256 b) external pure returns (int256) {\r\n        return a.sub(FixedPoint.Signed(b)).rawValue;\r\n    }\r\n\r\n    function wrapMul(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).mul(FixedPoint.Signed(b)).rawValue;\r\n    }\r\n\r\n    function wrapMulAwayFromZero(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).mulAwayFromZero(FixedPoint.Signed(b)).rawValue;\r\n    }\r\n\r\n    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedMul(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).mul(b).rawValue;\r\n    }\r\n\r\n    function wrapMixedMulAwayFromZero(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).mulAwayFromZero(b).rawValue;\r\n    }\r\n\r\n    function wrapDiv(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).div(FixedPoint.Signed(b)).rawValue;\r\n    }\r\n\r\n    function wrapDivAwayFromZero(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).divAwayFromZero(FixedPoint.Signed(b)).rawValue;\r\n    }\r\n\r\n    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedDiv(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).div(b).rawValue;\r\n    }\r\n\r\n    function wrapMixedDivAwayFromZero(int256 a, int256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).divAwayFromZero(b).rawValue;\r\n    }\r\n\r\n    // The second int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedDivOpposite(int256 a, int256 b) external pure returns (int256) {\r\n        return a.div(FixedPoint.Signed(b)).rawValue;\r\n    }\r\n\r\n    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapPow(int256 a, uint256 b) external pure returns (int256) {\r\n        return FixedPoint.Signed(a).pow(b).rawValue;\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/TestableTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../implementation/Testable.sol\";\r\n\r\n// TestableTest is derived from the abstract contract Testable for testing purposes.\r\ncontract TestableTest is Testable {\r\n    // solhint-disable-next-line no-empty-blocks\r\n    constructor(address _timerAddress) Testable(_timerAddress) {}\r\n\r\n    function getTestableTimeAndBlockTime() external view returns (uint256 testableTime, uint256 blockTime) {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        return (getCurrentTime(), block.timestamp);\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/UniswapV2Mock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/UniswapV2.sol\";\r\n\r\n/**\r\n * @title Uniswap v2 Mock that allows manual price injection.\r\n */\r\ncontract UniswapV2Mock is UniswapV2 {\r\n    function setTokens(address _token0, address _token1) external {\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n    }\r\n\r\n    function setPrice(uint112 reserve0, uint112 reserve1) external {\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/UniswapV3Mock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/UniswapV3.sol\";\r\n\r\n/**\r\n * @title Uniswap v3 Mock that allows manual price injection.\r\n */\r\ncontract UniswapV3Mock is UniswapV3 {\r\n    function setTokens(address _token0, address _token1) external {\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n    }\r\n\r\n    function setPrice(\r\n        address sender,\r\n        address recipient,\r\n        int256 amount0,\r\n        int256 amount1,\r\n        uint160 sqrtPriceX96,\r\n        uint128 liquidity,\r\n        int24 tick\r\n    ) external {\r\n        emit Swap(sender, recipient, amount0, amount1, sqrtPriceX96, liquidity, tick);\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/UnsignedFixedPointTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../implementation/FixedPoint.sol\";\r\n\r\n// Wraps the FixedPoint library for testing purposes.\r\ncontract UnsignedFixedPointTest {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using FixedPoint for uint256;\r\n    using SafeMath for uint256;\r\n\r\n    function wrapFromUnscaledUint(uint256 a) external pure returns (uint256) {\r\n        return FixedPoint.fromUnscaledUint(a).rawValue;\r\n    }\r\n\r\n    function wrapIsEqual(uint256 a, uint256 b) external pure returns (bool) {\r\n        return FixedPoint.Unsigned(a).isEqual(FixedPoint.Unsigned(b));\r\n    }\r\n\r\n    function wrapMixedIsEqual(uint256 a, uint256 b) external pure returns (bool) {\r\n        return FixedPoint.Unsigned(a).isEqual(b);\r\n    }\r\n\r\n    function wrapIsGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\r\n        return FixedPoint.Unsigned(a).isGreaterThan(FixedPoint.Unsigned(b));\r\n    }\r\n\r\n    function wrapIsGreaterThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\r\n        return FixedPoint.Unsigned(a).isGreaterThanOrEqual(FixedPoint.Unsigned(b));\r\n    }\r\n\r\n    function wrapMixedIsGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\r\n        return FixedPoint.Unsigned(a).isGreaterThan(b);\r\n    }\r\n\r\n    function wrapMixedIsGreaterThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\r\n        return FixedPoint.Unsigned(a).isGreaterThanOrEqual(b);\r\n    }\r\n\r\n    function wrapMixedIsGreaterThanOpposite(uint256 a, uint256 b) external pure returns (bool) {\r\n        return a.isGreaterThan(FixedPoint.Unsigned(b));\r\n    }\r\n\r\n    function wrapMixedIsGreaterThanOrEqualOpposite(uint256 a, uint256 b) external pure returns (bool) {\r\n        return a.isGreaterThanOrEqual(FixedPoint.Unsigned(b));\r\n    }\r\n\r\n    function wrapIsLessThan(uint256 a, uint256 b) external pure returns (bool) {\r\n        return FixedPoint.Unsigned(a).isLessThan(FixedPoint.Unsigned(b));\r\n    }\r\n\r\n    function wrapIsLessThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\r\n        return FixedPoint.Unsigned(a).isLessThanOrEqual(FixedPoint.Unsigned(b));\r\n    }\r\n\r\n    function wrapMixedIsLessThan(uint256 a, uint256 b) external pure returns (bool) {\r\n        return FixedPoint.Unsigned(a).isLessThan(b);\r\n    }\r\n\r\n    function wrapMixedIsLessThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\r\n        return FixedPoint.Unsigned(a).isLessThanOrEqual(b);\r\n    }\r\n\r\n    function wrapMixedIsLessThanOpposite(uint256 a, uint256 b) external pure returns (bool) {\r\n        return a.isLessThan(FixedPoint.Unsigned(b));\r\n    }\r\n\r\n    function wrapMixedIsLessThanOrEqualOpposite(uint256 a, uint256 b) external pure returns (bool) {\r\n        return a.isLessThanOrEqual(FixedPoint.Unsigned(b));\r\n    }\r\n\r\n    function wrapMin(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).min(FixedPoint.Unsigned(b)).rawValue;\r\n    }\r\n\r\n    function wrapMax(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).max(FixedPoint.Unsigned(b)).rawValue;\r\n    }\r\n\r\n    function wrapAdd(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).add(FixedPoint.Unsigned(b)).rawValue;\r\n    }\r\n\r\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedAdd(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).add(b).rawValue;\r\n    }\r\n\r\n    function wrapSub(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).sub(FixedPoint.Unsigned(b)).rawValue;\r\n    }\r\n\r\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedSub(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).sub(b).rawValue;\r\n    }\r\n\r\n    // The second uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedSubOpposite(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return a.sub(FixedPoint.Unsigned(b)).rawValue;\r\n    }\r\n\r\n    function wrapMul(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).mul(FixedPoint.Unsigned(b)).rawValue;\r\n    }\r\n\r\n    function wrapMulCeil(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).mulCeil(FixedPoint.Unsigned(b)).rawValue;\r\n    }\r\n\r\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedMul(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).mul(b).rawValue;\r\n    }\r\n\r\n    function wrapMixedMulCeil(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).mulCeil(b).rawValue;\r\n    }\r\n\r\n    function wrapDiv(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).div(FixedPoint.Unsigned(b)).rawValue;\r\n    }\r\n\r\n    function wrapDivCeil(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).divCeil(FixedPoint.Unsigned(b)).rawValue;\r\n    }\r\n\r\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedDiv(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).div(b).rawValue;\r\n    }\r\n\r\n    function wrapMixedDivCeil(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).divCeil(b).rawValue;\r\n    }\r\n\r\n    // The second uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapMixedDivOpposite(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return a.div(FixedPoint.Unsigned(b)).rawValue;\r\n    }\r\n\r\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\r\n    function wrapPow(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return FixedPoint.Unsigned(a).pow(b).rawValue;\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/VaultMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/VaultInterface.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title Mock for yearn-style vaults for use in tests.\r\n */\r\ncontract VaultMock is VaultInterface {\r\n    IERC20 public override token;\r\n    uint256 private pricePerFullShare = 0;\r\n\r\n    constructor(IERC20 _token) {\r\n        token = _token;\r\n    }\r\n\r\n    function getPricePerFullShare() external view override returns (uint256) {\r\n        return pricePerFullShare;\r\n    }\r\n\r\n    function setPricePerFullShare(uint256 _pricePerFullShare) external {\r\n        pricePerFullShare = _pricePerFullShare;\r\n    }\r\n}\r\n"
    },
    "contracts/common/test/WithdrawableTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../implementation/Withdrawable.sol\";\r\n\r\n// WithdrawableTest is derived from the abstract contract Withdrawable for testing purposes.\r\ncontract WithdrawableTest is Withdrawable {\r\n    enum Roles { Governance, Withdraw }\r\n\r\n    // solhint-disable-next-line no-empty-blocks\r\n    constructor() {\r\n        _createExclusiveRole(uint256(Roles.Governance), uint256(Roles.Governance), msg.sender);\r\n        _createWithdrawRole(uint256(Roles.Withdraw), uint256(Roles.Governance), msg.sender);\r\n    }\r\n\r\n    function pay() external payable {\r\n        require(msg.value > 0);\r\n    }\r\n\r\n    function setInternalWithdrawRole(uint256 setRoleId) public {\r\n        _setWithdrawRole(setRoleId);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/Admin_ChildMessenger.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../interfaces/ChildMessengerInterface.sol\";\r\nimport \"../interfaces/ChildMessengerConsumerInterface.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @notice A version of the child messenger that allows an admin to relay messages on its behalf.\r\n * @dev No parent messenger is needed for this case, as the admin could be trusted to manually send DVM requests on\r\n * mainnet. This is intended to be used as a \"beta\" deployment compatible with any EVM-compatible chains before\r\n * implementing a full bridge adapter. Put simply, it is meant as a stop-gap.\r\n */\r\ncontract Admin_ChildMessenger is Ownable, Lockable, ChildMessengerInterface {\r\n    // The only child network contract that can send messages over the bridge via the messenger is the oracle spoke.\r\n    address public oracleSpoke;\r\n\r\n    event SetOracleSpoke(address newOracleSpoke);\r\n    event MessageSentToParent(bytes data, address indexed oracleSpoke);\r\n    event MessageReceivedFromParent(bytes data, address indexed targetSpoke, address indexed caller);\r\n\r\n    /**\r\n     * @notice Changes the stored address of the Oracle spoke, deployed on L2.\r\n     * @dev The caller of this function must be the admin.\r\n     * @param newOracleSpoke address of the new oracle spoke, deployed on L2.\r\n     */\r\n    function setOracleSpoke(address newOracleSpoke) public onlyOwner nonReentrant() {\r\n        oracleSpoke = newOracleSpoke;\r\n        emit SetOracleSpoke(newOracleSpoke);\r\n    }\r\n\r\n    /**\r\n     * @notice Logs a message to be manually relayed to L1.\r\n     * @dev The caller must be the OracleSpoke on L2. No other contract is permissioned to call this function.\r\n     * @param data data message sent to the L1 messenger. Should be an encoded function call or packed data.\r\n     */\r\n    function sendMessageToParent(bytes memory data) public override nonReentrant() {\r\n        require(msg.sender == oracleSpoke, \"Only callable by oracleSpoke\");\r\n\r\n        // Note: only emit an event. These messages will be manually relayed.\r\n        emit MessageSentToParent(data, oracleSpoke);\r\n    }\r\n\r\n    /**\r\n     * @notice Process a received message from the admin.\r\n     * @dev The caller must be the the admin.\r\n     * @param data data message sent from the admin. Should be an encoded function call or packed data.\r\n     * @param target desired recipient of `data`. Target must implement the `processMessageFromParent` function. Having\r\n     * this as a param enables the Admin to send messages to arbitrary addresses from the messenger contract. This is\r\n     * primarily used to send messages to the OracleSpoke and GovernorSpoke.\r\n     */\r\n    function processMessageFromCrossChainParent(bytes memory data, address target) public onlyOwner nonReentrant() {\r\n        ChildMessengerConsumerInterface(target).processMessageFromParent(data);\r\n        emit MessageReceivedFromParent(data, target, msg.sender);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/Arbitrum_ChildMessenger.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/ChildMessengerInterface.sol\";\r\nimport \"../interfaces/ChildMessengerConsumerInterface.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../external/avm/AVM_CrossDomainEnabled.sol\";\r\n\r\n/**\r\n * @notice Sends and receives cross chain messages between Arbitrum L2 and Ethereum L1 network.\r\n * @dev This contract is ownable via the onlyCrossDomainAccount modifier, restricting ownership to the cross-domain\r\n * parent messenger contract that lives on L1.\r\n */\r\ncontract Arbitrum_ChildMessenger is AVM_CrossDomainEnabled, ChildMessengerInterface, Lockable {\r\n    // The only child network contract that can send messages over the bridge via the messenger is the oracle spoke.\r\n    address public oracleSpoke;\r\n\r\n    // Messenger contract on the other side of the L1<->L2 bridge.\r\n    address public parentMessenger;\r\n\r\n    event SetOracleSpoke(address newOracleSpoke);\r\n    event SetParentMessenger(address newParentMessenger);\r\n    event MessageSentToParent(bytes data, address indexed parentAddress, address indexed oracleSpoke, uint256 id);\r\n    event MessageReceivedFromParent(bytes data, address indexed targetSpoke, address indexed parentAddress);\r\n\r\n    /**\r\n     * @notice Construct the Arbitrum_ChildMessenger contract.\r\n     * @param _parentMessenger The address of the L1 parent messenger. Acts as the \"owner\" of this contract.\r\n     */\r\n    constructor(address _parentMessenger) {\r\n        parentMessenger = _parentMessenger;\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the stored address of the Oracle spoke, deployed on L2.\r\n     * @dev The caller of this function must be the parent messenger, over the canonical bridge.\r\n     * @param newOracleSpoke address of the new oracle spoke, deployed on L2.\r\n     */\r\n    function setOracleSpoke(address newOracleSpoke) public onlyFromCrossDomainAccount(parentMessenger) nonReentrant() {\r\n        oracleSpoke = newOracleSpoke;\r\n        emit SetOracleSpoke(newOracleSpoke);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the stored address of the parent messenger, deployed on L1.\r\n     * @dev The caller of this function must be the parent messenger, over the canonical bridge.\r\n     * @param newParentMessenger address of the new parent messenger, deployed on L1.\r\n     */\r\n    function setParentMessenger(address newParentMessenger)\r\n        public\r\n        onlyFromCrossDomainAccount(parentMessenger)\r\n        nonReentrant()\r\n    {\r\n        parentMessenger = newParentMessenger;\r\n        emit SetParentMessenger(newParentMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Sends a message to the parent messenger via the canonical message bridge.\r\n     * @dev The caller must be the OracleSpoke on L2. No other contract is permissioned to call this function.\r\n     * @dev The L1 target, the parent messenger, must implement processMessageFromChild to consume the message.\r\n     * @param data data message sent to the L1 messenger. Should be an encoded function call or packed data.\r\n     */\r\n    function sendMessageToParent(bytes memory data) public override nonReentrant() {\r\n        require(msg.sender == oracleSpoke, \"Only callable by oracleSpoke\");\r\n        bytes memory dataSentToParent = abi.encodeWithSignature(\"processMessageFromCrossChainChild(bytes)\", data);\r\n        uint256 id = sendCrossDomainMessage(msg.sender, parentMessenger, dataSentToParent);\r\n        emit MessageSentToParent(dataSentToParent, parentMessenger, oracleSpoke, id);\r\n    }\r\n\r\n    /**\r\n     * @notice Process a received message from the parent messenger via the canonical message bridge.\r\n     * @dev The caller must be the the parent messenger, sent over the canonical message bridge.\r\n     * @param data data message sent from the L1 messenger. Should be an encoded function call or packed data.\r\n     * @param target desired recipient of `data`. Target must implement the `processMessageFromParent` function. Having\r\n     * this as a param enables the L1 Messenger to send messages to arbitrary addresses on the L1. This is primarily\r\n     * used to send messages to the OracleSpoke and GovernorSpoke on L2.\r\n     */\r\n    function processMessageFromCrossChainParent(bytes memory data, address target)\r\n        public\r\n        onlyFromCrossDomainAccount(parentMessenger)\r\n        nonReentrant()\r\n    {\r\n        ChildMessengerConsumerInterface(target).processMessageFromParent(data);\r\n        emit MessageReceivedFromParent(data, target, parentMessenger);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/Arbitrum_ParentMessenger.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../external/avm/Arbitrum_Messenger.sol\";\r\nimport \"../interfaces/ParentMessengerInterface.sol\";\r\nimport \"../interfaces/ParentMessengerConsumerInterface.sol\";\r\nimport \"./ParentMessengerBase.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @notice Sends cross chain messages from Ethereum L1 to Arbitrum L2 network.\r\n * @dev This contract is ownable and should be owned by the DVM governor.\r\n */\r\ncontract Arbitrum_ParentMessenger is Arbitrum_Messenger, ParentMessengerInterface, ParentMessengerBase, Lockable {\r\n    event SetDefaultGasLimit(uint32 newDefaultGasLimit);\r\n    event SetDefaultMaxSubmissionCost(uint256 newMaxSubmissionCost);\r\n    event SetDefaultGasPrice(uint256 newDefaultGasPrice);\r\n    event SetRefundL2Address(address newRefundL2Address);\r\n    event MessageSentToChild(\r\n        bytes data,\r\n        address indexed targetSpoke,\r\n        uint256 l1CallValue,\r\n        uint32 gasLimit,\r\n        uint256 gasPrice,\r\n        uint256 maxSubmissionCost,\r\n        address refundL2Address,\r\n        address indexed childMessenger,\r\n        uint256 sequenceNumber\r\n    );\r\n    event MessageReceivedFromChild(bytes data, address indexed childMessenger, address indexed targetHub);\r\n\r\n    // Gas limit for immediate L2 execution attempt (can be estimated via NodeInterface.estimateRetryableTicket).\r\n    // NodeInterface precompile interface exists at L2 address 0x00000000000000000000000000000000000000C8\r\n    uint32 public defaultGasLimit = 5_000_000;\r\n\r\n    // Amount of ETH allocated to pay for the base submission fee. The base submission fee is a parameter unique to\r\n    // retryable transactions; the user is charged the base submission fee to cover the storage costs of keeping their\r\n    // tickets calldata in the retry buffer. (current base submission fee is queryable via\r\n    // ArbRetryableTx.getSubmissionPrice). ArbRetryableTicket precompile interface exists at L2 address\r\n    // 0x000000000000000000000000000000000000006E.\r\n    uint256 public defaultMaxSubmissionCost = 0.1e18;\r\n\r\n    // L2 Gas price bid for immediate L2 execution attempt (queryable via standard eth*gasPrice RPC)\r\n    uint256 public defaultGasPrice = 10e9; // 10 gWei\r\n\r\n    // This address on L2 receives extra ETH that is left over after relaying a message via the inbox.\r\n    address public refundL2Address;\r\n\r\n    /**\r\n     * @notice Construct the Optimism_ParentMessenger contract.\r\n     * @param _inbox Contract that sends generalized messages to the Arbitrum chain.\r\n     * @param _childChainId The chain id of the Optimism L2 network this messenger should connect to.\r\n     **/\r\n    constructor(address _inbox, uint256 _childChainId) Arbitrum_Messenger(_inbox) ParentMessengerBase(_childChainId) {\r\n        refundL2Address = owner();\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the refund address on L2 that receives excess gas or the full msg.value if the retryable\r\n     * ticket reverts.\r\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\r\n     * @param newRefundl2Address the new refund address to set. This should be set to an L2 address that is trusted by\r\n     * the owner as it can spend Arbitrum L2 refunds for excess gas when sending transactions on Arbitrum.\r\n     */\r\n    function setRefundL2Address(address newRefundl2Address) public onlyOwner nonReentrant() {\r\n        refundL2Address = newRefundl2Address;\r\n        emit SetRefundL2Address(refundL2Address);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the default gas limit that is sent along with transactions to Arbitrum.\r\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\r\n     * @param newDefaultGasLimit the new L2 gas limit to be set.\r\n     */\r\n    function setDefaultGasLimit(uint32 newDefaultGasLimit) public onlyOwner nonReentrant() {\r\n        defaultGasLimit = newDefaultGasLimit;\r\n        emit SetDefaultGasLimit(newDefaultGasLimit);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the default gas price that is sent along with transactions to Arbitrum.\r\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\r\n     * @param newDefaultGasPrice the new L2 gas price to be set.\r\n     */\r\n    function setDefaultGasPrice(uint256 newDefaultGasPrice) public onlyOwner nonReentrant() {\r\n        defaultGasPrice = newDefaultGasPrice;\r\n        emit SetDefaultGasPrice(newDefaultGasPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the default max submission cost that is sent along with transactions to Arbitrum.\r\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\r\n     * @param newDefaultMaxSubmissionCost the new L2 max submission cost to be set.\r\n     */\r\n    function setDefaultMaxSubmissionCost(uint256 newDefaultMaxSubmissionCost) public onlyOwner nonReentrant() {\r\n        defaultMaxSubmissionCost = newDefaultMaxSubmissionCost;\r\n        emit SetDefaultMaxSubmissionCost(newDefaultMaxSubmissionCost);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the address of the oracle spoke on L2 via the child messenger.\r\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\r\n     * @dev This function will only succeed if this contract has enough ETH to cover the approximate L1 call value.\r\n     * @param newOracleSpoke the new oracle spoke address set on L2.\r\n     */\r\n    function setChildOracleSpoke(address newOracleSpoke) public onlyOwner nonReentrant() {\r\n        bytes memory dataSentToChild = abi.encodeWithSignature(\"setOracleSpoke(address)\", newOracleSpoke);\r\n        _sendMessageToChild(dataSentToChild, childMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the address of the parent messenger on L2 via the child messenger.\r\n     * @dev The caller of this function must be the owner, which should be set to the DVM governor.\r\n     * @dev This function will only succeed if this contract has enough ETH to cover the approximate L1 call value.\r\n     * @param newParentMessenger the new parent messenger contract to be set on L2.\r\n     */\r\n    function setChildParentMessenger(address newParentMessenger) public onlyOwner nonReentrant() {\r\n        bytes memory dataSentToChild = abi.encodeWithSignature(\"setParentMessenger(address)\", newParentMessenger);\r\n        _sendMessageToChild(dataSentToChild, childMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Sends a message to the child messenger via the canonical message bridge.\r\n     * @dev The caller must be the either the OracleHub or the GovernorHub. This is to send either a\r\n     * price or initiate a governance action to the OracleSpoke or GovernorSpoke on the child network.\r\n     * @dev The recipient of this message is the child messenger. The messenger must implement processMessageFromParent\r\n     * which then forwards the data to the target either the OracleSpoke or the governorSpoke depending on the caller.\r\n     * @dev This function will only succeed if this contract has enough ETH to cover the approximate L1 call value.\r\n     * @param data data message sent to the child messenger. Should be an encoded function call or packed data.\r\n     */\r\n    function sendMessageToChild(bytes memory data) external override onlyHubContract() nonReentrant() {\r\n        address target = msg.sender == oracleHub ? oracleSpoke : governorSpoke;\r\n        bytes memory dataSentToChild =\r\n            abi.encodeWithSignature(\"processMessageFromCrossChainParent(bytes,address)\", data, target);\r\n        _sendMessageToChild(dataSentToChild, target);\r\n    }\r\n\r\n    /**\r\n     * @notice Process a received message from the child messenger via the canonical message bridge.\r\n     * @dev The caller must be the the child messenger, sent over the canonical message bridge.\r\n     * @dev Note that only the OracleHub can receive messages from the child messenger. Therefore we can always forward\r\n     * these messages to this contract. The OracleHub must implement processMessageFromChild to handle this message.\r\n     * @param data data message sent from the child messenger. Should be an encoded function call or packed data.\r\n     */\r\n    function processMessageFromCrossChainChild(bytes memory data)\r\n        public\r\n        onlyFromCrossDomainAccount(childMessenger)\r\n        nonReentrant()\r\n    {\r\n        ParentMessengerConsumerInterface(oracleHub).processMessageFromChild(childChainId, data);\r\n        emit MessageReceivedFromChild(data, childMessenger, oracleHub);\r\n    }\r\n\r\n    /**\r\n     * @notice This function is expected to be queried by Hub contracts that need to determine how much ETH\r\n     * to include in msg.value when calling `sendMessageToChild`.\r\n     * @return Amount of msg.value to include to send cross-chain message.\r\n     */\r\n    function getL1CallValue()\r\n        public\r\n        view\r\n        override(ParentMessengerBase, ParentMessengerInterface)\r\n        nonReentrantView()\r\n        returns (uint256)\r\n    {\r\n        return _getL1CallValue();\r\n    }\r\n\r\n    // We need to allow this contract to receive ETH, so that it can include some msg.value amount on external calls\r\n    // to the `sendMessageToChild` function. We shouldn't expect the owner of this contract to send\r\n    // ETH because the owner is intended to be a contract (e.g. the Governor) and we don't want to change the\r\n    // Governor interface.\r\n    fallback() external payable {}\r\n\r\n    // Used to determine how much ETH to include in msg.value when calling admin functions like\r\n    // `setChildParentMessenger` and sending messages across the bridge.\r\n    function _getL1CallValue() internal view returns (uint256) {\r\n        // This could overflow if these values are set too high, but since they are configurable by trusted owner\r\n        // we won't catch this case.\r\n        return defaultMaxSubmissionCost + defaultGasPrice * defaultGasLimit;\r\n    }\r\n\r\n    // This function will only succeed if this contract has enough ETH to cover the approximate L1 call value.\r\n    function _sendMessageToChild(bytes memory data, address target) internal {\r\n        uint256 requiredL1CallValue = _getL1CallValue();\r\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\r\n\r\n        uint256 seqNumber =\r\n            sendTxToL2NoAliassing(\r\n                childMessenger,\r\n                refundL2Address,\r\n                requiredL1CallValue,\r\n                defaultMaxSubmissionCost,\r\n                defaultGasLimit,\r\n                defaultGasPrice,\r\n                data\r\n            );\r\n        emit MessageSentToChild(\r\n            data,\r\n            target,\r\n            requiredL1CallValue,\r\n            defaultGasLimit,\r\n            defaultGasPrice,\r\n            defaultMaxSubmissionCost,\r\n            refundL2Address,\r\n            childMessenger,\r\n            seqNumber\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/Optimism_ChildMessenger.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n// This should be replaced with a \"real\" import when Optimism release their new contract versions.\r\nimport \"@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol\";\r\nimport \"@eth-optimism/contracts/libraries/constants/Lib_PredeployAddresses.sol\";\r\nimport \"../interfaces/ChildMessengerInterface.sol\";\r\nimport \"../interfaces/ChildMessengerConsumerInterface.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @notice Sends cross chain messages from Optimism L2 to Ethereum L1 network.\r\n * @dev This contract is ownable via the onlyFromCrossDomainAccount. modifier, restricting ownership to the cross-domain\r\n * parent messenger contract that lives on L1.\r\n */\r\ncontract Optimism_ChildMessenger is CrossDomainEnabled, ChildMessengerInterface, Lockable {\r\n    // The only child network contract that can send messages over the bridge via the messenger is the oracle spoke.\r\n    address public oracleSpoke;\r\n\r\n    // Messenger contract on the other side of the L1<->L2 bridge.\r\n    address public parentMessenger;\r\n\r\n    // Hard coded default gas limit for L1 transactions.\r\n    uint32 public defaultGasLimit = 5_000_000;\r\n\r\n    event SetOracleSpoke(address newOracleSpoke);\r\n    event SetParentMessenger(address newParentMessenger);\r\n    event SetDefaultGasLimit(uint32 newDefaultGasLimit);\r\n    event MessageSentToParent(bytes data, address indexed parentAddress, address oracleSpoke, uint32 gasLimit);\r\n    event MessageReceivedFromParent(bytes data, address indexed targetSpoke, address indexed parentAddress);\r\n\r\n    /**\r\n     * @notice Construct the Optimism_ChildMessenger contract.\r\n     * @param _parentMessenger The address of the L1 parent messenger. Acts as the \"owner\" of this contract.\r\n     */\r\n    constructor(address _parentMessenger) CrossDomainEnabled(Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER) {\r\n        parentMessenger = _parentMessenger;\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the stored address of the Oracle spoke, deployed on L2.\r\n     * @dev The caller of this function must be the parent messenger, over the canonical bridge.\r\n     * @param newOracleSpoke address of the new oracle spoke, deployed on L2.\r\n     */\r\n    function setOracleSpoke(address newOracleSpoke) public onlyFromCrossDomainAccount(parentMessenger) nonReentrant() {\r\n        oracleSpoke = newOracleSpoke;\r\n        emit SetOracleSpoke(newOracleSpoke);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the stored address of the parent messenger, deployed on L1.\r\n     * @dev The caller of this function must be the parent messenger, over the canonical bridge.\r\n     * @param newParentMessenger address of the new parent messenger, deployed on L1.\r\n     */\r\n    function setParentMessenger(address newParentMessenger)\r\n        public\r\n        onlyFromCrossDomainAccount(parentMessenger)\r\n        nonReentrant()\r\n    {\r\n        parentMessenger = newParentMessenger;\r\n        emit SetParentMessenger(newParentMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the default gas limit that is sent along with transactions to Ethereum.\r\n     * @dev The caller of this function must be the parent messenger, over the canonical bridge.\r\n     * @param newDefaultGasLimit the new L1 gas limit to be set.\r\n     */\r\n    function setDefaultGasLimit(uint32 newDefaultGasLimit)\r\n        public\r\n        onlyFromCrossDomainAccount(parentMessenger)\r\n        nonReentrant()\r\n    {\r\n        defaultGasLimit = newDefaultGasLimit;\r\n        emit SetDefaultGasLimit(newDefaultGasLimit);\r\n    }\r\n\r\n    /**\r\n     * @notice Sends a message to the parent messenger via the canonical message bridge.\r\n     * @dev The caller must be the OracleSpoke on L2. No other contract is permissioned to call this function.\r\n     * @dev The L1 target, the parent messenger, must implement processMessageFromChild to consume the message.\r\n     * @param data data message sent to the L1 messenger. Should be an encoded function call or packed data.\r\n     */\r\n    function sendMessageToParent(bytes memory data) public override nonReentrant() {\r\n        require(msg.sender == oracleSpoke, \"Only callable by oracleSpoke\");\r\n        bytes memory dataSentToParent = abi.encodeWithSignature(\"processMessageFromCrossChainChild(bytes)\", data);\r\n        sendCrossDomainMessage(parentMessenger, defaultGasLimit, dataSentToParent);\r\n        emit MessageSentToParent(dataSentToParent, parentMessenger, oracleSpoke, defaultGasLimit);\r\n    }\r\n\r\n    /**\r\n     * @notice Process a received message from the parent messenger via the canonical message bridge.\r\n     * @dev The caller must be the the parent messenger, sent over the canonical message bridge.\r\n     * @param data data message sent from the L1 messenger. Should be an encoded function call or packed data.\r\n     * @param target desired recipient of `data`. Target must implement the `processMessageFromParent` function. Having\r\n     * this as a param enables the L1 Messenger to send messages to arbitrary addresses on the L2. This is primarily\r\n     * used to send messages to the OracleSpoke and GovernorSpoke on L2.\r\n     */\r\n    function processMessageFromCrossChainParent(bytes memory data, address target)\r\n        public\r\n        onlyFromCrossDomainAccount(parentMessenger)\r\n        nonReentrant()\r\n    {\r\n        ChildMessengerConsumerInterface(target).processMessageFromParent(data);\r\n        emit MessageReceivedFromParent(data, target, parentMessenger);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/Optimism_ParentMessenger.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n// This should be replaced with a \"real\" import when Optimism release their new contract versions.\r\nimport \"@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol\";\r\nimport \"../interfaces/ParentMessengerInterface.sol\";\r\nimport \"../interfaces/ParentMessengerConsumerInterface.sol\";\r\nimport \"./ParentMessengerBase.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @notice Sends cross chain messages from Ethereum L1 to Optimism L2 network.\r\n * @dev This contract is ownable and should be owned by the DVM governor.\r\n */\r\ncontract Optimism_ParentMessenger is CrossDomainEnabled, ParentMessengerInterface, ParentMessengerBase, Lockable {\r\n    event SetDefaultGasLimit(uint32 newDefaultGasLimit);\r\n    event MessageSentToChild(bytes data, address indexed targetSpoke, uint32 gasLimit, address indexed childMessenger);\r\n    event MessageReceivedFromChild(bytes data, address indexed childMessenger, address indexed targetHub);\r\n\r\n    uint32 public defaultGasLimit = 5_000_000;\r\n\r\n    /**\r\n     * @notice Construct the Optimism_ParentMessenger contract.\r\n     * @param _crossDomainMessenger The address of the Optimism cross domain messenger contract.\r\n     * @param _childChainId The chain id of the Optimism L2 network this messenger should connect to.\r\n     **/\r\n    constructor(address _crossDomainMessenger, uint256 _childChainId)\r\n        CrossDomainEnabled(_crossDomainMessenger)\r\n        ParentMessengerBase(_childChainId)\r\n    {}\r\n\r\n    /**\r\n     * @notice Changes the default gas limit that is sent along with transactions to Optimism.\r\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\r\n     * @param newDefaultGasLimit the new L2 gas limit to be set.\r\n     */\r\n    function setDefaultGasLimit(uint32 newDefaultGasLimit) public onlyOwner nonReentrant() {\r\n        defaultGasLimit = newDefaultGasLimit;\r\n        emit SetDefaultGasLimit(newDefaultGasLimit);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the address of the oracle spoke on L2 via the child messenger.\r\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\r\n     * @param newOracleSpoke the new oracle spoke address set on L2.\r\n     */\r\n    function setChildOracleSpoke(address newOracleSpoke) public onlyOwner nonReentrant() {\r\n        bytes memory dataSentToChild = abi.encodeWithSignature(\"setOracleSpoke(address)\", newOracleSpoke);\r\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\r\n        emit MessageSentToChild(dataSentToChild, address(0), defaultGasLimit, childMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the address of the parent messenger on L2 via the child messenger.\r\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\r\n     * @param newParentMessenger the new parent messenger contract to be set on L2.\r\n     */\r\n    function setChildParentMessenger(address newParentMessenger) public onlyOwner nonReentrant() {\r\n        bytes memory dataSentToChild = abi.encodeWithSignature(\"setParentMessenger(address)\", newParentMessenger);\r\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\r\n        emit MessageSentToChild(dataSentToChild, address(0), defaultGasLimit, childMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the Optimism_ChildMessenger default gas limit on L2 via the child messenger.\r\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\r\n     * @param newDefaultGasLimit the new default gas limit set on L2.\r\n     */\r\n    function setChildDefaultGasLimit(uint32 newDefaultGasLimit) public onlyOwner nonReentrant() {\r\n        bytes memory dataSentToChild = abi.encodeWithSignature(\"setDefaultGasLimit(uint32)\", newDefaultGasLimit);\r\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\r\n        emit MessageSentToChild(dataSentToChild, address(0), defaultGasLimit, childMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Sends a message to the child messenger via the canonical message bridge.\r\n     * @dev The caller must be the either the OracleHub or the GovernorHub. This is to send either a\r\n     * price or initiate a governance action to the OracleSpoke or GovernorSpoke on the child network.\r\n     * @dev The recipient of this message is the child messenger. The messenger must implement processMessageFromParent\r\n     * which then forwards the data to the target either the OracleSpoke or the governorSpoke depending on the caller.\r\n     * @param data data message sent to the child messenger. Should be an encoded function call or packed data.\r\n     */\r\n    function sendMessageToChild(bytes memory data) public override onlyHubContract() nonReentrant() {\r\n        address target = msg.sender == oracleHub ? oracleSpoke : governorSpoke;\r\n        bytes memory dataSentToChild =\r\n            abi.encodeWithSignature(\"processMessageFromCrossChainParent(bytes,address)\", data, target);\r\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\r\n        emit MessageSentToChild(dataSentToChild, target, defaultGasLimit, childMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Process a received message from the child messenger via the canonical message bridge.\r\n     * @dev The caller must be the the child messenger, sent over the canonical message bridge.\r\n     * @dev Note that only the OracleHub can receive messages from the child messenger. Therefore we can always forward\r\n     * these messages to this contract. The OracleHub must implement processMessageFromChild to handle this message.\r\n     * @param data data message sent from the child messenger. Should be an encoded function call or packed data.\r\n     */\r\n    function processMessageFromCrossChainChild(bytes memory data)\r\n        public\r\n        onlyFromCrossDomainAccount(childMessenger)\r\n        nonReentrant()\r\n    {\r\n        ParentMessengerConsumerInterface(oracleHub).processMessageFromChild(childChainId, data);\r\n        emit MessageReceivedFromChild(data, childMessenger, oracleHub);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/ParentMessengerBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../interfaces/ParentMessengerInterface.sol\";\r\n\r\nabstract contract ParentMessengerBase is Ownable, ParentMessengerInterface {\r\n    uint256 public childChainId;\r\n\r\n    address public childMessenger;\r\n\r\n    address public oracleHub;\r\n    address public governorHub;\r\n\r\n    address public oracleSpoke;\r\n    address public governorSpoke;\r\n\r\n    event SetChildMessenger(address indexed childMessenger);\r\n    event SetOracleHub(address indexed oracleHub);\r\n    event SetGovernorHub(address indexed governorHub);\r\n    event SetOracleSpoke(address indexed oracleSpoke);\r\n    event SetGovernorSpoke(address indexed governorSpoke);\r\n\r\n    modifier onlyHubContract() {\r\n        require(msg.sender == oracleHub || msg.sender == governorHub, \"Only privileged caller\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Construct the ParentMessengerBase contract.\r\n     * @param _childChainId The chain id of the L2 network this messenger should connect to.\r\n     **/\r\n    constructor(uint256 _childChainId) {\r\n        childChainId = _childChainId;\r\n    }\r\n\r\n    /*******************\r\n     *  OWNER METHODS  *\r\n     *******************/\r\n\r\n    /**\r\n     * @notice Changes the stored address of the child messenger, deployed on L2.\r\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\r\n     * @param newChildMessenger address of the new child messenger, deployed on L2.\r\n     */\r\n    function setChildMessenger(address newChildMessenger) public onlyOwner {\r\n        childMessenger = newChildMessenger;\r\n        emit SetChildMessenger(childMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the stored address of the Oracle hub, deployed on L1.\r\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\r\n     * @param newOracleHub address of the new oracle hub, deployed on L1 Ethereum.\r\n     */\r\n    function setOracleHub(address newOracleHub) public onlyOwner {\r\n        oracleHub = newOracleHub;\r\n        emit SetOracleHub(oracleHub);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the stored address of the Governor hub, deployed on L1.\r\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\r\n     * @param newGovernorHub address of the new governor hub, deployed on L1 Ethereum.\r\n     */\r\n    function setGovernorHub(address newGovernorHub) public onlyOwner {\r\n        governorHub = newGovernorHub;\r\n        emit SetGovernorHub(governorHub);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the stored address of the oracle spoke, deployed on L2.\r\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\r\n     * @param newOracleSpoke address of the new oracle spoke, deployed on L2.\r\n     */\r\n    function setOracleSpoke(address newOracleSpoke) public onlyOwner {\r\n        oracleSpoke = newOracleSpoke;\r\n        emit SetOracleSpoke(oracleSpoke);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the stored address of the governor spoke, deployed on L2.\r\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\r\n     * @param newGovernorSpoke address of the new governor spoke, deployed on L2.\r\n     */\r\n    function setGovernorSpoke(address newGovernorSpoke) public onlyOwner {\r\n        governorSpoke = newGovernorSpoke;\r\n        emit SetGovernorSpoke(governorSpoke);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the amount of ETH required for a caller to pass as msg.value when calling `sendMessageToChild`.\r\n     * @return The amount of ETH required for a caller to pass as msg.value when calling `sendMessageToChild`.\r\n     */\r\n    function getL1CallValue() external view virtual override returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/Polygon_ChildMessenger.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@maticnetwork/fx-portal/contracts/tunnel/FxBaseChildTunnel.sol\";\r\nimport \"../interfaces/ChildMessengerInterface.sol\";\r\nimport \"../interfaces/ChildMessengerConsumerInterface.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../../common/implementation/HasFinder.sol\";\r\n\r\n/**\r\n * @notice Sends cross chain messages from Polygon to Ethereum network.\r\n * @dev This contract extends the `FxBaseChildTunnel` contract and therefore is 1-to-1 mapped with the\r\n * `FxBaseRootTunnel` extended by the `Polygon_ParentMessenger` contract deployed on Polygon. This mapping ensures that\r\n * the internal `_processMessageFromRoot` function is only callable indirectly by the `Polygon_ParentMessenger`.\r\n */\r\ncontract Polygon_ChildMessenger is FxBaseChildTunnel, ChildMessengerInterface, Lockable, HasFinder {\r\n    event MessageSentToParent(bytes data, address indexed targetHub, address indexed oracleSpoke);\r\n    event MessageReceivedFromParent(address indexed targetSpoke, bytes dataToSendToTarget);\r\n\r\n    /**\r\n     * @notice Construct the Polygon_ChildMessenger contract.\r\n     * @param _finder Used to locate contracts for this network.\r\n     * @param _fxChild Polygon system contract deployed on Mainnet, required to construct new FxBaseRootTunnel\r\n     * that can send messages via native Polygon data tunnel.\r\n     */\r\n    constructor(address _fxChild, address _finder) FxBaseChildTunnel(_fxChild) HasFinder(_finder) {}\r\n\r\n    /**\r\n     * @notice Sends a message to the OracleSpoke via the parent messenger and the canonical message bridge.\r\n     * @dev The caller must be the OracleSpoke on child network. No other contract is permissioned to call this\r\n     * function.\r\n     * @dev The L1 target, the parent messenger, must implement processMessageFromChild to consume the message.\r\n     * @param data data message sent to the L1 messenger. Should be an encoded function call or packed data.\r\n     */\r\n    function sendMessageToParent(bytes memory data) public override nonReentrant() {\r\n        require(msg.sender == getOracleSpoke(), \"Only callable by oracleSpoke\");\r\n        _sendMessageToRoot(abi.encode(data, getOracleHub()));\r\n        emit MessageSentToParent(data, getOracleHub(), getOracleSpoke());\r\n    }\r\n\r\n    /**\r\n     * @notice Process a received message from the parent messenger via the canonical message bridge.\r\n     * @dev The data will be received automatically from the state receiver when the state is synced between Ethereum\r\n     * and Polygon. This will revert if the Root chain sender is not the `fxRootTunnel` contract.\r\n     * @dev This call will revert if `setFxRoot` has not been called and the `sender` is not set to the\r\n     * FxRoot contract address. FxRoot should be set to Polygon_ParentMessenger.\r\n     * @param sender The sender of `data` from the Root chain.\r\n     * @param data ABI encoded params with which to call function on OracleHub or GovernorHub.\r\n     */\r\n    function _processMessageFromRoot(\r\n        uint256, /* stateId */\r\n        address sender,\r\n        bytes memory data\r\n    ) internal override validateSender(sender) nonReentrant() {\r\n        (bytes memory dataToSendToTarget, address target) = abi.decode(data, (bytes, address));\r\n        ChildMessengerConsumerInterface(target).processMessageFromParent(dataToSendToTarget);\r\n        emit MessageReceivedFromParent(target, dataToSendToTarget);\r\n    }\r\n\r\n    function getOracleSpoke() public view returns (address) {\r\n        return finder.getImplementationAddress(OracleInterfaces.OracleSpoke);\r\n    }\r\n\r\n    function getOracleHub() public view returns (address) {\r\n        return finder.getImplementationAddress(OracleInterfaces.OracleHub);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/Polygon_ParentMessenger.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@maticnetwork/fx-portal/contracts/tunnel/FxBaseRootTunnel.sol\";\r\nimport \"../interfaces/ParentMessengerInterface.sol\";\r\nimport \"../interfaces/ParentMessengerConsumerInterface.sol\";\r\nimport \"./ParentMessengerBase.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @notice Sends cross chain messages from Ethereum to Polygon network.\r\n * @dev This contract extends the `FxBaseRootTunnel` contract and therefore is 1-to-1 mapped with the\r\n * `FxBaseChildTunnel` extended by the `Polygon_ChildMessenger` contract deployed on Polygon. This mapping ensures that\r\n * the internal `_processMessageFromChild` function is only callable indirectly by the `Polygon_ChildMessenger`.\r\n */\r\ncontract Polygon_ParentMessenger is FxBaseRootTunnel, ParentMessengerInterface, ParentMessengerBase, Lockable {\r\n    event MessageSentToChild(bytes data, address indexed targetSpoke);\r\n    event MessageReceivedFromChild(address indexed targetHub, bytes dataToSendToTarget);\r\n\r\n    /**\r\n     * @notice Construct the Optimism_ParentMessenger contract.\r\n     * @param _checkpointManager The address of the Polygon checkpoint manager deployed on Mainnet. Required to\r\n     * construct new FxBaseRootTunnel that can connect to native Polygon data tunnel.\r\n     * @param _fxRoot Polygon system contract deployed on Mainnet, required to construct new FxBaseRootTunnel\r\n     * that can send messages via native Polygon data tunnel.\r\n     * @param _childChainId The chain id of the Optimism L2 network this messenger should connect to.\r\n     **/\r\n    constructor(\r\n        address _checkpointManager,\r\n        address _fxRoot,\r\n        uint256 _childChainId\r\n    ) FxBaseRootTunnel(_checkpointManager, _fxRoot) ParentMessengerBase(_childChainId) {}\r\n\r\n    /**\r\n     * @notice Sends a message to the child messenger via the canonical message bridge.\r\n     * @dev The caller must be the either the OracleHub or the GovernorHub. This is to send either a\r\n     * price or initiate a governance action to the OracleSpoke or GovernorSpoke on the child chain.\r\n     * @dev The recipient of this message is the child messenger. The messenger must implement _processMessageFromRoot\r\n     * which then forwards the data to the target either the OracleSpoke or the governorSpoke depending on the caller.\r\n     * @param data data message sent to the child messenger. Should be an encoded function call or packed data.\r\n     */\r\n    function sendMessageToChild(bytes memory data) public override onlyHubContract() nonReentrant() {\r\n        address target = msg.sender == oracleHub ? oracleSpoke : governorSpoke;\r\n        bytes memory dataToSendToChild = abi.encode(data, target);\r\n        _sendMessageToChild(dataToSendToChild);\r\n        emit MessageSentToChild(dataToSendToChild, target);\r\n    }\r\n\r\n    /**\r\n     * @notice Process a received message from the child messenger via the canonical message bridge.\r\n     * @dev This internal method will be called inside `FxBaseRootTunnel.receiveMessage(bytes memory inputData)`,\r\n     * which must be called by an EOA to finalize the relay of the message from Polygon to Ethereum.\r\n     * The `inputData` is a proof of transaction that is derived from the transaction hash of the transaction on the\r\n     * child chain that originated the cross-chain price request via _sendMessageToRoot.\r\n     * @dev This call will revert if `setFxChild` has not been called. Fx Child should be set to Polygon_ChildMessenger.\r\n     * @param data ABI encoded params with which to call function on OracleHub or GovernorHub.\r\n     */\r\n    function _processMessageFromChild(bytes memory data) internal override nonReentrant() {\r\n        // We know that this internal execution can only be triggered by the ChildMessenger, which inherits\r\n        // FxBaseChildTunnel and is mapped 1-to-1 with this contract's FxBaseRootTunnel via\r\n        // `setFxRootTunnel/setFxChildTunnel`.\r\n        (bytes memory dataToSendToTarget, address target) = abi.decode(data, (bytes, address));\r\n        ParentMessengerConsumerInterface(target).processMessageFromChild(childChainId, dataToSendToTarget);\r\n        emit MessageReceivedFromChild(target, dataToSendToTarget);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/test/Arbitrum_inboxMock.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\nimport \"../../../external/avm/interfaces/iArbitrum_Inbox.sol\";\r\nimport \"../../../cross-chain-oracle/chain-adapters/Arbitrum_ParentMessenger.sol\";\r\n\r\ncontract Arbitrum_OutboxMock {\r\n    function l2ToL1Sender() external view returns (address) {\r\n        // Function not called in tests, only smocked.\r\n        return address(this);\r\n    }\r\n}\r\n\r\ncontract Arbitrum_BridgeMock {\r\n    address public outbox;\r\n\r\n    function setOutbox(address _outbox) external {\r\n        outbox = _outbox;\r\n    }\r\n\r\n    function activeOutbox() external view returns (address) {\r\n        return outbox;\r\n    }\r\n\r\n    // This function can be called by an EOA to send a call to the parent messenger, which is important in tests\r\n    // because `processMessageFromCrossChainChild` can only be called by the Bridge contract.\r\n    function processMessageFromCrossChainChild(address payable messengerToCall, bytes memory data) external {\r\n        Arbitrum_ParentMessenger(messengerToCall).processMessageFromCrossChainChild(data);\r\n    }\r\n}\r\n\r\ncontract Arbitrum_InboxMock is iArbitrum_Inbox {\r\n    // We leave these unused function parameters named because this contract is used with smockit and makes testing\r\n    // this function's call inputs easier.\r\n    function createRetryableTicketNoRefundAliasRewrite(\r\n        address destAddr,\r\n        uint256 l2CallValue,\r\n        uint256 maxSubmissionCost,\r\n        address excessFeeRefundAddress,\r\n        address callValueRefundAddress,\r\n        uint256 maxGas,\r\n        uint256 gasPriceBid,\r\n        bytes calldata data\r\n    ) external payable override returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function bridge() external view returns (address) {\r\n        // Function not called in tests, only smocked.\r\n        return address(this);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/test/OVM_L1CrossDomainMessengerMock.sol": {
      "content": "pragma solidity ^0.8.0;\r\nimport \"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\";\r\n\r\ncontract OVM_L1CrossDomainMessengerMock is ICrossDomainMessenger {\r\n    function xDomainMessageSender() external view override returns (address) {\r\n        // Trivial return this contract's address.\r\n        return address(this);\r\n    }\r\n\r\n    function sendMessage(\r\n        address _target,\r\n        bytes calldata _message,\r\n        uint32 _gasLimit\r\n    ) external override {}\r\n    // Do nothing.\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/test/ParentMessengerBaseMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../ParentMessengerBase.sol\";\r\n\r\ncontract ParentMessengerBaseMock is ParentMessengerBase {\r\n    constructor(uint256 _childChainId) ParentMessengerBase(_childChainId) {}\r\n\r\n    function sendMessageToChild(bytes memory) public view override {\r\n        require(false, \"unused function\");\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/test/Polygon_ChildMessengerMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../Polygon_ChildMessenger.sol\";\r\n\r\ncontract Polygon_ChildMessengerMock is Polygon_ChildMessenger {\r\n    constructor(address _fxChild, address _finder) Polygon_ChildMessenger(_fxChild, _finder) {}\r\n\r\n    function processMessageFromRoot(address sender, bytes memory data) external {\r\n        _processMessageFromRoot(\r\n            1, // Unused param set to arbitrary value.\r\n            sender,\r\n            data\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/test/Polygon_ParentMessengerMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../Polygon_ParentMessenger.sol\";\r\n\r\ncontract Polygon_ParentMessengerMock is Polygon_ParentMessenger {\r\n    constructor(\r\n        address _checkpointManager,\r\n        address _fxRoot,\r\n        uint256 _childChainId\r\n    ) Polygon_ParentMessenger(_checkpointManager, _fxRoot, _childChainId) {}\r\n\r\n    function processMessageFromChild(bytes memory data) external {\r\n        _processMessageFromChild(data);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/GovernorHub.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../common/implementation/Lockable.sol\";\r\nimport \"../common/implementation/MultiCaller.sol\";\r\nimport \"./interfaces/ParentMessengerInterface.sol\";\r\nimport \"./GovernorSpoke.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @title Cross-chain Oracle L1 Governor Hub.\r\n * @notice Governance relayer contract to be deployed on Ethereum that receives messages from the owner (Governor) and\r\n * sends them to spoke contracts on child chains.\r\n */\r\n\r\ncontract GovernorHub is Ownable, Lockable, MultiCaller {\r\n    // Associates chain ID with ParentMessenger contract to use to send governance actions to that chain's GovernorSpoke\r\n    // contract.\r\n    mapping(uint256 => ParentMessengerInterface) public messengers;\r\n\r\n    event RelayedGovernanceRequest(\r\n        uint256 indexed chainId,\r\n        address indexed messenger,\r\n        GovernorSpoke.Call[] calls,\r\n        bytes dataSentToChild\r\n    );\r\n    event SetParentMessenger(uint256 indexed chainId, address indexed parentMessenger);\r\n\r\n    /**\r\n     * @notice Set new ParentMessenger contract for chainId.\r\n     * @param chainId child network that messenger contract will communicate with.\r\n     * @param messenger ParentMessenger contract that sends messages to ChildMessenger on network with ID `chainId`.\r\n     * @dev Only callable by the owner (presumably the Ethereum Governor contract).\r\n     */\r\n    function setMessenger(uint256 chainId, ParentMessengerInterface messenger) public nonReentrant() onlyOwner {\r\n        messengers[chainId] = messenger;\r\n        emit SetParentMessenger(chainId, address(messenger));\r\n    }\r\n\r\n    /**\r\n     * @notice This should be called in order to relay a governance request to the `GovernorSpoke` contract deployed to\r\n     * the child chain associated with `chainId`.\r\n     * @param chainId network that messenger contract will communicate with\r\n     * @param calls the calls to be made by the GovernorSpoke. Should encode a `to` and `data` prop for each call.\r\n     * @dev Only callable by the owner (presumably the UMA DVM Governor contract, on L1 Ethereum).\r\n     */\r\n    function relayGovernance(uint256 chainId, GovernorSpoke.Call[] memory calls) external nonReentrant() onlyOwner {\r\n        bytes memory dataSentToChild = abi.encode(calls);\r\n        messengers[chainId].sendMessageToChild(dataSentToChild);\r\n        emit RelayedGovernanceRequest(chainId, address(messengers[chainId]), calls, dataSentToChild);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/GovernorSpoke.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./interfaces/ChildMessengerConsumerInterface.sol\";\r\nimport \"../common/implementation/Lockable.sol\";\r\nimport \"./SpokeBase.sol\";\r\n\r\n/**\r\n * @title Cross-chain Oracle L2 Governor Spoke.\r\n * @notice Governor contract deployed on L2 that receives governance actions from Ethereum.\r\n */\r\ncontract GovernorSpoke is Lockable, SpokeBase, ChildMessengerConsumerInterface {\r\n    struct Call {\r\n        address to;\r\n        bytes data;\r\n    }\r\n\r\n    constructor(address _finderAddress) HasFinder(_finderAddress) {}\r\n\r\n    event ExecutedGovernanceTransaction(address indexed to, bytes data);\r\n\r\n    /**\r\n     * @notice Executes governance transaction created on Ethereum.\r\n     * @dev Can only be called by ChildMessenger contract that wants to execute governance action on this child chain\r\n     * that originated from DVM voters on root chain. ChildMessenger should only receive communication from\r\n     * ParentMessenger on mainnet. See the SpokeBase for the onlyMessenger modifier.\r\n\r\n     * @param data Contains the target address and the encoded function selector + ABI encoded params to include in\r\n     * delegated transaction.\r\n     */\r\n    function processMessageFromParent(bytes memory data) public override nonReentrant() onlyMessenger() {\r\n        Call[] memory calls = abi.decode(data, (Call[]));\r\n\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (address to, bytes memory inputData) = (calls[i].to, calls[i].data);\r\n            require(_executeCall(to, inputData), \"execute call failed\");\r\n            emit ExecutedGovernanceTransaction(to, inputData);\r\n        }\r\n    }\r\n\r\n    // Note: this snippet of code is copied from Governor.sol.\r\n    function _executeCall(address to, bytes memory data) private returns (bool) {\r\n        // Note: this snippet of code is copied from Governor.sol and modified to not include any \"value\" field.\r\n        // solhint-disable-next-line no-inline-assembly\r\n\r\n        bool success;\r\n        assembly {\r\n            let inputData := add(data, 0x20)\r\n            let inputDataSize := mload(data)\r\n            // Hardcode value to be 0 for relayed governance calls in order to avoid addressing complexity of bridging\r\n            // value cross-chain.\r\n            success := call(gas(), to, 0, inputData, inputDataSize, 0, 0)\r\n        }\r\n        return success;\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/interfaces/ChildMessengerConsumerInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\ninterface ChildMessengerConsumerInterface {\r\n    // Called on L2 by child messenger.\r\n    function processMessageFromParent(bytes memory data) external;\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/interfaces/ChildMessengerInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\ninterface ChildMessengerInterface {\r\n    // Should send cross-chain message to Parent messenger contract or revert.\r\n    function sendMessageToParent(bytes memory data) external;\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/interfaces/ParentMessengerConsumerInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\ninterface ParentMessengerConsumerInterface {\r\n    // Function called on Oracle hub to pass in data send from L2, with chain ID.\r\n    function processMessageFromChild(uint256 chainId, bytes memory data) external;\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/interfaces/ParentMessengerInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\ninterface ParentMessengerInterface {\r\n    // Should send cross-chain message to Child messenger contract or revert.\r\n    function sendMessageToChild(bytes memory data) external;\r\n\r\n    // Informs Hub how much msg.value they need to include to call `sendMessageToChild`.\r\n    function getL1CallValue() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/OracleBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../common/implementation/HasFinder.sol\";\r\n\r\n/**\r\n * @title Cross-chain Oracle L1 Oracle Base.\r\n * @notice Enforces lifecycle of price requests for deriving contract.\r\n */\r\nabstract contract OracleBase is HasFinder {\r\n    enum RequestState { NeverRequested, Requested, Resolved }\r\n\r\n    struct Price {\r\n        RequestState state;\r\n        int256 price;\r\n    }\r\n\r\n    // Mapping of encoded price requests {identifier, time, ancillaryData} to Price objects.\r\n    mapping(bytes32 => Price) internal prices;\r\n\r\n    event PriceRequestAdded(bytes32 indexed identifier, uint256 time, bytes ancillaryData, bytes32 indexed requestHash);\r\n    event PushedPrice(\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        int256 price,\r\n        bytes32 indexed requestHash\r\n    );\r\n\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the given (identifier, time,\r\n     * ancillary data) combination. Will only emit an event if the request has never been requested.\r\n     * @return True if price request is new, false otherwise. This is useful for caller to keep track of\r\n     * duplicate price requests.\r\n     */\r\n    function _requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) internal returns (bool) {\r\n        require(ancillaryData.length <= OptimisticOracleConstraints.ancillaryBytesLimit, \"Invalid ancillary data\");\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\r\n        Price storage lookup = prices[priceRequestId];\r\n        if (lookup.state == RequestState.NeverRequested) {\r\n            lookup.state = RequestState.Requested;\r\n            emit PriceRequestAdded(identifier, time, ancillaryData, priceRequestId);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Publishes price for a requested query.\r\n     * @dev Does not update price state if price is already resolved.\r\n     */\r\n    function _publishPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) internal {\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\r\n        Price storage lookup = prices[priceRequestId];\r\n        if (lookup.state == RequestState.Resolved) return;\r\n        lookup.price = price;\r\n        lookup.state = RequestState.Resolved;\r\n        emit PushedPrice(identifier, time, ancillaryData, lookup.price, priceRequestId);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the convenient way to store price requests, uniquely identified by {identifier, time,\r\n     * ancillaryData }.\r\n     */\r\n    function _encodePriceRequest(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(identifier, time, ancillaryData));\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/OracleHub.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./OracleBase.sol\";\r\nimport \"../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../data-verification-mechanism/interfaces/StoreInterface.sol\";\r\nimport \"../common/implementation/Lockable.sol\";\r\nimport \"../common/implementation/MultiCaller.sol\";\r\nimport \"./interfaces/ParentMessengerInterface.sol\";\r\nimport \"./interfaces/ParentMessengerConsumerInterface.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title Cross-chain Oracle L1 Oracle Hub.\r\n * @notice Gatekeeper contract deployed on mainnet that validates and sends price requests from sidechain to the DVM on\r\n * mainnet. This is a \"gate keeper\" contract because it performs the final validation for any messages originating from\r\n * a child chain's oracle before submitting price requests to the DVM. This contract also can publish DVM price\r\n * resolution data to OracleSpokes on any chainId via the messenger for that chainId.\r\n * @dev This contract must be a registered financial contract in order to make and query DVM price requests.\r\n */\r\n\r\ncontract OracleHub is OracleBase, ParentMessengerConsumerInterface, Ownable, Lockable, MultiCaller {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Currency that final fees are paid in.\r\n    IERC20 public token;\r\n\r\n    // Associates chain ID with ParentMessenger contract to use to send price resolutions to that chain's OracleSpoke\r\n    // contract via its ChildMessenger contract.\r\n    mapping(uint256 => ParentMessengerInterface) public messengers;\r\n\r\n    event SetParentMessenger(uint256 indexed chainId, address indexed parentMessenger);\r\n\r\n    constructor(address _finderAddress, IERC20 _token) HasFinder(_finderAddress) {\r\n        token = _token;\r\n    }\r\n\r\n    modifier onlyMessenger(uint256 chainId) {\r\n        require(msg.sender == address(messengers[chainId]), \"Caller must be messenger for network\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Set new ParentMessenger contract for chainId.\r\n     * @param chainId network that has a child messenger contract that parent messenger contract will communicate with.\r\n     * @param messenger ParentMessenger contract that sends messages to ChildMessenger on network with ID `chainId`.\r\n     * @dev Only callable by the owner (presumably the Ethereum Governor contract).\r\n     */\r\n    function setMessenger(uint256 chainId, ParentMessengerInterface messenger) public nonReentrant() onlyOwner {\r\n        messengers[chainId] = messenger;\r\n        emit SetParentMessenger(chainId, address(messenger));\r\n    }\r\n\r\n    /**\r\n     * @notice Publishes a DVM resolved price to the OracleSpoke deployed on the network linked  with `chainId`, or\r\n     * reverts if not resolved yet. This contract must be registered with the DVM to query price requests.\r\n     * The DVM price resolution is communicated to the OracleSpoke via the Parent-->Child messenger channel.\r\n     * @dev This method will always attempt to call `messenger.sendMessageToChild` even if it is a duplicate call for\r\n     * this price request. Therefore the Messenger contract for this `chainId` should determine how to handle duplicate\r\n     * calls.\r\n     * @dev This method is `payable` so that ETH can be forwarded to Messenger contracts that need to send ETH\r\n     * from L1 to L2, like Arbitrum messengers for example. For networks that do not use ETH, the caller will\r\n     * lose ETH, therefore it is the caller's responsibility to know when to send ETH. This is allowed to be\r\n     * `payable` because any EOA can call this function.\r\n     * @param chainId Network to resolve price for.\r\n     * @param identifier Identifier of price request to resolve.\r\n     * @param time Timestamp of price request to resolve.\r\n     * @param ancillaryData extra data of price request to resolve.\r\n     */\r\n    function publishPrice(\r\n        uint256 chainId,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public payable nonReentrant() {\r\n        // `getPrice` will revert if there is no price.\r\n        int256 price = _getOracle().getPrice(identifier, time, ancillaryData);\r\n        _publishPrice(identifier, time, ancillaryData, price);\r\n\r\n        // Require caller to include enough ETH to pass to Messenger so that caller cannot take advantage of excess\r\n        // ETH held by the Messenger. Caller can easily query messenger to get exact amount of ETh to send.\r\n        uint256 requiredL1CallValue = messengers[chainId].getL1CallValue();\r\n        require(msg.value == requiredL1CallValue, \"Insufficient msg.value\");\r\n\r\n        // Call returns a boolean value indicating success or failure.\r\n        // This is the current recommended method to use: https://solidity-by-example.org/sending-ether/\r\n        if (msg.value > 0) {\r\n            (bool sent, ) = address(messengers[chainId]).call{ value: msg.value }(\"\");\r\n            require(sent, \"Cannot send ETH to messenger\");\r\n        }\r\n\r\n        // Pass all msg.value to Messenger:\r\n        messengers[chainId].sendMessageToChild(abi.encode(identifier, time, ancillaryData, price));\r\n    }\r\n\r\n    /**\r\n     * @notice Submits a price request originating from an OracleSpoke. Request data must be sent via the\r\n     * Child --> Parent Messenger communication channel. Returns silently if price request is a duplicate.\r\n     * @dev This contract must be registered to submit price requests to the DVM. Only the ParentMessenger\r\n     * can call this method. If the original requester on the child chain wants to expedite the Child --> Parent\r\n     * message, then they can call `requestPrice` on this contract for the same unique price request.\r\n     * @param chainId id of the child chain that sent the price request.\r\n     * @param data ABI encoded params with which to call `_requestPrice`.\r\n     */\r\n    function processMessageFromChild(uint256 chainId, bytes memory data)\r\n        public\r\n        override\r\n        nonReentrant()\r\n        onlyMessenger(chainId)\r\n    {\r\n        (bytes32 identifier, uint256 time, bytes memory ancillaryData) = abi.decode(data, (bytes32, uint256, bytes));\r\n        bool newPriceRequested = _requestPrice(identifier, time, ancillaryData);\r\n        if (newPriceRequested) {\r\n            _getOracle().requestPrice(identifier, time, ancillaryData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Anyone can call this method to directly request a price to the DVM. This could be used by the child\r\n     * chain requester in the case where Child --> Parent communication takes too long and the requester wants to speed\r\n     * up the price resolution process. Returns silently if price request is a duplicate. Calling this method from\r\n     * the user's point of view is no different than calling the OptimisticOracle.requestPrice method, but with a\r\n     * different interface.\r\n     * @dev The caller must pay a final fee and have approved this contract to pull final fee from it.\r\n     * @dev If the price request params including the ancillary data does not match exactly the price request submitted\r\n     * on the child chain, then the child chain's price request will not resolve. The caller is recommended to use the\r\n     * `stampAncillaryData` method on the OracleSpoke to reconstruct the ancillary data.\r\n     * @param identifier Identifier for price request.\r\n     * @param time time for price request.\r\n     * @param ancillaryData Extra data for price request.\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public nonReentrant() {\r\n        bool newPriceRequested = _requestPrice(identifier, time, ancillaryData);\r\n        if (newPriceRequested) {\r\n            uint256 finalFee = _getStore().computeFinalFee(address(token)).rawValue;\r\n            token.safeTransferFrom(msg.sender, address(_getStore()), finalFee);\r\n            _getOracle().requestPrice(identifier, time, ancillaryData);\r\n        }\r\n    }\r\n\r\n    function _getOracle() internal view returns (OracleAncillaryInterface) {\r\n        return OracleAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/OracleSpoke.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../data-verification-mechanism/interfaces/OracleInterface.sol\";\r\nimport \"../data-verification-mechanism/interfaces/RegistryInterface.sol\";\r\nimport \"./OracleBase.sol\";\r\nimport \"../common/implementation/AncillaryData.sol\";\r\nimport \"../common/implementation/Lockable.sol\";\r\nimport \"./interfaces/ChildMessengerInterface.sol\";\r\nimport \"./interfaces/ChildMessengerConsumerInterface.sol\";\r\nimport \"./SpokeBase.sol\";\r\n\r\n/**\r\n * @title Cross-chain Oracle L2 Oracle Spoke.\r\n * @notice This contract is primarily intended to receive messages on the child chain from a parent chain and allow\r\n * contracts deployed on the child chain to interact with this contract as an Oracle. Moreover, this contract gives\r\n * child chain contracts the ability to trigger cross-chain price requests to the mainnet DVM. This Spoke knows how\r\n * to communicate with the parent chain via a \"ChildMessenger\" contract which directly communicates with the\r\n * \"ParentMessenger\" on mainnet.\r\n * @dev The intended client of this contract is an OptimisticOracle on sidechain that needs price\r\n * resolution secured by the DVM on mainnet.\r\n */\r\ncontract OracleSpoke is\r\n    OracleBase,\r\n    SpokeBase,\r\n    OracleAncillaryInterface,\r\n    OracleInterface,\r\n    ChildMessengerConsumerInterface,\r\n    Lockable\r\n{\r\n    constructor(address _finderAddress) HasFinder(_finderAddress) {}\r\n\r\n    // This assumes that the local network has a Registry that resembles the mainnet registry.\r\n    modifier onlyRegisteredContract() {\r\n        RegistryInterface registry = RegistryInterface(finder.getImplementationAddress(OracleInterfaces.Registry));\r\n        require(registry.isContractRegistered(msg.sender), \"Caller must be registered\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice This is called to bridge a price request to mainnet. This method will enqueue a new price request\r\n     * or return silently if already requested. Price requests are relayed to mainnet (the \"Parent\" chain) via the\r\n     * ChildMessenger contract.\r\n     * @dev Can be called only by a registered contract that is allowed to make DVM price requests. Will mark this\r\n     * price request as Requested, and therefore able to receive the price resolution data from mainnet.\r\n     * @dev Contract registration enables the DVM to validate that the calling contract correctly pays final fees.\r\n     * Therefore, this function does not directly attempt to pull a final fee from the caller.\r\n     * @param identifier Identifier of price request.\r\n     * @param time Timestamp of price request.\r\n     * @param ancillaryData extra data of price request.\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public override nonReentrant() onlyRegisteredContract() {\r\n        bool newPriceRequested = _requestPrice(identifier, time, _stampAncillaryData(ancillaryData));\r\n        if (newPriceRequested) {\r\n            getChildMessenger().sendMessageToParent(abi.encode(identifier, time, _stampAncillaryData(ancillaryData)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Overloaded function to provide backwards compatibility for legacy financial contracts that do not use\r\n     * ancillary data.\r\n     */\r\n    function requestPrice(bytes32 identifier, uint256 time) public override nonReentrant() onlyRegisteredContract() {\r\n        bool newPriceRequested = _requestPrice(identifier, time, _stampAncillaryData(\"\"));\r\n        if (newPriceRequested) {\r\n            getChildMessenger().sendMessageToParent(abi.encode(identifier, time, _stampAncillaryData(\"\")));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Resolves a price request originating from a message sent by the DVM on the parent chain.\r\n     * @dev Can only be called by the ChildMessenger contract which is designed to communicate only with the\r\n     * ParentMessenger contract on Mainnet. See the SpokeBase for the onlyMessenger modifier.\r\n     * @param data ABI encoded params with which to call `_publishPrice`.\r\n     */\r\n    function processMessageFromParent(bytes memory data) public override nonReentrant() onlyMessenger() {\r\n        (bytes32 identifier, uint256 time, bytes memory ancillaryData, int256 price) =\r\n            abi.decode(data, (bytes32, uint256, bytes, int256));\r\n        _publishPrice(identifier, time, ancillaryData, price);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether a price has resolved for the request. This method will not revert.\r\n     * @param identifier Identifier of price request.\r\n     * @param time Timestamp of price request\r\n     * @param ancillaryData extra data of price request.\r\n     * @return True if a price is available, False otherwise. If true, then getPrice will succeed for the request.\r\n     */\r\n    function hasPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() onlyRegisteredContract() returns (bool) {\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, _stampAncillaryData(ancillaryData));\r\n        return prices[priceRequestId].state == RequestState.Resolved;\r\n    }\r\n\r\n    /**\r\n     * @notice Overloaded function to provide backwards compatibility for legacy financial contracts that do not use\r\n     * ancillary data.\r\n     */\r\n    function hasPrice(bytes32 identifier, uint256 time)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        onlyRegisteredContract()\r\n        returns (bool)\r\n    {\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, _stampAncillaryData(\"\"));\r\n        return prices[priceRequestId].state == RequestState.Resolved;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns resolved price for the request. Reverts if price is not available.\r\n     * @param identifier Identifier of price request.\r\n     * @param time Timestamp of price request\r\n     * @param ancillaryData extra data of price request.\r\n     * @return int256 Price, or reverts if no resolved price for any reason.\r\n     */\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() onlyRegisteredContract() returns (int256) {\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, _stampAncillaryData(ancillaryData));\r\n        Price storage lookup = prices[priceRequestId];\r\n        require(lookup.state == RequestState.Resolved, \"Price has not been resolved\");\r\n        return lookup.price;\r\n    }\r\n\r\n    /**\r\n     * @notice Overloaded function to provide backwards compatibility for legacy financial contracts that do not use\r\n     * ancillary data.\r\n     */\r\n    function getPrice(bytes32 identifier, uint256 time)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        onlyRegisteredContract()\r\n        returns (int256)\r\n    {\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, _stampAncillaryData(\"\"));\r\n        Price storage lookup = prices[priceRequestId];\r\n        require(lookup.state == RequestState.Resolved, \"Price has not been resolved\");\r\n        return lookup.price;\r\n    }\r\n\r\n    /**\r\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the stamped ancillary bytes.\r\n     */\r\n    function stampAncillaryData(bytes memory ancillaryData) public view nonReentrantView() returns (bytes memory) {\r\n        return _stampAncillaryData(ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @dev We don't handle specifically the case where `ancillaryData` is not already readily translatable in utf8.\r\n     * For those cases, we assume that the client will be able to strip out the utf8-translatable part of the\r\n     * ancillary data that this contract stamps.\r\n     */\r\n    function _stampAncillaryData(bytes memory ancillaryData) internal view returns (bytes memory) {\r\n        // This contract should stamp the child network's ID so that voters on the parent network can\r\n        // deterministically track unique price requests back to this contract.\r\n        return AncillaryData.appendKeyValueUint(ancillaryData, \"childChainId\", block.chainid);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/SpokeBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\nimport \"./interfaces/ChildMessengerInterface.sol\";\r\n\r\nimport \"../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../common/implementation/HasFinder.sol\";\r\n\r\n/**\r\n * @title Cross-chain Oracle L2 Spoke Base.\r\n * @notice Provides access control to Governance and Oracle spoke L2 contracts.\r\n */\r\n\r\nabstract contract SpokeBase is HasFinder {\r\n    modifier onlyMessenger() {\r\n        require(msg.sender == address(getChildMessenger()), \"Caller must be messenger\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the child messenger address set in the finder.\r\n     * @return ChildMessengerInterface instance of child messenger deployed on L2.\r\n     */\r\n    function getChildMessenger() public view returns (ChildMessengerInterface) {\r\n        return ChildMessengerInterface(finder.getImplementationAddress(OracleInterfaces.ChildMessenger));\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/test/GovernorMessengerMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../GovernorSpoke.sol\";\r\n\r\n/**\r\n * @notice Can be used as either a Parent or Child messenger mock in unit tests for the Governor Hub and Spoke\r\n * cross-chain contracts. The reason that this can't also be used for the Oracle Hub and Spoke is that the\r\n * sendMessageToChild is called with different encoded data in the Oracle versus the Governor.\r\n */\r\ncontract GovernorMessengerMock {\r\n    GovernorSpoke.Call[] private _latestCalls;\r\n\r\n    function latestCalls() external view returns (GovernorSpoke.Call[] memory) {\r\n        return _latestCalls;\r\n    }\r\n\r\n    function sendMessageToChild(bytes memory data) external {\r\n        delete _latestCalls;\r\n        GovernorSpoke.Call[] memory calls = abi.decode(data, (GovernorSpoke.Call[]));\r\n        for (uint256 i = 0; i < calls.length; i++) _latestCalls.push(calls[i]);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/test/OracleBaseMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../OracleBase.sol\";\r\n\r\n/**\r\n * @title Test implementation of OracleBase enabling unit tests on internal methods.\r\n */\r\ncontract OracleBaseMock is OracleBase {\r\n    constructor(address _finderAddress) HasFinder(_finderAddress) {}\r\n\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public returns (bool) {\r\n        return _requestPrice(identifier, time, ancillaryData);\r\n    }\r\n\r\n    function encodePriceRequest(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public pure returns (bytes32) {\r\n        return _encodePriceRequest(identifier, time, ancillaryData);\r\n    }\r\n\r\n    function publishPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) public {\r\n        _publishPrice(identifier, time, ancillaryData, price);\r\n    }\r\n}\r\n"
    },
    "contracts/cross-chain-oracle/test/OracleMessengerMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../OracleHub.sol\";\r\nimport \"../OracleSpoke.sol\";\r\nimport \"../interfaces/ParentMessengerInterface.sol\";\r\n\r\n/**\r\n * @notice Can be used as either a Parent or Child messenger mock in unit tests for the Oracle Hub and Spoke\r\n * cross-chain contracts. The reason that this can't also be used for the Governor Hub and Spoke is that the\r\n * sendMessageToChild is called with different encoded data in the Oracle versus the Governor.\r\n */\r\ncontract OracleMessengerMock is ParentMessengerInterface {\r\n    bytes public latestAncillaryData;\r\n    uint256 public latestTime;\r\n    bytes32 public latestIdentifier;\r\n    int256 public latestPrice;\r\n\r\n    uint256 public messageCount;\r\n\r\n    // OracleHub calls `sendMessageToChild`\r\n    function sendMessageToChild(bytes memory data) external override {\r\n        (latestIdentifier, latestTime, latestAncillaryData, latestPrice) = abi.decode(\r\n            data,\r\n            (bytes32, uint256, bytes, int256)\r\n        );\r\n        messageCount++;\r\n    }\r\n\r\n    function getL1CallValue() public pure override returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    // This calls `processMessageFromChild` on OracleHub\r\n    function requestPrice(\r\n        address oracleHub,\r\n        uint256 chainId,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) external {\r\n        OracleHub(oracleHub).processMessageFromChild(chainId, abi.encode(identifier, time, ancillaryData));\r\n    }\r\n\r\n    // OracleSpoke calls `sendMessageToParent`\r\n    function sendMessageToParent(bytes memory data) external {\r\n        (latestIdentifier, latestTime, latestAncillaryData) = abi.decode(data, (bytes32, uint256, bytes));\r\n        messageCount++;\r\n    }\r\n\r\n    // This calls `processMessageFromParent` on OracleSpoke\r\n    function publishPrice(\r\n        address oracleSpoke,\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) external {\r\n        OracleSpoke(oracleSpoke).processMessageFromParent(abi.encode(identifier, time, ancillaryData, price));\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/AdminIdentifierLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title Library to construct admin identifiers.\r\n */\r\nlibrary AdminIdentifierLib {\r\n    // Returns a UTF-8 identifier representing a particular admin proposal.\r\n    // The identifier is of the form \"Admin n\", where n is the proposal id provided.\r\n    function _constructIdentifier(uint256 id) internal pure returns (bytes32) {\r\n        bytes32 bytesId = _uintToUtf8(id);\r\n        return _addPrefix(bytesId, \"Admin \", 6);\r\n    }\r\n\r\n    // This method converts the integer `v` into a base-10, UTF-8 representation stored in a `bytes32` type.\r\n    // If the input cannot be represented by 32 base-10 digits, it returns only the highest 32 digits.\r\n    // This method is based off of this code: https://ethereum.stackexchange.com/a/6613/47801.\r\n    function _uintToUtf8(uint256 v) internal pure returns (bytes32) {\r\n        bytes32 ret;\r\n        if (v == 0) {\r\n            // Handle 0 case explicitly.\r\n            ret = \"0\";\r\n        } else {\r\n            // Constants.\r\n            uint256 bitsPerByte = 8;\r\n            uint256 base = 10; // Note: the output should be base-10. The below implementation will not work for bases > 10.\r\n            uint256 utf8NumberOffset = 48;\r\n            while (v > 0) {\r\n                // Downshift the entire bytes32 to allow the new digit to be added at the \"front\" of the bytes32, which\r\n                // translates to the beginning of the UTF-8 representation.\r\n                ret = ret >> bitsPerByte;\r\n\r\n                // Separate the last digit that remains in v by modding by the base of desired output representation.\r\n                uint256 leastSignificantDigit = v % base;\r\n\r\n                // Digits 0-9 are represented by 48-57 in UTF-8, so an offset must be added to create the character.\r\n                bytes32 utf8Digit = bytes32(leastSignificantDigit + utf8NumberOffset);\r\n\r\n                // The top byte of ret has already been cleared to make room for the new digit.\r\n                // Upshift by 31 bytes to put it in position, and OR it with ret to leave the other characters untouched.\r\n                ret |= utf8Digit << (31 * bitsPerByte);\r\n\r\n                // Divide v by the base to remove the digit that was just added.\r\n                v /= base;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // This method takes two UTF-8 strings represented as bytes32 and outputs one as a prefixed by the other.\r\n    // `input` is the UTF-8 that should have the prefix prepended.\r\n    // `prefix` is the UTF-8 that should be prepended onto input.\r\n    // `prefixLength` is number of UTF-8 characters represented by `prefix`.\r\n    // Notes:\r\n    // 1. If the resulting UTF-8 is larger than 32 characters, then only the first 32 characters will be represented\r\n    //    by the bytes32 output.\r\n    // 2. If `prefix` has more characters than `prefixLength`, the function will produce an invalid result.\r\n    function _addPrefix(\r\n        bytes32 input,\r\n        bytes32 prefix,\r\n        uint256 prefixLength\r\n    ) internal pure returns (bytes32) {\r\n        // Downshift `input` to open space at the \"front\" of the bytes32\r\n        bytes32 shiftedInput = input >> (prefixLength * 8);\r\n        return shiftedInput | prefix;\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/Constants.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Stores common interface names used throughout the DVM by registration in the Finder.\r\n */\r\nlibrary OracleInterfaces {\r\n    bytes32 public constant Oracle = \"Oracle\";\r\n    bytes32 public constant IdentifierWhitelist = \"IdentifierWhitelist\";\r\n    bytes32 public constant Store = \"Store\";\r\n    bytes32 public constant FinancialContractsAdmin = \"FinancialContractsAdmin\";\r\n    bytes32 public constant Registry = \"Registry\";\r\n    bytes32 public constant CollateralWhitelist = \"CollateralWhitelist\";\r\n    bytes32 public constant OptimisticOracle = \"OptimisticOracle\";\r\n    bytes32 public constant OptimisticOracleV2 = \"OptimisticOracleV2\";\r\n    bytes32 public constant OptimisticOracleV3 = \"OptimisticOracleV3\";\r\n    bytes32 public constant Bridge = \"Bridge\";\r\n    bytes32 public constant GenericHandler = \"GenericHandler\";\r\n    bytes32 public constant SkinnyOptimisticOracle = \"SkinnyOptimisticOracle\";\r\n    bytes32 public constant ChildMessenger = \"ChildMessenger\";\r\n    bytes32 public constant OracleHub = \"OracleHub\";\r\n    bytes32 public constant OracleSpoke = \"OracleSpoke\";\r\n}\r\n\r\n/**\r\n * @title Commonly re-used values for contracts associated with the OptimisticOracle.\r\n */\r\nlibrary OptimisticOracleConstraints {\r\n    // Any price request submitted to the OptimisticOracle must contain ancillary data no larger than this value.\r\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` constant value otherwise it is possible\r\n    // that a price can be requested to the OptimisticOracle successfully, but cannot be resolved by the DVM which\r\n    // refuses to accept a price request made with ancillary data length over a certain size.\r\n    uint256 public constant ancillaryBytesLimit = 8192;\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/ContractCreator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/FinderInterface.sol\";\r\nimport \"../../common/implementation/AddressWhitelist.sol\";\r\nimport \"./Registry.sol\";\r\nimport \"./Constants.sol\";\r\n\r\n/**\r\n * @title Base contract for all financial contract creators\r\n */\r\nabstract contract ContractCreator {\r\n    address internal finderAddress;\r\n\r\n    constructor(address _finderAddress) {\r\n        finderAddress = _finderAddress;\r\n    }\r\n\r\n    function _requireWhitelistedCollateral(address collateralAddress) internal view {\r\n        FinderInterface finder = FinderInterface(finderAddress);\r\n        AddressWhitelist collateralWhitelist =\r\n            AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n        require(collateralWhitelist.isOnWhitelist(collateralAddress), \"Collateral not whitelisted\");\r\n    }\r\n\r\n    function _registerContract(address[] memory parties, address contractToRegister) internal {\r\n        FinderInterface finder = FinderInterface(finderAddress);\r\n        Registry registry = Registry(finder.getImplementationAddress(OracleInterfaces.Registry));\r\n        registry.registerContract(parties, contractToRegister);\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/DesignatedVoting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/MultiRole.sol\";\r\nimport \"../../common/implementation/Withdrawable.sol\";\r\nimport \"../interfaces/VotingAncillaryInterface.sol\";\r\nimport \"../interfaces/FinderInterface.sol\";\r\nimport \"./Constants.sol\";\r\n\r\n/**\r\n * @title Proxy to allow voting from another address.\r\n * @dev Allows a UMA token holder to designate another address to vote on their behalf.\r\n * Each voter must deploy their own instance of this contract.\r\n */\r\ncontract DesignatedVoting is Withdrawable {\r\n    /****************************************\r\n     *    INTERNAL VARIABLES AND STORAGE    *\r\n     ****************************************/\r\n\r\n    enum Roles {\r\n        Owner, // Can set the Voter role. Is also permanently permissioned as the minter role.\r\n        Voter // Can vote through this contract.\r\n    }\r\n\r\n    // Reference to the UMA Finder contract, allowing Voting upgrades to be performed\r\n    // without requiring any calls to this contract.\r\n    FinderInterface private finder;\r\n\r\n    /**\r\n     * @notice Construct the DesignatedVoting contract.\r\n     * @param finderAddress keeps track of all contracts within the system based on their interfaceName.\r\n     * @param ownerAddress address of the owner of the DesignatedVoting contract.\r\n     * @param voterAddress address to which the owner has delegated their voting power.\r\n     */\r\n    constructor(\r\n        address finderAddress,\r\n        address ownerAddress,\r\n        address voterAddress\r\n    ) {\r\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), ownerAddress);\r\n        _createExclusiveRole(uint256(Roles.Voter), uint256(Roles.Owner), voterAddress);\r\n        _setWithdrawRole(uint256(Roles.Owner));\r\n\r\n        finder = FinderInterface(finderAddress);\r\n    }\r\n\r\n    /****************************************\r\n     *   VOTING AND REWARD FUNCTIONALITY    *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Forwards a commit to Voting.\r\n     * @param identifier uniquely identifies the feed for this vote. EG BTC/USD price pair.\r\n     * @param time specifies the unix timestamp of the price being voted on.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param hash the keccak256 hash of the price you want to vote for and a random integer salt value.\r\n     */\r\n    function commitVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bytes32 hash\r\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\r\n        _getVotingAddress().commitVote(identifier, time, ancillaryData, hash);\r\n    }\r\n\r\n    /**\r\n     * @notice Forwards a batch commit to Voting.\r\n     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\r\n     */\r\n    function batchCommit(VotingAncillaryInterface.CommitmentAncillary[] calldata commits)\r\n        external\r\n        onlyRoleHolder(uint256(Roles.Voter))\r\n    {\r\n        _getVotingAddress().batchCommit(commits);\r\n    }\r\n\r\n    /**\r\n     * @notice Forwards a reveal to Voting.\r\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\r\n     * @param time specifies the unix timestamp of the price being voted on.\r\n     * @param price used along with the `salt` to produce the `hash` during the commit phase.\r\n     * @param salt used along with the `price` to produce the `hash` during the commit phase.\r\n     */\r\n    function revealVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes memory ancillaryData,\r\n        int256 salt\r\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\r\n        _getVotingAddress().revealVote(identifier, time, price, ancillaryData, salt);\r\n    }\r\n\r\n    /**\r\n     * @notice Forwards a batch reveal to Voting.\r\n     * @param reveals is an array of the Reveal struct which contains an identifier, time, price and salt.\r\n     */\r\n    function batchReveal(VotingAncillaryInterface.RevealAncillary[] calldata reveals)\r\n        external\r\n        onlyRoleHolder(uint256(Roles.Voter))\r\n    {\r\n        _getVotingAddress().batchReveal(reveals);\r\n    }\r\n\r\n    /**\r\n     * @notice Forwards a reward retrieval to Voting.\r\n     * @dev Rewards are added to the tokens already held by this contract.\r\n     * @param roundId defines the round from which voting rewards will be retrieved from.\r\n     * @param toRetrieve an array of PendingRequests which rewards are retrieved from.\r\n     * @return amount of rewards that the user should receive.\r\n     */\r\n    function retrieveRewards(uint256 roundId, VotingAncillaryInterface.PendingRequestAncillary[] memory toRetrieve)\r\n        public\r\n        onlyRoleHolder(uint256(Roles.Voter))\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        return _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\r\n    }\r\n\r\n    function _getVotingAddress() private view returns (VotingAncillaryInterface) {\r\n        return VotingAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/DesignatedVotingFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/Withdrawable.sol\";\r\nimport \"./DesignatedVoting.sol\";\r\n\r\n/**\r\n * @title Factory to deploy new instances of DesignatedVoting and look up previously deployed instances.\r\n * @dev Allows off-chain infrastructure to look up a hot wallet's deployed DesignatedVoting contract.\r\n */\r\ncontract DesignatedVotingFactory is Withdrawable {\r\n    /****************************************\r\n     *    INTERNAL VARIABLES AND STORAGE    *\r\n     ****************************************/\r\n\r\n    enum Roles {\r\n        Withdrawer // Can withdraw any ETH or ERC20 sent accidentally to this contract.\r\n    }\r\n\r\n    address private finder;\r\n    mapping(address => DesignatedVoting) public designatedVotingContracts;\r\n\r\n    /**\r\n     * @notice Construct the DesignatedVotingFactory contract.\r\n     * @param finderAddress keeps track of all contracts within the system based on their interfaceName.\r\n     */\r\n    constructor(address finderAddress) {\r\n        finder = finderAddress;\r\n\r\n        _createWithdrawRole(uint256(Roles.Withdrawer), uint256(Roles.Withdrawer), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys a new `DesignatedVoting` contract.\r\n     * @param ownerAddress defines who will own the deployed instance of the designatedVoting contract.\r\n     * @return designatedVoting a new DesignatedVoting contract.\r\n     */\r\n    function newDesignatedVoting(address ownerAddress) external returns (DesignatedVoting) {\r\n        DesignatedVoting designatedVoting = new DesignatedVoting(finder, ownerAddress, msg.sender);\r\n        designatedVotingContracts[msg.sender] = designatedVoting;\r\n        return designatedVoting;\r\n    }\r\n\r\n    /**\r\n     * @notice Associates a `DesignatedVoting` instance with `msg.sender`.\r\n     * @param designatedVotingAddress address to designate voting to.\r\n     * @dev This is generally only used if the owner of a `DesignatedVoting` contract changes their `voter`\r\n     * address and wants that reflected here.\r\n     */\r\n    function setDesignatedVoting(address designatedVotingAddress) external {\r\n        designatedVotingContracts[msg.sender] = DesignatedVoting(designatedVotingAddress);\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/DesignatedVotingV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../../common/implementation/MultiCaller.sol\";\r\nimport \"../../common/implementation/Stakeable.sol\";\r\nimport \"../interfaces/FinderInterface.sol\";\r\nimport \"./Constants.sol\";\r\n\r\n/**\r\n * @title Proxy to allow voting from another address.\r\n * @dev Allows a UMA token holder to designate another address to vote on their behalf.\r\n * Each voter must deploy their own instance of this contract.\r\n */\r\ncontract DesignatedVotingV2 is Stakeable, MultiCaller {\r\n    /****************************************\r\n     *    INTERNAL VARIABLES AND STORAGE    *\r\n     ****************************************/\r\n\r\n    enum Roles {\r\n        Owner, // Can set the Voter role.\r\n        Voter // Can vote through this contract.\r\n    }\r\n\r\n    // Reference to UMA Finder contract, allowing Voting upgrades to be without requiring any calls to this contract.\r\n    FinderInterface public immutable finder;\r\n\r\n    /**\r\n     * @notice Construct the DesignatedVotingV2 contract.\r\n     * @param finderAddress keeps track of all contracts within the system based on their interfaceName.\r\n     * @param ownerAddress address of the owner of the DesignatedVotingV2 contract.\r\n     * @param voterAddress address to which the owner has delegated their voting power.\r\n     */\r\n    constructor(\r\n        address finderAddress,\r\n        address ownerAddress,\r\n        address voterAddress\r\n    ) {\r\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), ownerAddress);\r\n        _createExclusiveRole(uint256(Roles.Voter), uint256(Roles.Owner), voterAddress);\r\n        _setWithdrawRole(uint256(Roles.Owner));\r\n        _setStakeRole(uint256(Roles.Owner));\r\n\r\n        finder = FinderInterface(finderAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice This method essentially syncs the voter role with the current voting delegate.\r\n     * @dev Because this is essentially a state sync method, there is no reason to restrict its permissioning.\r\n     */\r\n    function delegateToVoter() public {\r\n        address voter = getMember(uint256(Roles.Voter));\r\n        _getVotingContract().setDelegate(voter);\r\n    }\r\n\r\n    // Returns the Voting contract address, named \"Oracle\" in the finder.\r\n    function _getVotingContract() private view returns (StakerInterface) {\r\n        return StakerInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/DesignatedVotingV2Factory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"./DesignatedVotingV2.sol\";\r\nimport \"../../common/implementation/MultiCaller.sol\";\r\n\r\n/**\r\n * @title Factory to deploy new instances of DesignatedVotingV2 and look up previously deployed instances.\r\n * @dev Allows off-chain infrastructure to look up a hot wallet's deployed DesignatedVoting contract.\r\n */\r\ncontract DesignatedVotingV2Factory is MultiCaller {\r\n    address public immutable finder; // Finder contract that stores addresses of UMA system contracts.\r\n\r\n    event NewDesignatedVoting(address indexed voter, address indexed owner, address indexed designatedVoting);\r\n\r\n    /**\r\n     * @notice Construct the DesignatedVotingFactory contract.\r\n     * @param _finder keeps track of all contracts within the system based on their interfaceName.\r\n     */\r\n    constructor(address _finder) {\r\n        finder = _finder;\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys a new `DesignatedVoting` contract.\r\n     * @param owner defines who will own the deployed instance of the designatedVoting contract.\r\n     * @param voter defines who will be able to vote on behalf of the owner, using the designatedVoting contract.\r\n     * @return designatedVoting a new DesignatedVoting contract.\r\n     */\r\n    function newDesignatedVoting(address owner, address voter) external returns (DesignatedVotingV2) {\r\n        DesignatedVotingV2 designatedVoting = new DesignatedVotingV2(finder, owner, voter);\r\n\r\n        emit NewDesignatedVoting(voter, owner, address(designatedVoting));\r\n\r\n        return designatedVoting;\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/EmergencyProposer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"./GovernorV2.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/MultiCaller.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title Emergency Proposer contract\r\n * @dev This is a contract that allows anyone to construct an emergency recovery transaction to bypass the\r\n * standard voting process by submitting a very large bond, which is considered a quorum in this case. This bond is\r\n * expected to be about as large as the GAT in the VotingV2 contract. If a proposal is considered invalid, UMA token\r\n * holders can vote to slash and remove this proposal through the standard governance flow. If valid, a proposal must\r\n * wait minimumWaitTime before it can be executed and it can only be executed by a privileged account, executor. This\r\n * includes three tiers of protection to ensure that abuse is extremely risky both from creating market volatility in\r\n * the underlying token and the threat of the locked tokens being slashed.\r\n */\r\ncontract EmergencyProposer is Ownable, Lockable, MultiCaller {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /****************************************\r\n     *      EMERGENCY PROPOSAL STATE        *\r\n     ****************************************/\r\n\r\n    // Identifies a unique emergency proposal.\r\n    struct EmergencyProposal {\r\n        address sender; // Sender of the proposal. Address that receives the bond refund in the case of execution.\r\n        uint64 expiryTime; // Time at which the proposal expires and can be executed.\r\n        uint256 lockedTokens; // Tokens locked for the proposal. Tokens are returned when proposal is executed.\r\n        GovernorV2.Transaction[] transactions; // Array of transactions to be executed in the emergency action.\r\n    }\r\n\r\n    // Array of all proposed emergency proposals.\r\n    EmergencyProposal[] public emergencyProposals;\r\n\r\n    // UMA Governor, used to execute transactions. The Governor is the owner of all other UMA ecosystem contracts.\r\n    GovernorV2 public immutable governor;\r\n\r\n    // Voting token, used to bond proposes.\r\n    IERC20 public immutable token;\r\n\r\n    // The number of tokens needed to propose an emergency action.\r\n    uint256 public quorum;\r\n\r\n    // The minimum time that must elapse between from when a proposal is created to when it can be executed.\r\n    uint64 public minimumWaitTime;\r\n\r\n    // The only address that can execute an emergency proposal. Will be set to a multisig. Acts to guardrail the\r\n    // emergency recovery mechanism and ensure that only valid proposals can be executed. Note that while this address\r\n    // is somewhat privileged, it can't unilaterally push through proposals as a proposal must pass the minimum wait\r\n    // time without the DVM voters voting to slash the proposal.\r\n    address public executor;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event QuorumSet(uint256 quorum);\r\n    event ExecutorSet(address executor);\r\n    event MinimumWaitTimeSet(uint256 minimumWaitTime);\r\n    event EmergencyTransactionsProposed(\r\n        uint256 indexed id,\r\n        address indexed sender,\r\n        address indexed caller,\r\n        uint64 expiryTime,\r\n        uint256 lockedTokens,\r\n        GovernorV2.Transaction[] transactions\r\n    );\r\n    event EmergencyProposalRemoved(\r\n        uint256 indexed id,\r\n        address indexed sender,\r\n        address indexed caller,\r\n        uint64 expiryTime,\r\n        uint256 lockedTokens,\r\n        GovernorV2.Transaction[] transactions\r\n    );\r\n    event EmergencyProposalSlashed(\r\n        uint256 indexed id,\r\n        address indexed sender,\r\n        address indexed caller,\r\n        uint64 expiryTime,\r\n        uint256 lockedTokens,\r\n        GovernorV2.Transaction[] transactions\r\n    );\r\n    event EmergencyProposalExecuted(\r\n        uint256 indexed id,\r\n        address indexed sender,\r\n        address indexed caller,\r\n        uint64 expiryTime,\r\n        uint256 lockedTokens,\r\n        GovernorV2.Transaction[] transactions\r\n    );\r\n\r\n    /**\r\n     * @notice Construct the EmergencyProposer contract.\r\n     * @param _token the ERC20 token that the quorum is in.\r\n     * @param _quorum the tokens needed to propose an emergency action.\r\n     * @param _governor the governor contract that this contract makes proposals to.\r\n     * @param _executor the address that can execute an emergency proposal.\r\n     * @param _minimumWaitTime the minimum time that must elapse between from when a proposal is created to when it can\r\n     * be executed.\r\n     */\r\n    constructor(\r\n        IERC20 _token,\r\n        uint256 _quorum,\r\n        GovernorV2 _governor,\r\n        address _executor,\r\n        uint64 _minimumWaitTime\r\n    ) {\r\n        token = _token;\r\n        governor = _governor;\r\n        setExecutor(_executor);\r\n        setQuorum(_quorum);\r\n\r\n        setMinimumWaitTime(_minimumWaitTime);\r\n        transferOwnership(address(_governor));\r\n    }\r\n\r\n    /**\r\n     * @notice Propose an emergency admin action to execute on the DVM as a set of proposed transactions.\r\n     * @dev Caller of this method must approve (and have) quorum amount of token to be pulled from their wallet.\r\n     * @param transactions array of transactions to be executed in the emergency action. When executed, will be sent\r\n     * via the governor contract.\r\n     * @return uint256 the emergency proposal id.\r\n     */\r\n    function emergencyPropose(GovernorV2.Transaction[] memory transactions) external nonReentrant() returns (uint256) {\r\n        require(msg.sender != address(governor), \"Governor can't propose\"); // The governor should never be the proposer.\r\n        require(transactions.length > 0, \"No transactions to propose\");\r\n        token.safeTransferFrom(msg.sender, address(this), quorum);\r\n        uint256 id = emergencyProposals.length;\r\n        EmergencyProposal storage proposal = emergencyProposals.push();\r\n        proposal.sender = msg.sender;\r\n        proposal.lockedTokens = quorum;\r\n        proposal.expiryTime = uint64(getCurrentTime()) + minimumWaitTime;\r\n\r\n        for (uint256 i = 0; i < transactions.length; i++) proposal.transactions.push(transactions[i]);\r\n\r\n        emit EmergencyTransactionsProposed(id, msg.sender, msg.sender, proposal.expiryTime, quorum, transactions);\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * @notice After the proposal is executable, the executor or owner can use this function to remove the proposal\r\n     * without slashing.\r\n     * @dev This means that the DVM didn't explicitly reject the proposal. Allowing the executor to slash the quorum\r\n     * would give the executor too much power. So the only control either party has is to remove the proposal,\r\n     * releasing the bond. The proposal should not be removable before its liveness/expiry to ensure the regular Voting\r\n     * system's slash cannot be frontrun.\r\n     * @param id id of the proposal.\r\n     */\r\n    function removeProposal(uint256 id) external nonReentrant() {\r\n        EmergencyProposal storage proposal = emergencyProposals[id];\r\n        require(proposal.expiryTime <= getCurrentTime(), \"must be expired to remove\");\r\n        require(msg.sender == owner() || msg.sender == executor, \"owner or executor\");\r\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\r\n        token.safeTransfer(proposal.sender, proposal.lockedTokens);\r\n        emit EmergencyProposalRemoved(\r\n            id,\r\n            proposal.sender,\r\n            msg.sender,\r\n            proposal.expiryTime,\r\n            proposal.lockedTokens,\r\n            proposal.transactions\r\n        );\r\n        delete emergencyProposals[id];\r\n    }\r\n\r\n    /**\r\n     * @notice Before a proposal expires (or after), this method can be used by the owner, which should generally be\r\n     * the GovernorV2 contract, to slash the proposer.\r\n     * @dev The slash results in the proposer's tokens being sent to the Governor contract.\r\n     * @param id id of the proposal.\r\n     */\r\n    function slashProposal(uint256 id) external nonReentrant() onlyOwner() {\r\n        EmergencyProposal storage proposal = emergencyProposals[id];\r\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\r\n        token.safeTransfer(address(governor), proposal.lockedTokens);\r\n        emit EmergencyProposalSlashed(\r\n            id,\r\n            proposal.sender,\r\n            msg.sender,\r\n            proposal.expiryTime,\r\n            proposal.lockedTokens,\r\n            proposal.transactions\r\n        );\r\n        delete emergencyProposals[id];\r\n    }\r\n\r\n    /**\r\n     * @notice After a proposal expires, this method can be used by the executor to execute the proposal.\r\n     * @dev This method effectively gives the executor veto power over any proposal.\r\n     * @dev The first transaction execution sends the total amount of ETH required to complete all payable\r\n     * transactions in the Governor. The EmergencyProposer must receive this amount of ETH in advance.\r\n     * The executed transactions are then able to use this ETH by including a nonzero value.\r\n     * @param id id of the proposal.\r\n     */\r\n    function executeEmergencyProposal(uint256 id) external payable nonReentrant() {\r\n        require(msg.sender == executor, \"must be called by executor\");\r\n\r\n        EmergencyProposal storage proposal = emergencyProposals[id];\r\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\r\n        require(proposal.expiryTime <= getCurrentTime(), \"must be expired to execute\");\r\n\r\n        for (uint256 i = 0; i < proposal.transactions.length; i++)\r\n            governor.emergencyExecute{ value: address(this).balance }(proposal.transactions[i]);\r\n\r\n        token.safeTransfer(proposal.sender, proposal.lockedTokens);\r\n        emit EmergencyProposalExecuted(\r\n            id,\r\n            proposal.sender,\r\n            msg.sender,\r\n            proposal.expiryTime,\r\n            proposal.lockedTokens,\r\n            proposal.transactions\r\n        );\r\n        delete emergencyProposals[id];\r\n    }\r\n\r\n    /**\r\n     * @notice Admin method to set the quorum (bond) size.\r\n     * @dev Admin is intended to be the governance system.\r\n     * @param newQuorum the new quorum.\r\n     */\r\n    function setQuorum(uint256 newQuorum) public nonReentrant() onlyOwner() {\r\n        require(newQuorum != 0, \"quorum must be > 0\");\r\n        require(newQuorum < token.totalSupply(), \"quorum must be < totalSupply\");\r\n        quorum = newQuorum;\r\n        emit QuorumSet(newQuorum);\r\n    }\r\n\r\n    /**\r\n     * @notice Admin method to set the executor address.\r\n     * @dev Admin is intended to be the governance system.\r\n     * @param newExecutor the new executor address.\r\n     */\r\n    function setExecutor(address newExecutor) public nonReentrant() onlyOwner() {\r\n        executor = newExecutor;\r\n        emit ExecutorSet(newExecutor);\r\n    }\r\n\r\n    /**\r\n     * @notice Admin method to set the minimum wait time for a proposal to be executed.\r\n     * @dev Admin is intended to be the governance system. The minimum wait time is added to the current time at the\r\n     * time of the proposal to determine when the proposal will be executable. Any changes to this value after that\r\n     * point will have no impact on the proposal.\r\n     * @param newMinimumWaitTime the new minimum wait time.\r\n     */\r\n    function setMinimumWaitTime(uint64 newMinimumWaitTime) public nonReentrant() onlyOwner() {\r\n        require(newMinimumWaitTime != 0, \"minimumWaitTime == 0\");\r\n        require(newMinimumWaitTime <= 4 weeks, \"minimumWaitTime > 1 month\");\r\n        minimumWaitTime = newMinimumWaitTime;\r\n        emit MinimumWaitTimeSet(newMinimumWaitTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current block timestamp.\r\n     * @dev Can be overridden to control contract time.\r\n     * @return the current block timestamp.\r\n     */\r\n    function getCurrentTime() public view virtual returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/FinancialContractsAdmin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/AdministrateeInterface.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @title Admin for financial contracts in the UMA system.\r\n * @dev Allows appropriately permissioned admin roles to interact with financial contracts.\r\n */\r\ncontract FinancialContractsAdmin is Ownable {\r\n    /**\r\n     * @notice Calls emergency shutdown on the provided financial contract.\r\n     * @param financialContract address of the FinancialContract to be shut down.\r\n     */\r\n    function callEmergencyShutdown(address financialContract) external onlyOwner {\r\n        AdministrateeInterface administratee = AdministrateeInterface(financialContract);\r\n        administratee.emergencyShutdown();\r\n    }\r\n\r\n    /**\r\n     * @notice Calls remargin on the provided financial contract.\r\n     * @param financialContract address of the FinancialContract to be remargined.\r\n     */\r\n    function callRemargin(address financialContract) external onlyOwner {\r\n        AdministrateeInterface administratee = AdministrateeInterface(financialContract);\r\n        administratee.remargin();\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/Finder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../interfaces/FinderInterface.sol\";\r\n\r\n/**\r\n * @title Provides addresses of the live contracts implementing certain interfaces.\r\n * @dev Examples of interfaces with implementations that Finder locates are the Oracle and Store interfaces.\r\n */\r\ncontract Finder is FinderInterface, Ownable {\r\n    mapping(bytes32 => address) public interfacesImplemented;\r\n\r\n    event InterfaceImplementationChanged(bytes32 indexed interfaceName, address indexed newImplementationAddress);\r\n\r\n    /**\r\n     * @notice Updates the address of the contract that implements `interfaceName`.\r\n     * @param interfaceName bytes32 of the interface name that is either changed or registered.\r\n     * @param implementationAddress address of the implementation contract.\r\n     */\r\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        interfacesImplemented[interfaceName] = implementationAddress;\r\n\r\n        emit InterfaceImplementationChanged(interfaceName, implementationAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\r\n     * @param interfaceName queried interface.\r\n     * @return implementationAddress address of the defined interface.\r\n     */\r\n    function getImplementationAddress(bytes32 interfaceName) external view override returns (address) {\r\n        address implementationAddress = interfacesImplemented[interfaceName];\r\n        require(implementationAddress != address(0x0), \"Implementation not found\");\r\n        return implementationAddress;\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/FixedSlashSlashingLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../interfaces/SlashingLibraryInterface.sol\";\r\n\r\n/**\r\n * @title Slashing Library contract. Returns the how much a voter should be slashed per staked token as a function of\r\n * the total staked, total votes and total correct votes. Can be upgraded to a new implementation to enable more\r\n elaborate slashing algorithms via UMA governance.\r\n */\r\n\r\ncontract FixedSlashSlashingLibrary is SlashingLibraryInterface {\r\n    uint256 public immutable baseSlashAmount; // Slash amount per token for missed votes and wrong non-governance votes.\r\n    uint256 public immutable governanceSlashAmount; // Slash amount per token for wrong governance votes.\r\n\r\n    /**\r\n     * @notice Construct the FixedSlashSlashingLibrary contract.\r\n     * @param _baseSlashAmount Slash amount per token for missed votes and wrong non-governance votes.\r\n     * @param _governanceSlashAmount Slash amount per token for wrong governance votes.\r\n     */\r\n    constructor(uint256 _baseSlashAmount, uint256 _governanceSlashAmount) {\r\n        require(_baseSlashAmount < 1e18, \"Invalid base slash amount\");\r\n        require(_governanceSlashAmount < 1e18, \"Invalid governance slash amount\");\r\n        baseSlashAmount = _baseSlashAmount; // Slash amount per token for missed votes and wrong non-governance votes.\r\n        governanceSlashAmount = _governanceSlashAmount; // Slash amount per token for wrong governance votes.\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the wrong vote slash per token.\r\n     * @param totalStaked The total amount of tokens staked.\r\n     * @param totalVotes The total amount of votes.\r\n     * @param totalCorrectVotes The total amount of correct votes.\r\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\r\n     * @return uint256 The amount of tokens to slash per token staked.\r\n     */\r\n    function calcWrongVoteSlashPerToken(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public view returns (uint256) {\r\n        return baseSlashAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the wrong vote slash per token for governance requests.\r\n     * @param totalStaked The total amount of tokens staked.\r\n     * @param totalVotes The total amount of votes.\r\n     * @param totalCorrectVotes The total amount of correct votes.\r\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\r\n     * @return uint256 The amount of tokens to slash per token staked.\r\n     */\r\n    function calcWrongVoteSlashPerTokenGovernance(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public view returns (uint256) {\r\n        return governanceSlashAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the no vote slash per token.\r\n     * @param totalStaked The total amount of tokens staked.\r\n     * @param totalVotes The total amount of votes.\r\n     * @param totalCorrectVotes The total amount of correct votes.\r\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\r\n     * @return uint256 The amount of tokens to slash per token staked.\r\n     */\r\n    function calcNoVoteSlashPerToken(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public view returns (uint256) {\r\n        return baseSlashAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates all slashing trackers in one go to decrease cross-contract calls needed.\r\n     * @param totalStaked The total amount of tokens staked.\r\n     * @param totalVotes The total amount of votes.\r\n     * @param totalCorrectVotes The total amount of correct votes.\r\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\r\n     * @param isGovernance Whether the request is a governance request.\r\n     * @return wrongVoteSlashPerToken The amount of tokens to slash for voting wrong.\r\n     * @return noVoteSlashPerToken The amount of tokens to slash for not voting.\r\n     */\r\n    function calcSlashing(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex,\r\n        bool isGovernance\r\n    ) external view returns (uint256 wrongVoteSlashPerToken, uint256 noVoteSlashPerToken) {\r\n        return (\r\n            isGovernance\r\n                ? calcWrongVoteSlashPerTokenGovernance(totalStaked, totalVotes, totalCorrectVotes, priceRequestIndex)\r\n                : calcWrongVoteSlashPerToken(totalStaked, totalVotes, totalCorrectVotes, priceRequestIndex),\r\n            calcNoVoteSlashPerToken(totalStaked, totalVotes, totalCorrectVotes, priceRequestIndex)\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/Governor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/MultiRole.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../interfaces/FinderInterface.sol\";\r\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../interfaces/OracleInterface.sol\";\r\nimport \"./Constants.sol\";\r\nimport \"./AdminIdentifierLib.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\n/**\r\n * @title Takes proposals for certain governance actions and allows UMA token holders to vote on them.\r\n */\r\ncontract Governor is MultiRole, Testable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    /****************************************\r\n     *     INTERNAL VARIABLES AND STORAGE   *\r\n     ****************************************/\r\n\r\n    enum Roles {\r\n        Owner, // Can set the proposer.\r\n        Proposer // Address that can make proposals.\r\n    }\r\n\r\n    struct Transaction {\r\n        address to;\r\n        uint256 value;\r\n        bytes data;\r\n    }\r\n\r\n    struct Proposal {\r\n        Transaction[] transactions;\r\n        uint256 requestTime;\r\n    }\r\n\r\n    FinderInterface private finder;\r\n    Proposal[] public proposals;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    // Emitted when a new proposal is created.\r\n    event NewProposal(uint256 indexed id, Transaction[] transactions);\r\n\r\n    // Emitted when an existing proposal is executed.\r\n    event ProposalExecuted(uint256 indexed id, uint256 transactionIndex);\r\n\r\n    /**\r\n     * @notice Construct the Governor contract.\r\n     * @param _finderAddress keeps track of all contracts within the system based on their interfaceName.\r\n     * @param _startingId the initial proposal id that the contract will begin incrementing from.\r\n     * @param _timerAddress Contract that stores the current time in a testing environment.\r\n     * Must be set to 0x0 for production environments that use live time.\r\n     */\r\n    constructor(\r\n        address _finderAddress,\r\n        uint256 _startingId,\r\n        address _timerAddress\r\n    ) Testable(_timerAddress) {\r\n        finder = FinderInterface(_finderAddress);\r\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\r\n        _createExclusiveRole(uint256(Roles.Proposer), uint256(Roles.Owner), msg.sender);\r\n\r\n        // Ensure the startingId is not set unreasonably high to avoid it being set such that new proposals overwrite\r\n        // other storage slots in the contract.\r\n        uint256 maxStartingId = 10**18;\r\n        require(_startingId <= maxStartingId, \"Cannot set startingId larger than 10^18\");\r\n\r\n        // This just sets the initial length of the array to the startingId since modifying length directly has been\r\n        // disallowed in solidity 0.6.\r\n        assembly {\r\n            sstore(proposals.slot, _startingId)\r\n        }\r\n    }\r\n\r\n    /****************************************\r\n     *          PROPOSAL ACTIONS            *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Proposes a new governance action. Can only be called by the holder of the Proposer role.\r\n     * @param transactions list of transactions that are being proposed.\r\n     * @dev You can create the data portion of each transaction by doing the following:\r\n     * ```\r\n     * const truffleContractInstance = await TruffleContract.deployed()\r\n     * const data = truffleContractInstance.methods.methodToCall(arg1, arg2).encodeABI()\r\n     * ```\r\n     * Note: this method must be public because of a solidity limitation that\r\n     * disallows structs arrays to be passed to external functions.\r\n     */\r\n    function propose(Transaction[] memory transactions) public onlyRoleHolder(uint256(Roles.Proposer)) {\r\n        uint256 id = proposals.length;\r\n        uint256 time = getCurrentTime();\r\n\r\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\r\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\r\n\r\n        // Add a zero-initialized element to the proposals array.\r\n        proposals.push();\r\n\r\n        // Initialize the new proposal.\r\n        Proposal storage proposal = proposals[id];\r\n        proposal.requestTime = time;\r\n\r\n        // Initialize the transaction array.\r\n        for (uint256 i = 0; i < transactions.length; i++) {\r\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\r\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\r\n            if (transactions[i].data.length > 0) {\r\n                require(transactions[i].to.isContract(), \"EOA can't accept tx with data\");\r\n            }\r\n            proposal.transactions.push(transactions[i]);\r\n        }\r\n\r\n        bytes32 identifier = AdminIdentifierLib._constructIdentifier(id);\r\n\r\n        // Request a vote on this proposal in the DVM.\r\n        OracleInterface oracle = _getOracle();\r\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\r\n        supportedIdentifiers.addSupportedIdentifier(identifier);\r\n\r\n        oracle.requestPrice(identifier, time);\r\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\r\n\r\n        emit NewProposal(id, transactions);\r\n    }\r\n\r\n    /**\r\n     * @notice Executes a proposed governance action that has been approved by voters.\r\n     * @dev This can be called by any address. Caller is expected to send enough ETH to execute payable transactions.\r\n     * @param id unique id for the executed proposal.\r\n     * @param transactionIndex unique transaction index for the executed proposal.\r\n     */\r\n    function executeProposal(uint256 id, uint256 transactionIndex) external payable {\r\n        Proposal storage proposal = proposals[id];\r\n        int256 price = _getOracle().getPrice(AdminIdentifierLib._constructIdentifier(id), proposal.requestTime);\r\n\r\n        Transaction memory transaction = proposal.transactions[transactionIndex];\r\n\r\n        require(\r\n            transactionIndex == 0 || proposal.transactions[transactionIndex.sub(1)].to == address(0),\r\n            \"Previous tx not yet executed\"\r\n        );\r\n        require(transaction.to != address(0), \"Tx already executed\");\r\n        require(price != 0, \"Proposal was rejected\");\r\n        require(msg.value == transaction.value, \"Must send exact amount of ETH\");\r\n\r\n        // Delete the transaction before execution to avoid any potential re-entrancy issues.\r\n        delete proposal.transactions[transactionIndex];\r\n\r\n        require(_executeCall(transaction.to, transaction.value, transaction.data), \"Tx execution failed\");\r\n\r\n        emit ProposalExecuted(id, transactionIndex);\r\n    }\r\n\r\n    /****************************************\r\n     *       GOVERNOR STATE GETTERS         *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Gets the total number of proposals (includes executed and non-executed).\r\n     * @return uint256 representing the current number of proposals.\r\n     */\r\n    function numProposals() external view returns (uint256) {\r\n        return proposals.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the proposal data for a particular id.\r\n     * @dev after a proposal is executed, its data will be zeroed out, except for the request time.\r\n     * @param id uniquely identify the identity of the proposal.\r\n     * @return proposal struct containing transactions[] and requestTime.\r\n     */\r\n    function getProposal(uint256 id) external view returns (Proposal memory) {\r\n        return proposals[id];\r\n    }\r\n\r\n    /****************************************\r\n     *      PRIVATE GETTERS AND FUNCTIONS   *\r\n     ****************************************/\r\n\r\n    function _executeCall(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) private returns (bool) {\r\n        // Mostly copied from:\r\n        // solhint-disable-next-line max-line-length\r\n        // https://github.com/gnosis/safe-contracts/blob/59cfdaebcd8b87a0a32f87b50fead092c10d3a05/contracts/base/Executor.sol#L23-L31\r\n        // solhint-disable-next-line no-inline-assembly\r\n\r\n        bool success;\r\n        assembly {\r\n            let inputData := add(data, 0x20)\r\n            let inputDataSize := mload(data)\r\n            success := call(gas(), to, value, inputData, inputDataSize, 0, 0)\r\n        }\r\n        return success;\r\n    }\r\n\r\n    function _getOracle() private view returns (OracleInterface) {\r\n        return OracleInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n\r\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface supportedIdentifiers) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/GovernorV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/MultiCaller.sol\";\r\nimport \"../../common/implementation/MultiRole.sol\";\r\nimport \"../interfaces/FinderInterface.sol\";\r\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../interfaces/OracleGovernanceInterface.sol\";\r\nimport \"./Constants.sol\";\r\nimport \"./AdminIdentifierLib.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\n/**\r\n * @title Takes proposals for certain governance actions and allows UMA token holders to vote on them.\r\n */\r\ncontract GovernorV2 is MultiRole, Lockable, MultiCaller {\r\n    using Address for address;\r\n\r\n    /****************************************\r\n     *             GOVERNOR STATE           *\r\n     ****************************************/\r\n\r\n    // Permissioned governor rolls.\r\n    enum Roles {\r\n        Owner, // Can set the proposer.\r\n        Proposer, // Address that can make proposals.\r\n        EmergencyProposer // Address that can make emergency proposals.\r\n    }\r\n\r\n    // Structure to represent a transaction.\r\n    struct Transaction {\r\n        address to; // Target.\r\n        uint256 value; // value, in eth, to be sent as the msg.value.\r\n        bytes data; // payload data to be sent to the target. Would include encoded function call data usually.\r\n    }\r\n\r\n    // Structure to represent a governance proposal.\r\n    struct Proposal {\r\n        Transaction[] transactions; // Set of transactions to be sent, if the proposal is executed.\r\n        uint256 requestTime; // Time at which the proposal was proposed.\r\n        bytes ancillaryData; // Extra data appended to a proposal to enhance the voters information.\r\n    }\r\n\r\n    // Reference to UMA finder, used to find addresses of other UMA ecosystem contracts.\r\n    FinderInterface public immutable finder;\r\n\r\n    // Array of all proposals.\r\n    Proposal[] public proposals;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event NewProposal(uint256 indexed id, Transaction[] transactions);\r\n\r\n    event ProposalExecuted(uint256 indexed id, uint256 transactionIndex);\r\n    event EmergencyExecution(address indexed to, uint256 value, bytes data);\r\n\r\n    /**\r\n     * @notice Construct the Governor contract.\r\n     * @param _finderAddress keeps track of all contracts within the system based on their interfaceName.\r\n     * @param _startingId the initial proposal id that the contract will begin incrementing from.\r\n     */\r\n    constructor(address _finderAddress, uint256 _startingId) {\r\n        finder = FinderInterface(_finderAddress);\r\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\r\n        _createExclusiveRole(uint256(Roles.Proposer), uint256(Roles.Owner), msg.sender);\r\n        _createExclusiveRole(uint256(Roles.EmergencyProposer), uint256(Roles.Owner), msg.sender);\r\n\r\n        // Ensure the startingId is not set unreasonably high to avoid it being set such that new proposals overwrite\r\n        // other storage slots in the contract.\r\n        uint256 maxStartingId = 10**18;\r\n        require(_startingId <= maxStartingId, \"Cannot set startingId larger than 10^18\");\r\n\r\n        // Sets the initial length of the array to the startingId. Modifying length directly has been disallowed in solidity 0.6.\r\n        assembly {\r\n            sstore(proposals.slot, _startingId)\r\n        }\r\n    }\r\n\r\n    /****************************************\r\n     *          PROPOSAL ACTIONS            *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Proposes a new governance action. Can only be called by the holder of the Proposer role.\r\n     * @param transactions list of transactions that are being proposed.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     */\r\n    function propose(Transaction[] memory transactions, bytes memory ancillaryData)\r\n        external\r\n        nonReentrant()\r\n        onlyRoleHolder(uint256(Roles.Proposer))\r\n    {\r\n        require(transactions.length > 0, \"Empty transactions array\");\r\n        uint256 id = proposals.length;\r\n        uint256 time = getCurrentTime();\r\n\r\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\r\n        // structs in storage to an array of structs in memory is currently not implemented in solidity :/.\r\n\r\n        // Add a zero-initialized element to the proposals array.\r\n        proposals.push();\r\n\r\n        // Initialize the new proposal.\r\n        Proposal storage proposal = proposals[id];\r\n        proposal.requestTime = time;\r\n        proposal.ancillaryData = ancillaryData;\r\n\r\n        // Initialize the transaction array.\r\n        for (uint256 i = 0; i < transactions.length; i++) {\r\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\r\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\r\n            if (transactions[i].data.length > 0) {\r\n                require(transactions[i].to.isContract(), \"EOA can't accept tx with data\");\r\n            }\r\n            proposal.transactions.push(transactions[i]);\r\n        }\r\n\r\n        bytes32 identifier = AdminIdentifierLib._constructIdentifier(id);\r\n\r\n        // Request a vote on this proposal in the DVM.\r\n        _getOracle().requestGovernanceAction(identifier, time, ancillaryData);\r\n\r\n        emit NewProposal(id, transactions);\r\n    }\r\n\r\n    /**\r\n     * @notice Executes a proposed governance action that has been approved by voters.\r\n     * @dev This can be called by any address. Caller is expected to send enough ETH to execute payable transactions.\r\n     * @param id unique id for the executed proposal.\r\n     * @param transactionIndex unique transaction index for the executed proposal.\r\n     */\r\n    function executeProposal(uint256 id, uint256 transactionIndex) external payable nonReentrant() {\r\n        Proposal storage proposal = proposals[id];\r\n        int256 price =\r\n            _getOracle().getPrice(\r\n                AdminIdentifierLib._constructIdentifier(id),\r\n                proposal.requestTime,\r\n                proposal.ancillaryData\r\n            );\r\n\r\n        Transaction memory transaction = proposal.transactions[transactionIndex];\r\n\r\n        require(\r\n            transactionIndex == 0 || proposal.transactions[transactionIndex - 1].to == address(0),\r\n            \"Previous tx not yet executed\"\r\n        );\r\n        require(transaction.to != address(0), \"Tx already executed\");\r\n        require(price != 0, \"Proposal was rejected\");\r\n        require(msg.value == transaction.value, \"Must send exact amount of ETH\");\r\n\r\n        // Delete the transaction before execution to avoid any potential re-entrancy issues.\r\n        delete proposal.transactions[transactionIndex];\r\n\r\n        require(_executeCall(transaction.to, transaction.value, transaction.data), \"Tx execution failed\");\r\n\r\n        emit ProposalExecuted(id, transactionIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice Emergency execution method that bypasses the voting system to execute a transaction.\r\n     * @dev This can only be called by the EmergencyProposer.\r\n     * @param transaction a single transaction to execute.\r\n     */\r\n    function emergencyExecute(Transaction memory transaction)\r\n        external\r\n        payable\r\n        nonReentrant()\r\n        onlyRoleHolder(uint256(Roles.EmergencyProposer))\r\n    {\r\n        require(_executeCall(transaction.to, transaction.value, transaction.data), \"Tx execution failed\");\r\n\r\n        emit EmergencyExecution(transaction.to, transaction.value, transaction.data);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current block timestamp.\r\n     * @dev Can be overridden to control contract time.\r\n     * @return the current block timestamp.\r\n     */\r\n    function getCurrentTime() public view virtual returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /****************************************\r\n     *       GOVERNOR STATE GETTERS         *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Gets the total number of proposals (includes executed and non-executed).\r\n     * @return uint256 representing the current number of proposals.\r\n     */\r\n    function numProposals() external view returns (uint256) {\r\n        return proposals.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the proposal data for a particular id.\r\n     * @dev after a proposal is executed, its data will be zeroed out, except for the request time and ancillary data.\r\n     * @param id uniquely identify the identity of the proposal.\r\n     * @return proposal struct containing transactions[] and requestTime.\r\n     */\r\n    function getProposal(uint256 id) external view returns (Proposal memory) {\r\n        return proposals[id];\r\n    }\r\n\r\n    /****************************************\r\n     *      PRIVATE GETTERS AND FUNCTIONS   *\r\n     ****************************************/\r\n\r\n    // Runs a function call on to, with value eth sent and data payload.\r\n    function _executeCall(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) private returns (bool) {\r\n        // Mostly copied from:\r\n        // solhint-disable-next-line max-line-length\r\n        // https://github.com/gnosis/safe-contracts/blob/59cfdaebcd8b87a0a32f87b50fead092c10d3a05/contracts/base/Executor.sol#L23-L31\r\n        // solhint-disable-next-line no-inline-assembly\r\n\r\n        bool success;\r\n        assembly {\r\n            let inputData := add(data, 0x20)\r\n            let inputDataSize := mload(data)\r\n            success := call(gas(), to, value, inputData, inputDataSize, 0, 0)\r\n        }\r\n        return success;\r\n    }\r\n\r\n    // Returns the Voting contract address, named \"Oracle\" in the finder.\r\n    function _getOracle() private view returns (OracleGovernanceInterface) {\r\n        return OracleGovernanceInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n\r\n    // Returns the IdentifierWhitelist contract address, named \"IdentifierWhitelist\" in the finder.\r\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/IdentifierWhitelist.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @title Stores a whitelist of supported identifiers that the oracle can provide prices for.\r\n */\r\ncontract IdentifierWhitelist is IdentifierWhitelistInterface, Ownable {\r\n    /****************************************\r\n     *     INTERNAL VARIABLES AND STORAGE   *\r\n     ****************************************/\r\n\r\n    mapping(bytes32 => bool) private supportedIdentifiers;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event SupportedIdentifierAdded(bytes32 indexed identifier);\r\n    event SupportedIdentifierRemoved(bytes32 indexed identifier);\r\n\r\n    /****************************************\r\n     *    ADMIN STATE MODIFYING FUNCTIONS   *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Adds the provided identifier as a supported identifier.\r\n     * @dev Price requests using this identifier will succeed after this call.\r\n     * @param identifier unique UTF-8 representation for the feed being added. Eg: BTC/USD.\r\n     */\r\n    function addSupportedIdentifier(bytes32 identifier) external override onlyOwner {\r\n        if (!supportedIdentifiers[identifier]) {\r\n            supportedIdentifiers[identifier] = true;\r\n            emit SupportedIdentifierAdded(identifier);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Removes the identifier from the whitelist.\r\n     * @dev Price requests using this identifier will no longer succeed after this call.\r\n     * @param identifier unique UTF-8 representation for the feed being removed. Eg: BTC/USD.\r\n     */\r\n    function removeSupportedIdentifier(bytes32 identifier) external override onlyOwner {\r\n        if (supportedIdentifiers[identifier]) {\r\n            supportedIdentifiers[identifier] = false;\r\n            emit SupportedIdentifierRemoved(identifier);\r\n        }\r\n    }\r\n\r\n    /****************************************\r\n     *     WHITELIST GETTERS FUNCTIONS      *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Checks whether an identifier is on the whitelist.\r\n     * @param identifier unique UTF-8 representation for the feed being queried. Eg: BTC/USD.\r\n     * @return bool if the identifier is supported (or not).\r\n     */\r\n    function isIdentifierSupported(bytes32 identifier) external view override returns (bool) {\r\n        return supportedIdentifiers[identifier];\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/Proposer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Finder.sol\";\r\nimport \"./Governor.sol\";\r\nimport \"./Constants.sol\";\r\nimport \"./Voting.sol\";\r\nimport \"./AdminIdentifierLib.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title Proposer contract that allows anyone to make governance proposals with a bond.\r\n */\r\ncontract Proposer is Ownable, Testable, Lockable {\r\n    using SafeERC20 for IERC20;\r\n    IERC20 public token;\r\n    uint256 public bond;\r\n    Governor public governor;\r\n    Finder public finder;\r\n\r\n    struct BondedProposal {\r\n        address sender;\r\n        // 64 bits to save a storage slot.\r\n        uint64 time;\r\n        uint256 lockedBond;\r\n    }\r\n    mapping(uint256 => BondedProposal) public bondedProposals;\r\n\r\n    event BondSet(uint256 bond);\r\n    event ProposalResolved(uint256 indexed id, bool success);\r\n\r\n    /**\r\n     * @notice Construct the Proposer contract.\r\n     * @param _token the ERC20 token that the bond is paid in.\r\n     * @param _bond the bond amount.\r\n     * @param _governor the governor contract that this contract makes proposals to.\r\n     * @param _finder the finder contract used to look up addresses.\r\n     * @param _timer the timer contract to control the output of getCurrentTime(). Set to 0x0 if in production.\r\n     */\r\n    constructor(\r\n        IERC20 _token,\r\n        uint256 _bond,\r\n        Governor _governor,\r\n        Finder _finder,\r\n        address _timer\r\n    ) Testable(_timer) {\r\n        token = _token;\r\n        governor = _governor;\r\n        finder = _finder;\r\n        setBond(_bond);\r\n        transferOwnership(address(_governor));\r\n    }\r\n\r\n    /**\r\n     * @notice Propose a new set of governance transactions for vote.\r\n     * @dev Pulls bond from the caller.\r\n     * @param transactions list of transactions for the governor to execute.\r\n     * @return id the id of the governor proposal.\r\n     */\r\n    function propose(Governor.Transaction[] memory transactions) external nonReentrant() returns (uint256 id) {\r\n        id = governor.numProposals();\r\n        token.safeTransferFrom(msg.sender, address(this), bond);\r\n        bondedProposals[id] = BondedProposal({ sender: msg.sender, lockedBond: bond, time: uint64(getCurrentTime()) });\r\n        governor.propose(transactions);\r\n    }\r\n\r\n    /**\r\n     * @notice Resolves a proposal by checking the status of the request in the Voting contract.\r\n     * @dev For the resolution to work correctly, this contract must be a registered contract in the DVM.\r\n     * @param id proposal id.\r\n     */\r\n    function resolveProposal(uint256 id) external nonReentrant() {\r\n        BondedProposal storage bondedProposal = bondedProposals[id];\r\n        Voting voting = Voting(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n        require(\r\n            voting.hasPrice(AdminIdentifierLib._constructIdentifier(id), bondedProposal.time, \"\"),\r\n            \"No price resolved\"\r\n        );\r\n        if (voting.getPrice(AdminIdentifierLib._constructIdentifier(id), bondedProposal.time, \"\") != 0) {\r\n            token.safeTransfer(bondedProposal.sender, bondedProposal.lockedBond);\r\n            emit ProposalResolved(id, true);\r\n        } else {\r\n            token.safeTransfer(finder.getImplementationAddress(OracleInterfaces.Store), bondedProposal.lockedBond);\r\n            emit ProposalResolved(id, false);\r\n        }\r\n        delete bondedProposals[id];\r\n    }\r\n\r\n    /**\r\n     * @notice Admin method to set the bond amount.\r\n     * @dev Admin is intended to be the governance system, itself.\r\n     * @param _bond the new bond.\r\n     */\r\n    function setBond(uint256 _bond) public nonReentrant() onlyOwner() {\r\n        bond = _bond;\r\n        emit BondSet(_bond);\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/ProposerV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"./Finder.sol\";\r\nimport \"./GovernorV2.sol\";\r\nimport \"./Constants.sol\";\r\nimport \"../interfaces/OracleAncillaryInterface.sol\";\r\nimport \"./AdminIdentifierLib.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/MultiCaller.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title Proposer contract that allows anyone to make governance proposals with a bond.\r\n */\r\ncontract ProposerV2 is Ownable, Lockable, MultiCaller {\r\n    using SafeERC20 for IERC20;\r\n    IERC20 public immutable token; // The ERC20 token that the bond is paid in.\r\n    uint256 public bond; // The bond amount for making a proposal.\r\n    GovernorV2 public immutable governor; // The governor contract that this contract makes proposals to.\r\n    Finder public immutable finder; // Finder contract that stores addresses of UMA system contracts.\r\n\r\n    struct BondedProposal {\r\n        address sender;\r\n        // 64 bits to save a storage slot.\r\n        uint64 time;\r\n        uint256 lockedBond;\r\n        bytes ancillaryData;\r\n    }\r\n    mapping(uint256 => BondedProposal) public bondedProposals;\r\n\r\n    event BondSet(uint256 bond);\r\n    event ProposalResolved(uint256 indexed id, bool success);\r\n\r\n    /**\r\n     * @notice Construct the Proposer contract.\r\n     * @param _token the ERC20 token that the bond is paid in.\r\n     * @param _bond the bond amount.\r\n     * @param _governor the governor contract that this contract makes proposals to.\r\n     * @param _finder the finder contract used to look up addresses.\r\n     */\r\n    constructor(\r\n        IERC20 _token,\r\n        uint256 _bond,\r\n        GovernorV2 _governor,\r\n        Finder _finder\r\n    ) {\r\n        token = _token;\r\n        governor = _governor;\r\n        finder = _finder;\r\n        setBond(_bond);\r\n        transferOwnership(address(_governor));\r\n    }\r\n\r\n    /**\r\n     * @notice Propose a new set of governance transactions for vote.\r\n     * @dev Pulls bond from the caller.\r\n     * @param transactions list of transactions for the governor to execute.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return id the id of the governor proposal.\r\n     */\r\n    function propose(GovernorV2.Transaction[] memory transactions, bytes memory ancillaryData)\r\n        external\r\n        nonReentrant()\r\n        returns (uint256)\r\n    {\r\n        uint256 id = governor.numProposals();\r\n        token.safeTransferFrom(msg.sender, address(this), bond);\r\n        bondedProposals[id] = BondedProposal({\r\n            sender: msg.sender,\r\n            lockedBond: bond,\r\n            time: uint64(getCurrentTime()),\r\n            ancillaryData: ancillaryData\r\n        });\r\n        governor.propose(transactions, ancillaryData);\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * @notice Resolves a proposal by checking the status of the request in the Voting contract.\r\n     * @dev For the resolution to work correctly, this contract must be a registered contract in the DVM.\r\n     * @param id proposal id.\r\n     */\r\n    function resolveProposal(uint256 id) external nonReentrant() {\r\n        BondedProposal memory bondedProposal = bondedProposals[id];\r\n        require(bondedProposal.sender != address(0), \"Invalid proposal id\");\r\n        OracleAncillaryInterface voting =\r\n            OracleAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n        bytes32 adminIdentifier = AdminIdentifierLib._constructIdentifier(id);\r\n\r\n        require(\r\n            voting.hasPrice(adminIdentifier, bondedProposal.time, bondedProposal.ancillaryData),\r\n            \"No price resolved\"\r\n        );\r\n        if (voting.getPrice(adminIdentifier, bondedProposal.time, bondedProposal.ancillaryData) != 0) {\r\n            token.safeTransfer(bondedProposal.sender, bondedProposal.lockedBond);\r\n            emit ProposalResolved(id, true);\r\n        } else {\r\n            token.safeTransfer(finder.getImplementationAddress(OracleInterfaces.Store), bondedProposal.lockedBond);\r\n            emit ProposalResolved(id, false);\r\n        }\r\n        delete bondedProposals[id];\r\n    }\r\n\r\n    /**\r\n     * @notice Admin method to set the bond amount.\r\n     * @dev Admin is intended to be the governance system itself.\r\n     * @param _bond the new bond.\r\n     */\r\n    function setBond(uint256 _bond) public nonReentrant() onlyOwner() {\r\n        bond = _bond;\r\n        emit BondSet(_bond);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current block timestamp.\r\n     * @dev Can be overridden to control contract time.\r\n     * @return the current block timestamp.\r\n     */\r\n    function getCurrentTime() public view virtual returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/Registry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/MultiRole.sol\";\r\nimport \"../interfaces/RegistryInterface.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\n/**\r\n * @title Registry for financial contracts and approved financial contract creators.\r\n * @dev Maintains a whitelist of financial contract creators that are allowed\r\n * to register new financial contracts and stores party members of a financial contract.\r\n */\r\ncontract Registry is RegistryInterface, MultiRole {\r\n    using SafeMath for uint256;\r\n\r\n    /****************************************\r\n     *    INTERNAL VARIABLES AND STORAGE    *\r\n     ****************************************/\r\n\r\n    enum Roles {\r\n        Owner, // The owner manages the set of ContractCreators.\r\n        ContractCreator // Can register financial contracts.\r\n    }\r\n\r\n    // This enum is required because a `WasValid` state is required\r\n    // to ensure that financial contracts cannot be re-registered.\r\n    enum Validity { Invalid, Valid }\r\n\r\n    // Local information about a contract.\r\n    struct FinancialContract {\r\n        Validity valid;\r\n        uint128 index;\r\n    }\r\n\r\n    struct Party {\r\n        address[] contracts; // Each financial contract address is stored in this array.\r\n        // The address of each financial contract is mapped to its index for constant time look up and deletion.\r\n        mapping(address => uint256) contractIndex;\r\n    }\r\n\r\n    // Array of all contracts that are approved to use the UMA Oracle.\r\n    address[] public registeredContracts;\r\n\r\n    // Map of financial contract contracts to the associated FinancialContract struct.\r\n    mapping(address => FinancialContract) public contractMap;\r\n\r\n    // Map each party member to their their associated Party struct.\r\n    mapping(address => Party) private partyMap;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event NewContractRegistered(address indexed contractAddress, address indexed creator, address[] parties);\r\n    event PartyAdded(address indexed contractAddress, address indexed party);\r\n    event PartyRemoved(address indexed contractAddress, address indexed party);\r\n\r\n    /**\r\n     * @notice Construct the Registry contract.\r\n     */\r\n    constructor() {\r\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\r\n        // Start with no contract creators registered.\r\n        _createSharedRole(uint256(Roles.ContractCreator), uint256(Roles.Owner), new address[](0));\r\n    }\r\n\r\n    /****************************************\r\n     *        REGISTRATION FUNCTIONS        *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Registers a new financial contract.\r\n     * @dev Only authorized contract creators can call this method.\r\n     * @param parties array of addresses who become parties in the contract.\r\n     * @param contractAddress address of the contract against which the parties are registered.\r\n     */\r\n    function registerContract(address[] calldata parties, address contractAddress)\r\n        external\r\n        override\r\n        onlyRoleHolder(uint256(Roles.ContractCreator))\r\n    {\r\n        FinancialContract storage financialContract = contractMap[contractAddress];\r\n        require(contractMap[contractAddress].valid == Validity.Invalid, \"Can only register once\");\r\n\r\n        // Store contract address as a registered contract.\r\n        registeredContracts.push(contractAddress);\r\n\r\n        // No length check necessary because we should never hit (2^127 - 1) contracts.\r\n        financialContract.index = uint128(registeredContracts.length.sub(1));\r\n\r\n        // For all parties in the array add them to the contract's parties.\r\n        financialContract.valid = Validity.Valid;\r\n        for (uint256 i = 0; i < parties.length; i = i.add(1)) {\r\n            _addPartyToContract(parties[i], contractAddress);\r\n        }\r\n\r\n        emit NewContractRegistered(contractAddress, msg.sender, parties);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a party member to the calling contract.\r\n     * @dev msg.sender will be used to determine the contract that this party is added to.\r\n     * @param party new party for the calling contract.\r\n     */\r\n    function addPartyToContract(address party) external override {\r\n        address contractAddress = msg.sender;\r\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Can only add to valid contract\");\r\n\r\n        _addPartyToContract(party, contractAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes a party member from the calling contract.\r\n     * @dev msg.sender will be used to determine the contract that this party is removed from.\r\n     * @param partyAddress address to be removed from the calling contract.\r\n     */\r\n    function removePartyFromContract(address partyAddress) external override {\r\n        address contractAddress = msg.sender;\r\n        Party storage party = partyMap[partyAddress];\r\n        uint256 numberOfContracts = party.contracts.length;\r\n\r\n        require(numberOfContracts != 0, \"Party has no contracts\");\r\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Remove only from valid contract\");\r\n        require(isPartyMemberOfContract(partyAddress, contractAddress), \"Can only remove existing party\");\r\n\r\n        // Index of the current location of the contract to remove.\r\n        uint256 deleteIndex = party.contractIndex[contractAddress];\r\n\r\n        // Store the last contract's address to update the lookup map.\r\n        address lastContractAddress = party.contracts[numberOfContracts - 1];\r\n\r\n        // Swap the contract to be removed with the last contract.\r\n        party.contracts[deleteIndex] = lastContractAddress;\r\n\r\n        // Update the lookup index with the new location.\r\n        party.contractIndex[lastContractAddress] = deleteIndex;\r\n\r\n        // Pop the last contract from the array and update the lookup map.\r\n        party.contracts.pop();\r\n        delete party.contractIndex[contractAddress];\r\n\r\n        emit PartyRemoved(contractAddress, partyAddress);\r\n    }\r\n\r\n    /****************************************\r\n     *         REGISTRY STATE GETTERS       *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Returns whether the contract has been registered with the registry.\r\n     * @dev If it is registered, it is an authorized participant in the UMA system.\r\n     * @param contractAddress address of the financial contract.\r\n     * @return bool indicates whether the contract is registered.\r\n     */\r\n    function isContractRegistered(address contractAddress) external view override returns (bool) {\r\n        return contractMap[contractAddress].valid == Validity.Valid;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a list of all contracts that are associated with a particular party.\r\n     * @param party address of the party.\r\n     * @return an array of the contracts the party is registered to.\r\n     */\r\n    function getRegisteredContracts(address party) external view override returns (address[] memory) {\r\n        return partyMap[party].contracts;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns all registered contracts.\r\n     * @return all registered contract addresses within the system.\r\n     */\r\n    function getAllRegisteredContracts() external view override returns (address[] memory) {\r\n        return registeredContracts;\r\n    }\r\n\r\n    /**\r\n     * @notice checks if an address is a party of a contract.\r\n     * @param party party to check.\r\n     * @param contractAddress address to check against the party.\r\n     * @return bool indicating if the address is a party of the contract.\r\n     */\r\n    function isPartyMemberOfContract(address party, address contractAddress) public view override returns (bool) {\r\n        uint256 index = partyMap[party].contractIndex[contractAddress];\r\n        return partyMap[party].contracts.length > index && partyMap[party].contracts[index] == contractAddress;\r\n    }\r\n\r\n    /****************************************\r\n     *           INTERNAL FUNCTIONS         *\r\n     ****************************************/\r\n\r\n    function _addPartyToContract(address party, address contractAddress) internal {\r\n        require(!isPartyMemberOfContract(party, contractAddress), \"Can only register a party once\");\r\n        uint256 contractIndex = partyMap[party].contracts.length;\r\n        partyMap[party].contracts.push(contractAddress);\r\n        partyMap[party].contractIndex[contractAddress] = contractIndex;\r\n\r\n        emit PartyAdded(contractAddress, party);\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/ResultComputation.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n/**\r\n * @title Computes vote results.\r\n * @dev The result is the mode of the added votes. Otherwise, the vote is unresolved.\r\n */\r\nlibrary ResultComputation {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    /****************************************\r\n     *   INTERNAL LIBRARY DATA STRUCTURE    *\r\n     ****************************************/\r\n\r\n    struct Data {\r\n        // Maps price to number of tokens that voted for that price.\r\n        mapping(int256 => FixedPoint.Unsigned) voteFrequency;\r\n        // The total votes that have been added.\r\n        FixedPoint.Unsigned totalVotes;\r\n        // The price that is the current mode, i.e., the price with the highest frequency in `voteFrequency`.\r\n        int256 currentMode;\r\n    }\r\n\r\n    /****************************************\r\n     *            VOTING FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Adds a new vote to be used when computing the result.\r\n     * @param data contains information to which the vote is applied.\r\n     * @param votePrice value specified in the vote for the given `numberTokens`.\r\n     * @param numberTokens number of tokens that voted on the `votePrice`.\r\n     */\r\n    function addVote(\r\n        Data storage data,\r\n        int256 votePrice,\r\n        FixedPoint.Unsigned memory numberTokens\r\n    ) internal {\r\n        data.totalVotes = data.totalVotes.add(numberTokens);\r\n        data.voteFrequency[votePrice] = data.voteFrequency[votePrice].add(numberTokens);\r\n        if (\r\n            votePrice != data.currentMode &&\r\n            data.voteFrequency[votePrice].isGreaterThan(data.voteFrequency[data.currentMode])\r\n        ) data.currentMode = votePrice;\r\n    }\r\n\r\n    /****************************************\r\n     *        VOTING STATE GETTERS          *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Returns whether the result is resolved, and if so, what value it resolved to.\r\n     * @dev `price` should be ignored if `isResolved` is false.\r\n     * @param data contains information against which the `minVoteThreshold` is applied.\r\n     * @param minVoteThreshold min (exclusive) number of tokens that must have voted for the result to be valid. Can be\r\n     * used to enforce a minimum voter participation rate, regardless of how the votes are distributed.\r\n     * @return isResolved indicates if the price has been resolved correctly.\r\n     * @return price the price that the dvm resolved to.\r\n     */\r\n    function getResolvedPrice(Data storage data, FixedPoint.Unsigned memory minVoteThreshold)\r\n        internal\r\n        view\r\n        returns (bool isResolved, int256 price)\r\n    {\r\n        FixedPoint.Unsigned memory modeThreshold = FixedPoint.fromUnscaledUint(50).div(100);\r\n\r\n        if (\r\n            data.totalVotes.isGreaterThan(minVoteThreshold) &&\r\n            data.voteFrequency[data.currentMode].div(data.totalVotes).isGreaterThan(modeThreshold)\r\n        ) {\r\n            // `modeThreshold` and `minVoteThreshold` are exceeded, so the current mode is the resolved price.\r\n            isResolved = true;\r\n            price = data.currentMode;\r\n        } else isResolved = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks whether a `voteHash` is considered correct.\r\n     * @dev Should only be called after a vote is resolved, i.e., via `getResolvedPrice`.\r\n     * @param data contains information against which the `voteHash` is checked.\r\n     * @param voteHash committed hash submitted by the voter.\r\n     * @return bool true if the vote was correct.\r\n     */\r\n    function wasVoteCorrect(Data storage data, bytes32 voteHash) internal view returns (bool) {\r\n        return voteHash == keccak256(abi.encode(data.currentMode));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the total number of tokens whose votes are considered correct.\r\n     * @dev Should only be called after a vote is resolved, i.e., via `getResolvedPrice`.\r\n     * @param data contains all votes against which the correctly voted tokens are counted.\r\n     * @return FixedPoint.Unsigned which indicates the frequency of the correctly voted tokens.\r\n     */\r\n    function getTotalCorrectlyVotedTokens(Data storage data) internal view returns (FixedPoint.Unsigned memory) {\r\n        return data.voteFrequency[data.currentMode];\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/ResultComputationV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title Computes vote results.\r\n * @dev The result is the mode of the added votes. Otherwise, the vote is unresolved.\r\n */\r\nlibrary ResultComputationV2 {\r\n    /****************************************\r\n     *   INTERNAL LIBRARY DATA STRUCTURE    *\r\n     ****************************************/\r\n\r\n    struct Data {\r\n        mapping(int256 => uint128) voteFrequency; // Maps price to number of tokens that voted for that price.\r\n        uint128 totalVotes; // The total votes that have been added.\r\n        int256 currentMode; // The price that is the current mode, i.e., the price with the highest frequency.\r\n    }\r\n\r\n    /****************************************\r\n     *            VOTING FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Adds a new vote to be used when computing the result.\r\n     * @param data contains information to which the vote is applied.\r\n     * @param votePrice value specified in the vote for the given `numberTokens`.\r\n     * @param numberTokens number of tokens that voted on the `votePrice`.\r\n     */\r\n    function addVote(\r\n        Data storage data,\r\n        int256 votePrice,\r\n        uint128 numberTokens\r\n    ) internal {\r\n        data.totalVotes += numberTokens;\r\n        data.voteFrequency[votePrice] += numberTokens;\r\n        if (votePrice != data.currentMode && data.voteFrequency[votePrice] > data.voteFrequency[data.currentMode])\r\n            data.currentMode = votePrice;\r\n    }\r\n\r\n    /****************************************\r\n     *        VOTING STATE GETTERS          *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Returns whether the result is resolved, and if so, what value it resolved to.\r\n     * @dev `price` should be ignored if `isResolved` is false.\r\n     * @param data contains information against which the `minTotalVotes` and `minModalVotes` thresholds are applied.\r\n     * @param minTotalVotes min (exclusive) number of tokens that must have voted (in any direction) for the result\r\n     * to be valid. Used to enforce a minimum voter participation rate, regardless of how the votes are distributed.\r\n     * @param minModalVotes min (exclusive) number of tokens that must have voted for the modal outcome for it to result\r\n     * in a resolution. This is used to avoid cases where the mode is a very small plurality.\r\n     * @return isResolved indicates if the price has been resolved correctly.\r\n     * @return price the price that the dvm resolved to.\r\n     */\r\n    function getResolvedPrice(\r\n        Data storage data,\r\n        uint128 minTotalVotes,\r\n        uint128 minModalVotes\r\n    ) internal view returns (bool isResolved, int256 price) {\r\n        if (data.totalVotes > minTotalVotes && data.voteFrequency[data.currentMode] > minModalVotes) {\r\n            isResolved = true; // minTotalVotes and minModalVotes are exceeded, so the resolved price is the mode.\r\n            price = data.currentMode;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks whether a `voteHash` is considered correct.\r\n     * @dev Should only be called after a vote is resolved, i.e., via `getResolvedPrice`.\r\n     * @param data contains information against which the `voteHash` is checked.\r\n     * @param voteHash committed hash submitted by the voter.\r\n     * @return bool true if the vote was correct.\r\n     */\r\n    function wasVoteCorrect(Data storage data, bytes32 voteHash) internal view returns (bool) {\r\n        return voteHash == keccak256(abi.encode(data.currentMode));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the total number of tokens whose votes are considered correct.\r\n     * @dev Should only be called after a vote is resolved, i.e., via `getResolvedPrice`.\r\n     * @param data contains all votes against which the correctly voted tokens are counted.\r\n     * @return uint128 which indicates the frequency of the correctly voted tokens.\r\n     */\r\n    function getTotalCorrectlyVotedTokens(Data storage data) internal view returns (uint128) {\r\n        return data.voteFrequency[data.currentMode];\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/Staker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/MultiCaller.sol\";\r\n\r\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\r\nimport \"../interfaces/StakerInterface.sol\";\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\n\r\n/**\r\n * @title Staking contract enabling UMA to be locked up by stakers to earn a pro rata share of a fixed emission rate.\r\n * @dev Handles the staking, unstaking and reward retrieval logic.\r\n */\r\nabstract contract Staker is StakerInterface, Ownable, Lockable, MultiCaller {\r\n    /****************************************\r\n     *             STAKING STATE            *\r\n     ****************************************/\r\n\r\n    // Identifies a \"stake\" for a given voter. Each staker has an instance of this struct.\r\n    struct VoterStake {\r\n        uint128 stake; // UMA staked by the staker.\r\n        uint128 pendingUnstake; // UMA in unstake cooldown period, waiting to be unstaked.\r\n        mapping(uint32 => uint128) pendingStakes; // If a voter stakes during an active reveal, stake is pending.\r\n        uint128 rewardsPaidPerToken; // Internal tracker used in the calculation of pro-rata share of rewards.\r\n        uint128 outstandingRewards; // Accumulated rewards that have not yet been claimed.\r\n        int128 unappliedSlash; // Used to track unapplied slashing in the case of bisected rounds.\r\n        uint64 nextIndexToProcess; // The next request index that a staker is susceptible to be slashed on.\r\n        uint64 unstakeTime; // Time that a staker can unstake. Used to determine if cooldown has passed.\r\n        address delegate; // Address a staker has delegated to. The delegate can commit/reveal/claimRestake rewards.\r\n    }\r\n\r\n    mapping(address => VoterStake) public voterStakes; // Each voter is mapped to staker struct for their position.\r\n\r\n    mapping(address => address) public delegateToStaker; // Mapping of delegates to their delegators (staker).\r\n\r\n    uint128 public emissionRate; // Number of UMA emitted per second to incentivize stakers.\r\n\r\n    uint128 public cumulativeStake; // Total number of UMA staked within the system.\r\n\r\n    uint128 public rewardPerTokenStored; // Tracker used to allocate pro-rata share of rewards to stakers.\r\n\r\n    uint64 public unstakeCoolDown; // Delay, in seconds, a staker must wait when trying to unstake their UMA.\r\n\r\n    uint64 public lastUpdateTime; // Tracks the last time the reward rate was updated, used in reward allocation.\r\n\r\n    ExpandedIERC20 public immutable votingToken; // An instance of the UMA voting token to mint rewards for stakers\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event Staked(\r\n        address indexed voter,\r\n        address indexed from,\r\n        uint128 amount,\r\n        uint128 voterStake,\r\n        uint128 voterPendingUnstake,\r\n        uint128 cumulativeStake\r\n    );\r\n\r\n    event RequestedUnstake(address indexed voter, uint128 amount, uint64 unstakeTime, uint128 voterStake);\r\n\r\n    event ExecutedUnstake(address indexed voter, uint128 tokensSent, uint128 voterStake);\r\n\r\n    event WithdrawnRewards(address indexed voter, address indexed delegate, uint128 tokensWithdrawn);\r\n\r\n    event UpdatedReward(address indexed voter, uint128 newReward, uint64 lastUpdateTime);\r\n\r\n    event SetNewEmissionRate(uint128 newEmissionRate);\r\n\r\n    event SetNewUnstakeCoolDown(uint64 newUnstakeCoolDown);\r\n\r\n    event DelegateSet(address indexed delegator, address indexed delegate);\r\n\r\n    event DelegatorSet(address indexed delegate, address indexed delegator);\r\n\r\n    /**\r\n     * @notice Construct the Staker contract\r\n     * @param _emissionRate amount of voting tokens that are emitted per second, split pro rata to stakers.\r\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\r\n     * @param _votingToken address of the UMA token contract used to commit votes.\r\n     */\r\n    constructor(\r\n        uint128 _emissionRate,\r\n        uint64 _unstakeCoolDown,\r\n        address _votingToken\r\n    ) {\r\n        setEmissionRate(_emissionRate);\r\n        setUnstakeCoolDown(_unstakeCoolDown);\r\n        votingToken = ExpandedIERC20(_votingToken);\r\n    }\r\n\r\n    /****************************************\r\n     *           STAKER FUNCTIONS           *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Pulls tokens from the sender's wallet and stakes them on his behalf.\r\n     * @param amount the amount of tokens to stake.\r\n     */\r\n    function stake(uint128 amount) external {\r\n        _stakeTo(msg.sender, msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Pulls tokens from the sender's wallet and stakes them for the recipient.\r\n     * @param recipient the recipient address.\r\n     * @param amount the amount of tokens to stake.\r\n     */\r\n    function stakeTo(address recipient, uint128 amount) external {\r\n        _stakeTo(msg.sender, recipient, amount);\r\n    }\r\n\r\n    // Pull an amount of votingToken from the from address and stakes them for the recipient address.\r\n    // If we are in an active reveal phase the stake amount will be added to the pending stake.\r\n    // If not, the stake amount will be added to the stake.\r\n    function _stakeTo(\r\n        address from,\r\n        address recipient,\r\n        uint128 amount\r\n    ) internal {\r\n        require(amount > 0, \"Cannot stake 0\");\r\n\r\n        VoterStake storage voterStake = voterStakes[recipient];\r\n\r\n        // If the staker has a cumulative staked balance of 0 then we can shortcut their nextIndexToProcess to\r\n        // the most recent index. This means we don't need to traverse requests where the staker was not staked.\r\n        // _getStartingIndexForStaker returns the appropriate index to start at.\r\n        if (voterStake.stake == 0) voterStake.nextIndexToProcess = _getStartingIndexForStaker();\r\n        _updateTrackers(recipient);\r\n\r\n        // Compute pending stakes when needed.\r\n        _computePendingStakes(recipient, amount);\r\n\r\n        voterStake.stake += amount;\r\n        cumulativeStake += amount;\r\n\r\n        // Tokens are pulled from the from address and sent to this contract.\r\n        // During withdrawAndRestake, from is the same as the address of this contract, so there is no need to transfer.\r\n        if (from != address(this)) votingToken.transferFrom(from, address(this), amount);\r\n        emit Staked(recipient, from, amount, voterStake.stake, voterStake.pendingUnstake, cumulativeStake);\r\n    }\r\n\r\n    /**\r\n     * @notice Request a certain number of tokens to be unstaked. After the unstake time expires, the user may execute\r\n     * the unstake. Tokens requested to unstake are not slashable nor subject to earning rewards.\r\n     * This function cannot be called during an active reveal phase.\r\n     * Note there is no way to cancel an unstake request, you must wait until after unstakeTime and re-stake.\r\n     * @param amount the amount of tokens to request to be unstaked.\r\n     */\r\n    function requestUnstake(uint128 amount) external nonReentrant() {\r\n        require(!_inActiveReveal(), \"In an active reveal phase\");\r\n        require(amount > 0, \"Cannot unstake 0\");\r\n        _updateTrackers(msg.sender);\r\n        VoterStake storage voterStake = voterStakes[msg.sender];\r\n\r\n        require(voterStake.stake >= amount && voterStake.pendingUnstake == 0, \"Bad amount or pending unstake\");\r\n\r\n        cumulativeStake -= amount;\r\n        voterStake.pendingUnstake = amount;\r\n        voterStake.stake -= amount;\r\n        voterStake.unstakeTime = uint64(getCurrentTime()) + unstakeCoolDown;\r\n\r\n        emit RequestedUnstake(msg.sender, amount, voterStake.unstakeTime, voterStake.stake);\r\n    }\r\n\r\n    /**\r\n     * @notice  Execute a previously requested unstake. Requires the unstake time to have passed.\r\n     * @dev If a staker requested an unstake and time > unstakeTime then send funds to staker. If unstakeCoolDown is\r\n     * set to 0 then the unstake can be executed immediately.\r\n     */\r\n    function executeUnstake() external nonReentrant() {\r\n        VoterStake storage voterStake = voterStakes[msg.sender];\r\n        require(\r\n            voterStake.unstakeTime != 0 && (getCurrentTime() >= voterStake.unstakeTime || unstakeCoolDown == 0),\r\n            \"Unstake time not passed\"\r\n        );\r\n        uint128 tokensToSend = voterStake.pendingUnstake;\r\n\r\n        if (tokensToSend > 0) {\r\n            voterStake.pendingUnstake = 0;\r\n            voterStake.unstakeTime = 0;\r\n            votingToken.transfer(msg.sender, tokensToSend);\r\n        }\r\n\r\n        emit ExecutedUnstake(msg.sender, tokensToSend, voterStake.stake);\r\n    }\r\n\r\n    /**\r\n     * @notice Send accumulated rewards to the voter. Note that these rewards do not include slashing balance changes.\r\n     * @return uint128 the amount of tokens sent to the voter.\r\n     */\r\n    function withdrawRewards() external returns (uint128) {\r\n        return _withdrawRewards(msg.sender, msg.sender);\r\n    }\r\n\r\n    // Withdraws rewards for a given voter and sends them to the recipient.\r\n    function _withdrawRewards(address voter, address recipient) internal returns (uint128) {\r\n        _updateTrackers(voter);\r\n        VoterStake storage voterStake = voterStakes[voter];\r\n\r\n        uint128 tokensToMint = voterStake.outstandingRewards;\r\n        if (tokensToMint > 0) {\r\n            voterStake.outstandingRewards = 0;\r\n            require(votingToken.mint(recipient, tokensToMint), \"Voting token issuance failed\");\r\n            emit WithdrawnRewards(voter, msg.sender, tokensToMint);\r\n        }\r\n        return tokensToMint;\r\n    }\r\n\r\n    /**\r\n     * @notice Stake accumulated rewards. This is merely a convenience mechanism that combines the voter's withdrawal\r\n     * and stake in the same transaction if requested by a delegate or the voter.\r\n     * @dev The rewarded tokens simply pass through this contract before being staked on the voter's behalf.\r\n     *  The balance of the delegate remains unchanged.\r\n     * @return uint128 the amount of tokens that the voter is staking.\r\n     */\r\n    function withdrawAndRestake() external returns (uint128) {\r\n        address voter = getVoterFromDelegate(msg.sender);\r\n        uint128 rewards = _withdrawRewards(voter, address(this));\r\n        _stakeTo(address(this), voter, rewards);\r\n        return rewards;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the delegate of a voter. This delegate can vote on behalf of the staker. The staker will still own\r\n     * all staked balances, receive rewards and be slashed based on the actions of the delegate. Intended use is using a\r\n     * low-security available wallet for voting while keeping access to staked amounts secure by a more secure wallet.\r\n     * @param delegate the address of the delegate.\r\n     */\r\n    function setDelegate(address delegate) external {\r\n        voterStakes[msg.sender].delegate = delegate;\r\n        emit DelegateSet(msg.sender, delegate);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the delegator of a voter. Acts to accept a delegation. The delegate can only vote for the delegator\r\n     * if the delegator also selected the delegate to do so (two-way relationship needed).\r\n     * @param delegator the address of the delegator.\r\n     */\r\n    function setDelegator(address delegator) external {\r\n        delegateToStaker[msg.sender] = delegator;\r\n        emit DelegatorSet(msg.sender, delegator);\r\n    }\r\n\r\n    /****************************************\r\n     *        OWNER ADMIN FUNCTIONS         *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice  Set the token's emission rate, the number of voting tokens that are emitted per second.\r\n     * @param newEmissionRate the new amount of voting tokens that are emitted per second, split pro rata to stakers.\r\n     */\r\n    function setEmissionRate(uint128 newEmissionRate) public onlyOwner {\r\n        _updateReward(address(0));\r\n        emissionRate = newEmissionRate;\r\n        emit SetNewEmissionRate(newEmissionRate);\r\n    }\r\n\r\n    /**\r\n     * @notice  Set the amount of time a voter must wait to unstake after submitting a request to do so.\r\n     * @param newUnstakeCoolDown the new duration of the cool down period in seconds.\r\n     */\r\n    function setUnstakeCoolDown(uint64 newUnstakeCoolDown) public onlyOwner {\r\n        unstakeCoolDown = newUnstakeCoolDown;\r\n        emit SetNewUnstakeCoolDown(newUnstakeCoolDown);\r\n    }\r\n\r\n    // Updates an account internal trackers.\r\n    function _updateTrackers(address voter) internal virtual {\r\n        _updateReward(voter);\r\n    }\r\n\r\n    /****************************************\r\n     *            VIEW FUNCTIONS            *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Gets the pending stake for a voter for a given round.\r\n     * @param voter the voter address.\r\n     * @param roundId round id.\r\n     * @return uint128 amount of the pending stake.\r\n     */\r\n    function getVoterPendingStake(address voter, uint32 roundId) external view returns (uint128) {\r\n        return voterStakes[voter].pendingStakes[roundId];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the voter from the delegate.\r\n     * @param caller caller of the function or the address to check in the mapping between a voter and their delegate.\r\n     * @return address voter that corresponds to the delegate.\r\n     */\r\n    function getVoterFromDelegate(address caller) public view returns (address) {\r\n        address delegator = delegateToStaker[caller];\r\n        // The delegate chose to be a delegate for the staker.\r\n        if (delegator != address(0) && voterStakes[delegator].delegate == caller) return delegator;\r\n        else return caller; // The staker chose the delegate.\r\n    }\r\n\r\n    /**\r\n     * @notice  Determine the number of outstanding token rewards that can be withdrawn by a voter.\r\n     * @param voter the address of the voter.\r\n     * @return uint256 the outstanding rewards.\r\n     */\r\n    function outstandingRewards(address voter) public view returns (uint256) {\r\n        VoterStake storage voterStake = voterStakes[voter];\r\n\r\n        return\r\n            ((voterStake.stake * (rewardPerToken() - voterStake.rewardsPaidPerToken)) / 1e18) +\r\n            voterStake.outstandingRewards;\r\n    }\r\n\r\n    /**\r\n     * @notice  Calculate the reward per token based on the last time the reward was updated.\r\n     * @return uint256 the reward per token.\r\n     */\r\n    function rewardPerToken() public view returns (uint256) {\r\n        if (cumulativeStake == 0) return rewardPerTokenStored;\r\n        return rewardPerTokenStored + ((getCurrentTime() - lastUpdateTime) * emissionRate * 1e18) / cumulativeStake;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total amount of tokens staked by the voter, after applying updateTrackers. Specifically used\r\n     * by offchain apps to simulate the cumulative stake + unapplied slashing updates without sending a transaction.\r\n     * @param voter the address of the voter.\r\n     * @return uint128 the total stake.\r\n     */\r\n    function getVoterStakePostUpdate(address voter) external returns (uint128) {\r\n        _updateTrackers(voter);\r\n        return voterStakes[voter].stake;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current block timestamp.\r\n     * @dev Can be overridden to control contract time.\r\n     * @return the current block timestamp.\r\n     */\r\n    function getCurrentTime() public view virtual returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /****************************************\r\n     *          INTERNAL FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    // This function must be called before any tokens are staked. Update the voter's pending stakes when necessary.\r\n    // The contract that inherits from Staker (e.g. VotingV2) must implement this logic by overriding this function.\r\n    function _computePendingStakes(address voter, uint128 amount) internal virtual;\r\n\r\n    // Add a new stake amount to the voter's pending stake for a specific round id.\r\n    function _incrementPendingStake(\r\n        address voter,\r\n        uint32 roundId,\r\n        uint128 amount\r\n    ) internal {\r\n        voterStakes[voter].pendingStakes[roundId] += amount;\r\n    }\r\n\r\n    // Determine if we are in an active reveal phase. This function should be overridden by the child contract.\r\n    function _inActiveReveal() internal view virtual returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    // Returns the starting index for a staker. This function should be overridden by the implementing contract.\r\n    function _getStartingIndexForStaker() internal virtual returns (uint64) {\r\n        return 0;\r\n    }\r\n\r\n    // Calculate the reward per token based on last time the reward was updated.\r\n    function _updateReward(address voter) internal {\r\n        uint128 newRewardPerToken = uint128(rewardPerToken());\r\n        rewardPerTokenStored = newRewardPerToken;\r\n        lastUpdateTime = uint64(getCurrentTime());\r\n        if (voter != address(0)) {\r\n            VoterStake storage voterStake = voterStakes[voter];\r\n            voterStake.outstandingRewards = uint128(outstandingRewards(voter));\r\n            voterStake.rewardsPaidPerToken = newRewardPerToken;\r\n        }\r\n        emit UpdatedReward(voter, newRewardPerToken, lastUpdateTime);\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/Store.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/implementation/MultiRole.sol\";\r\nimport \"../../common/implementation/Withdrawable.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../interfaces/StoreInterface.sol\";\r\n\r\n/**\r\n * @title An implementation of Store that can accept Oracle fees in ETH or any arbitrary ERC20 token.\r\n */\r\ncontract Store is StoreInterface, Withdrawable, Testable {\r\n    using SafeMath for uint256;\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using FixedPoint for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /****************************************\r\n     *    INTERNAL VARIABLES AND STORAGE    *\r\n     ****************************************/\r\n\r\n    enum Roles { Owner, Withdrawer }\r\n\r\n    FixedPoint.Unsigned public fixedOracleFeePerSecondPerPfc; // Percentage of 1 E.g., .1 is 10% Oracle fee.\r\n    FixedPoint.Unsigned public weeklyDelayFeePerSecondPerPfc; // Percentage of 1 E.g., .1 is 10% weekly delay fee.\r\n\r\n    mapping(address => FixedPoint.Unsigned) public finalFees;\r\n    uint256 public constant SECONDS_PER_WEEK = 604800;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event NewFixedOracleFeePerSecondPerPfc(FixedPoint.Unsigned newOracleFee);\r\n    event NewWeeklyDelayFeePerSecondPerPfc(FixedPoint.Unsigned newWeeklyDelayFeePerSecondPerPfc);\r\n    event NewFinalFee(FixedPoint.Unsigned newFinalFee);\r\n\r\n    /**\r\n     * @notice Construct the Store contract.\r\n     */\r\n    constructor(\r\n        FixedPoint.Unsigned memory _fixedOracleFeePerSecondPerPfc,\r\n        FixedPoint.Unsigned memory _weeklyDelayFeePerSecondPerPfc,\r\n        address _timerAddress\r\n    ) Testable(_timerAddress) {\r\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\r\n        _createWithdrawRole(uint256(Roles.Withdrawer), uint256(Roles.Owner), msg.sender);\r\n        setFixedOracleFeePerSecondPerPfc(_fixedOracleFeePerSecondPerPfc);\r\n        setWeeklyDelayFeePerSecondPerPfc(_weeklyDelayFeePerSecondPerPfc);\r\n    }\r\n\r\n    /****************************************\r\n     *  ORACLE FEE CALCULATION AND PAYMENT  *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Pays Oracle fees in ETH to the store.\r\n     * @dev To be used by contracts whose margin currency is ETH.\r\n     */\r\n    function payOracleFees() external payable override {\r\n        require(msg.value > 0, \"Value sent can't be zero\");\r\n    }\r\n\r\n    /**\r\n     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\r\n     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\r\n     * @param erc20Address address of the ERC20 token used to pay the fee.\r\n     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\r\n     */\r\n    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external override {\r\n        IERC20 erc20 = IERC20(erc20Address);\r\n        require(amount.isGreaterThan(0), \"Amount sent can't be zero\");\r\n        erc20.safeTransferFrom(msg.sender, address(this), amount.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the regular oracle fees that a contract should pay for a period.\r\n     * @dev The late penalty is similar to the regular fee in that is is charged per second over the period between\r\n     * startTime and endTime.\r\n     *\r\n     * The late penalty percentage increases over time as follows:\r\n     *\r\n     * - 0-1 week since startTime: no late penalty\r\n     *\r\n     * - 1-2 weeks since startTime: 1x late penalty percentage is applied\r\n     *\r\n     * - 2-3 weeks since startTime: 2x late penalty percentage is applied\r\n     *\r\n     * - ...\r\n     *\r\n     * @param startTime defines the beginning time from which the fee is paid.\r\n     * @param endTime end time until which the fee is paid.\r\n     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a\r\n     * token sponsor could extract from the contract through corrupting the price feed in their favor.\r\n     * @return regularFee amount owed for the duration from start to end time for the given pfc.\r\n     * @return latePenalty penalty percentage, if any, for paying the fee after the deadline.\r\n     */\r\n    function computeRegularFee(\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        FixedPoint.Unsigned calldata pfc\r\n    ) external view override returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty) {\r\n        uint256 timeDiff = endTime.sub(startTime);\r\n\r\n        // Multiply by the unscaled `timeDiff` first, to get more accurate results.\r\n        regularFee = pfc.mul(timeDiff).mul(fixedOracleFeePerSecondPerPfc);\r\n\r\n        // Compute how long ago the start time was to compute the delay penalty.\r\n        uint256 paymentDelay = getCurrentTime().sub(startTime);\r\n\r\n        // Compute the additional percentage (per second) that will be charged because of the penalty.\r\n        // Note: if less than a week has gone by since the startTime, paymentDelay / SECONDS_PER_WEEK will truncate to\r\n        // 0, causing no penalty to be charged.\r\n        FixedPoint.Unsigned memory penaltyPercentagePerSecond =\r\n            weeklyDelayFeePerSecondPerPfc.mul(paymentDelay.div(SECONDS_PER_WEEK));\r\n\r\n        // Apply the penaltyPercentagePerSecond to the payment period.\r\n        latePenalty = pfc.mul(timeDiff).mul(penaltyPercentagePerSecond);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the final oracle fees that a contract should pay at settlement.\r\n     * @param currency token used to pay the final fee.\r\n     * @return finalFee amount due denominated in units of `currency`.\r\n     */\r\n    function computeFinalFee(address currency) external view override returns (FixedPoint.Unsigned memory) {\r\n        return finalFees[currency];\r\n    }\r\n\r\n    /****************************************\r\n     *   ADMIN STATE MODIFYING FUNCTIONS    *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Sets a new oracle fee per second.\r\n     * @param newFixedOracleFeePerSecondPerPfc new fee per second charged to use the oracle.\r\n     */\r\n    function setFixedOracleFeePerSecondPerPfc(FixedPoint.Unsigned memory newFixedOracleFeePerSecondPerPfc)\r\n        public\r\n        onlyRoleHolder(uint256(Roles.Owner))\r\n    {\r\n        // Oracle fees at or over 100% don't make sense.\r\n        require(newFixedOracleFeePerSecondPerPfc.isLessThan(1), \"Fee must be < 100% per second.\");\r\n        fixedOracleFeePerSecondPerPfc = newFixedOracleFeePerSecondPerPfc;\r\n        emit NewFixedOracleFeePerSecondPerPfc(newFixedOracleFeePerSecondPerPfc);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a new weekly delay fee.\r\n     * @param newWeeklyDelayFeePerSecondPerPfc fee escalation per week of late fee payment.\r\n     */\r\n    function setWeeklyDelayFeePerSecondPerPfc(FixedPoint.Unsigned memory newWeeklyDelayFeePerSecondPerPfc)\r\n        public\r\n        onlyRoleHolder(uint256(Roles.Owner))\r\n    {\r\n        require(newWeeklyDelayFeePerSecondPerPfc.isLessThan(1), \"weekly delay fee must be < 100%\");\r\n        weeklyDelayFeePerSecondPerPfc = newWeeklyDelayFeePerSecondPerPfc;\r\n        emit NewWeeklyDelayFeePerSecondPerPfc(newWeeklyDelayFeePerSecondPerPfc);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a new final fee for a particular currency.\r\n     * @param currency defines the token currency used to pay the final fee.\r\n     * @param newFinalFee final fee amount.\r\n     */\r\n    function setFinalFee(address currency, FixedPoint.Unsigned memory newFinalFee)\r\n        public\r\n        onlyRoleHolder(uint256(Roles.Owner))\r\n    {\r\n        finalFees[currency] = newFinalFee;\r\n        emit NewFinalFee(newFinalFee);\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/EmergencyProposerTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../EmergencyProposer.sol\";\r\nimport \"../../../common/implementation/Testable.sol\";\r\n\r\ncontract EmergencyProposerTest is EmergencyProposer, Testable {\r\n    constructor(\r\n        IERC20 _token,\r\n        uint256 _quorum,\r\n        GovernorV2 _governor,\r\n        address _executor,\r\n        address _timerAddress,\r\n        uint64 _minimumWaitTime\r\n    ) EmergencyProposer(_token, _quorum, _governor, _executor, _minimumWaitTime) Testable(_timerAddress) {}\r\n\r\n    function getCurrentTime() public view override(EmergencyProposer, Testable) returns (uint256) {\r\n        return Testable.getCurrentTime();\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/GovernorTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../Governor.sol\";\r\nimport \"../AdminIdentifierLib.sol\";\r\n\r\n// GovernorTest exposes internal methods in the Governor for testing.\r\ncontract GovernorTest is Governor {\r\n    constructor(address _timerAddress) Governor(address(0), 0, _timerAddress) {}\r\n\r\n    function addPrefix(\r\n        bytes32 input,\r\n        bytes32 prefix,\r\n        uint256 prefixLength\r\n    ) external pure returns (bytes32) {\r\n        return AdminIdentifierLib._addPrefix(input, prefix, prefixLength);\r\n    }\r\n\r\n    function uintToUtf8(uint256 v) external pure returns (bytes32 ret) {\r\n        return AdminIdentifierLib._uintToUtf8(v);\r\n    }\r\n\r\n    function constructIdentifier(uint256 id) external pure returns (bytes32 identifier) {\r\n        return AdminIdentifierLib._constructIdentifier(id);\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/GovernorV2Test.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../GovernorV2.sol\";\r\nimport \"../../../common/implementation/Testable.sol\";\r\n\r\ncontract GovernorV2Test is GovernorV2, Testable {\r\n    constructor(\r\n        address _finderAddress,\r\n        uint256 _startingId,\r\n        address _timerAddress\r\n    ) GovernorV2(_finderAddress, _startingId) Testable(_timerAddress) {}\r\n\r\n    function getCurrentTime() public view override(GovernorV2, Testable) returns (uint256) {\r\n        return Testable.getCurrentTime();\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/MockAdministratee.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../interfaces/AdministrateeInterface.sol\";\r\n\r\n// A mock implementation of AdministrateeInterface, taking the place of a financial contract.\r\ncontract MockAdministratee is AdministrateeInterface {\r\n    uint256 public timesRemargined;\r\n    uint256 public timesEmergencyShutdown;\r\n\r\n    function remargin() external override {\r\n        timesRemargined++;\r\n    }\r\n\r\n    function emergencyShutdown() external override {\r\n        timesEmergencyShutdown++;\r\n    }\r\n\r\n    function pfc() external pure override returns (FixedPoint.Unsigned memory) {\r\n        return FixedPoint.fromUnscaledUint(0);\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/PriceIdentifierSlashingLibaryTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../../interfaces/SlashingLibraryInterface.sol\";\r\nimport \"../VotingV2.sol\";\r\n\r\n/**\r\n * @title Slashing Library contract that uses the price identifier to calculate the amount of tokens to slash.\r\n */\r\n\r\ncontract PriceIdentifierSlashingLibaryTest is SlashingLibraryInterface {\r\n    VotingV2 public voting;\r\n\r\n    bytes32 public constant whiteListedIdentifier = \"SAFE_NO_VOTE\";\r\n\r\n    uint256 public constant slashPerToken = 0.0016e18;\r\n\r\n    constructor(address _votingV2Address) {\r\n        voting = VotingV2(_votingV2Address);\r\n    }\r\n\r\n    function calcWrongVoteSlashPerToken(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public pure returns (uint256) {}\r\n\r\n    function calcWrongVoteSlashPerTokenGovernance(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public pure returns (uint256) {}\r\n\r\n    function calcNoVoteSlashPerToken(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public pure returns (uint256) {}\r\n\r\n    function calcSlashing(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex,\r\n        bool isGovernance\r\n    ) external view returns (uint256 wrongVoteSlashPerToken, uint256 noVoteSlashPerToken) {\r\n        bytes32 priceRequestIdentifier = voting.resolvedPriceRequestIds(priceRequestIndex);\r\n        (, , , , bytes32 identifier, ) = voting.priceRequests(priceRequestIdentifier);\r\n\r\n        // If the identifier is whiteListedIdentifier, then no tokens are slashed for no vote.\r\n        uint256 noVoteSlashPerToken = identifier == whiteListedIdentifier ? 0 : slashPerToken;\r\n\r\n        // If it's a governance price request, then no tokens are slashed for wrong vote.\r\n        uint256 wrongVoteSlashPerToken = isGovernance ? 0 : slashPerToken;\r\n\r\n        return (isGovernance ? 0 : slashPerToken, noVoteSlashPerToken);\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/ProposerV2Test.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../ProposerV2.sol\";\r\nimport \"../AdminIdentifierLib.sol\";\r\nimport \"../../../common/implementation/Testable.sol\";\r\n\r\ncontract ProposerV2Test is ProposerV2, Testable {\r\n    constructor(\r\n        IERC20 _token,\r\n        uint256 _bond,\r\n        GovernorV2 _governor,\r\n        Finder _finder,\r\n        address _timerAddress\r\n    ) ProposerV2(_token, _bond, _governor, _finder) Testable(_timerAddress) {}\r\n\r\n    function getCurrentTime() public view override(ProposerV2, Testable) returns (uint256) {\r\n        return Testable.getCurrentTime();\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/PunitiveSlashingLibraryTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../../interfaces/SlashingLibraryInterface.sol\";\r\n\r\ncontract PunitiveSlashingLibraryTest is SlashingLibraryInterface {\r\n    function calcWrongVoteSlashPerToken(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public pure returns (uint256) {\r\n        return 0.99e18;\r\n    }\r\n\r\n    function calcWrongVoteSlashPerTokenGovernance(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public pure returns (uint256) {\r\n        return 0.99e18;\r\n    }\r\n\r\n    function calcNoVoteSlashPerToken(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public pure returns (uint256) {\r\n        return 0.99e18;\r\n    }\r\n\r\n    function calcSlashing(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex,\r\n        bool isGovernance\r\n    ) external pure returns (uint256 wrongVoteSlashPerToken, uint256 noVoteSlashPerToken) {\r\n        return (\r\n            isGovernance\r\n                ? calcWrongVoteSlashPerTokenGovernance(totalStaked, totalVotes, totalCorrectVotes, priceRequestIndex)\r\n                : calcWrongVoteSlashPerToken(totalStaked, totalVotes, totalCorrectVotes, priceRequestIndex),\r\n            calcNoVoteSlashPerToken(totalStaked, totalVotes, totalCorrectVotes, priceRequestIndex)\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/ResultComputationTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../ResultComputation.sol\";\r\nimport \"../../../common/implementation/FixedPoint.sol\";\r\n\r\n// Wraps the library ResultComputation for testing purposes.\r\ncontract ResultComputationTest {\r\n    using ResultComputation for ResultComputation.Data;\r\n\r\n    ResultComputation.Data public data;\r\n\r\n    function wrapAddVote(int256 votePrice, uint256 numberTokens) external {\r\n        data.addVote(votePrice, FixedPoint.Unsigned(numberTokens));\r\n    }\r\n\r\n    function wrapGetResolvedPrice(uint256 minVoteThreshold) external view returns (bool isResolved, int256 price) {\r\n        return data.getResolvedPrice(FixedPoint.Unsigned(minVoteThreshold));\r\n    }\r\n\r\n    function wrapWasVoteCorrect(bytes32 revealHash) external view returns (bool) {\r\n        return data.wasVoteCorrect(revealHash);\r\n    }\r\n\r\n    function wrapGetTotalCorrectlyVotedTokens() external view returns (uint256) {\r\n        return data.getTotalCorrectlyVotedTokens().rawValue;\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/StakerTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../Staker.sol\";\r\nimport \"../../../common/implementation/Testable.sol\";\r\n\r\n// Version of the Staker contract used in tests so time can be controlled.\r\nabstract contract StakerControlledTiming is Staker, Testable {\r\n    constructor(\r\n        uint128 _emissionRate,\r\n        uint64 _unstakeCoolDown,\r\n        address _votingToken,\r\n        address _timerAddress\r\n    ) Staker(_emissionRate, _unstakeCoolDown, _votingToken) Testable(_timerAddress) {}\r\n\r\n    function getCurrentTime() public view virtual override(Staker, Testable) returns (uint256) {\r\n        return Testable.getCurrentTime();\r\n    }\r\n}\r\n\r\ncontract StakerTest is StakerControlledTiming {\r\n    constructor(\r\n        uint128 _emissionRate,\r\n        uint64 _unstakeCoolDown,\r\n        address _votingToken,\r\n        address _timer\r\n    ) StakerControlledTiming(_emissionRate, _unstakeCoolDown, _votingToken, _timer) {}\r\n\r\n    function applySlashingToCumulativeStaked(address voter, int128 amount) public {\r\n        _updateTrackers(voter); // apply any unaccumulated rewards before modifying the staked balances.\r\n        require(int128(cumulativeStake) + amount >= 0, \"Cumulative staked cannot be negative\");\r\n        voterStakes[voter].stake = uint128(int128(voterStakes[voter].stake) + amount);\r\n    }\r\n\r\n    function _inActiveReveal() internal view override returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    function _getStartingIndexForStaker() internal view override returns (uint64) {\r\n        return 0;\r\n    }\r\n\r\n    function _computePendingStakes(address wallet, uint128 amount) internal override {}\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/VoteTimingTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../interfaces/VotingInterface.sol\";\r\nimport \"../VoteTiming.sol\";\r\n\r\n// Wraps the library VoteTiming for testing purposes.\r\ncontract VoteTimingTest {\r\n    using VoteTiming for VoteTiming.Data;\r\n\r\n    VoteTiming.Data public voteTiming;\r\n\r\n    constructor(uint256 phaseLength) {\r\n        wrapInit(phaseLength);\r\n    }\r\n\r\n    function wrapComputeCurrentRoundId(uint256 currentTime) external view returns (uint256) {\r\n        return voteTiming.computeCurrentRoundId(currentTime);\r\n    }\r\n\r\n    function wrapComputeCurrentPhase(uint256 currentTime) external view returns (VotingAncillaryInterface.Phase) {\r\n        return voteTiming.computeCurrentPhase(currentTime);\r\n    }\r\n\r\n    function wrapInit(uint256 phaseLength) public {\r\n        voteTiming.init(phaseLength);\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/VotingTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../Voting.sol\";\r\nimport \"../../../common/implementation/FixedPoint.sol\";\r\n\r\n// Test contract used to access internal variables in the Voting contract.\r\ncontract VotingTest is Voting {\r\n    constructor(\r\n        uint256 _phaseLength,\r\n        FixedPoint.Unsigned memory _gatPercentage,\r\n        FixedPoint.Unsigned memory _inflationRate,\r\n        uint256 _rewardsExpirationTimeout,\r\n        address _votingToken,\r\n        address _finder,\r\n        address _timerAddress\r\n    )\r\n        Voting(\r\n            _phaseLength,\r\n            _gatPercentage,\r\n            _inflationRate,\r\n            _rewardsExpirationTimeout,\r\n            _votingToken,\r\n            _finder,\r\n            _timerAddress\r\n        )\r\n    {}\r\n\r\n    function getPendingPriceRequestsArray() external view returns (bytes32[] memory) {\r\n        return pendingPriceRequests;\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/VotingV2Test.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../VotingV2.sol\";\r\nimport \"../../../common/implementation/Testable.sol\";\r\n\r\n// Test contract used to manage the time for the contract in tests.\r\ncontract VotingV2ControllableTiming is VotingV2, Testable {\r\n    constructor(\r\n        uint128 _emissionRate,\r\n        uint64 _unstakeCoolDown,\r\n        uint64 _phaseLength,\r\n        uint32 _maxRolls,\r\n        uint32 _maxRequestsPerRound,\r\n        uint128 _gat,\r\n        uint64 _spat,\r\n        address _votingToken,\r\n        address _finder,\r\n        address _slashingLibrary,\r\n        address _previousVotingContract,\r\n        address _timerAddress\r\n    )\r\n        VotingV2(\r\n            _emissionRate,\r\n            _unstakeCoolDown,\r\n            _phaseLength,\r\n            _maxRolls,\r\n            _maxRequestsPerRound,\r\n            _gat,\r\n            _spat,\r\n            _votingToken,\r\n            _finder,\r\n            _slashingLibrary,\r\n            _previousVotingContract\r\n        )\r\n        Testable(_timerAddress)\r\n    {}\r\n\r\n    function getCurrentTime() public view override(Staker, Testable) returns (uint256) {\r\n        return Testable.getCurrentTime();\r\n    }\r\n\r\n    function commitVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes32 hash\r\n    ) external virtual {\r\n        commitVote(identifier, time, \"\", hash);\r\n    }\r\n\r\n    function revealVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        int256 salt\r\n    ) external virtual {\r\n        revealVote(identifier, time, price, \"\", salt);\r\n    }\r\n\r\n    function commitAndEmitEncryptedVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes32 hash,\r\n        bytes memory encryptedVote\r\n    ) public {\r\n        commitAndEmitEncryptedVote(identifier, time, \"\", hash, encryptedVote);\r\n    }\r\n\r\n    function getPendingPriceRequestsArray() external view returns (bytes32[] memory) {\r\n        return pendingPriceRequestsIds;\r\n    }\r\n\r\n    function getPriceRequestStatuses(PendingRequest[] memory requests) external view returns (RequestState[] memory) {\r\n        PendingRequestAncillary[] memory requestsAncillary = new PendingRequestAncillary[](requests.length);\r\n\r\n        for (uint256 i = 0; i < requests.length; i = unsafe_inc(i)) {\r\n            requestsAncillary[i].identifier = requests[i].identifier;\r\n            requestsAncillary[i].time = requests[i].time;\r\n            requestsAncillary[i].ancillaryData = \"\";\r\n        }\r\n        return getPriceRequestStatuses(requestsAncillary);\r\n    }\r\n}\r\n\r\n// Test contract used to access internal variables in the Voting contract.\r\ncontract VotingV2Test is VotingV2ControllableTiming {\r\n    constructor(\r\n        uint128 _emissionRate,\r\n        uint64 _unstakeCoolDown,\r\n        uint64 _phaseLength,\r\n        uint32 _maxRolls,\r\n        uint32 _maxRequestsPerRound,\r\n        uint128 _gat,\r\n        uint64 _spat,\r\n        address _votingToken,\r\n        address _finder,\r\n        address _slashingLibrary,\r\n        address _previousVotingContract,\r\n        address _timerAddress\r\n    )\r\n        VotingV2ControllableTiming(\r\n            _emissionRate,\r\n            _unstakeCoolDown,\r\n            _phaseLength,\r\n            _maxRolls,\r\n            _maxRequestsPerRound,\r\n            _gat,\r\n            _spat,\r\n            _votingToken,\r\n            _finder,\r\n            _slashingLibrary,\r\n            _previousVotingContract,\r\n            _timerAddress\r\n        )\r\n    {}\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/test/ZeroedSlashingLibaryTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../../interfaces/SlashingLibraryInterface.sol\";\r\n\r\n/**\r\n * @title Slashing Library contract that executes no slashing for any actions. Used in tests.\r\n */\r\n\r\ncontract ZeroedSlashingSlashingLibraryTest is SlashingLibraryInterface {\r\n    function calcWrongVoteSlashPerToken(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public pure returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function calcWrongVoteSlashPerTokenGovernance(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public pure returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function calcNoVoteSlashPerToken(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) public pure returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function calcSlashing(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex,\r\n        bool isGovernance\r\n    ) external pure returns (uint256 wrongVoteSlashPerToken, uint256 noVoteSlashPerToken) {\r\n        return (\r\n            isGovernance\r\n                ? calcWrongVoteSlashPerTokenGovernance(totalStaked, totalVotes, totalCorrectVotes, priceRequestIndex)\r\n                : calcWrongVoteSlashPerToken(totalStaked, totalVotes, totalCorrectVotes, priceRequestIndex),\r\n            calcNoVoteSlashPerToken(totalStaked, totalVotes, totalCorrectVotes, priceRequestIndex)\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/TokenMigrator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\r\nimport \"./VotingToken.sol\";\r\n\r\n/**\r\n * @title Migration contract for VotingTokens.\r\n * @dev Handles migrating token holders from one token to the next.\r\n */\r\ncontract TokenMigrator {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    /****************************************\r\n     *    INTERNAL VARIABLES AND STORAGE    *\r\n     ****************************************/\r\n\r\n    VotingToken public oldToken;\r\n    ExpandedIERC20 public newToken;\r\n\r\n    uint256 public snapshotId;\r\n    FixedPoint.Unsigned public rate;\r\n\r\n    mapping(address => bool) public hasMigrated;\r\n\r\n    /**\r\n     * @notice Construct the TokenMigrator contract.\r\n     * @dev This function triggers the snapshot upon which all migrations will be based.\r\n     * @param _rate the number of old tokens it takes to generate one new token.\r\n     * @param _oldToken address of the token being migrated from.\r\n     * @param _newToken address of the token being migrated to.\r\n     */\r\n    constructor(\r\n        FixedPoint.Unsigned memory _rate,\r\n        address _oldToken,\r\n        address _newToken\r\n    ) {\r\n        // Prevents division by 0 in migrateTokens().\r\n        // Also it doesnt make sense to have 0 old tokens equate to 1 new token.\r\n        require(_rate.isGreaterThan(0), \"Rate can't be 0\");\r\n        rate = _rate;\r\n        newToken = ExpandedIERC20(_newToken);\r\n        oldToken = VotingToken(_oldToken);\r\n        snapshotId = oldToken.snapshot();\r\n    }\r\n\r\n    /**\r\n     * @notice Migrates the tokenHolder's old tokens to new tokens.\r\n     * @dev This function can only be called once per `tokenHolder`. Anyone can call this method\r\n     * on behalf of any other token holder since there is no disadvantage to receiving the tokens earlier.\r\n     * @param tokenHolder address of the token holder to migrate.\r\n     */\r\n    function migrateTokens(address tokenHolder) external {\r\n        require(!hasMigrated[tokenHolder], \"Already migrated tokens\");\r\n        hasMigrated[tokenHolder] = true;\r\n\r\n        FixedPoint.Unsigned memory oldBalance = FixedPoint.Unsigned(oldToken.balanceOfAt(tokenHolder, snapshotId));\r\n\r\n        if (!oldBalance.isGreaterThan(0)) {\r\n            return;\r\n        }\r\n\r\n        FixedPoint.Unsigned memory newBalance = oldBalance.div(rate);\r\n        require(newToken.mint(tokenHolder, newBalance.rawValue), \"Mint failed\");\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/VoteTiming.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/VotingInterface.sol\";\r\n\r\n/**\r\n * @title Library to compute rounds and phases for an equal length commit-reveal voting cycle.\r\n */\r\nlibrary VoteTiming {\r\n    struct Data {\r\n        uint256 phaseLength;\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes the data object. Sets the phase length based on the input.\r\n     * @param data reference to the this library's data object.\r\n     * @param phaseLength length of voting phase in seconds.\r\n     */\r\n    function init(Data storage data, uint256 phaseLength) internal {\r\n        // This should have a require message but this results in an internal Solidity error.\r\n        require(phaseLength > 0);\r\n        data.phaseLength = phaseLength;\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the roundID based off the current time as floor(timestamp/roundLength).\r\n     * @dev The round ID depends on the global timestamp but not on the lifetime of the system.\r\n     * The consequence is that the initial round ID starts at an arbitrary number (that increments, as expected, for subsequent rounds) instead of zero or one.\r\n     * @param data input data object.\r\n     * @param currentTime input unix timestamp used to compute the current roundId.\r\n     * @return roundId defined as a function of the currentTime and `phaseLength` from `data`.\r\n     */\r\n    function computeCurrentRoundId(Data storage data, uint256 currentTime) internal view returns (uint256) {\r\n        uint256 roundLength = data.phaseLength * uint256(VotingAncillaryInterface.Phase.NUM_PHASES);\r\n        return currentTime / roundLength;\r\n    }\r\n\r\n    /**\r\n     * @notice compute the round end time as a function of the round Id.\r\n     * @param data input data object.\r\n     * @param roundId uniquely identifies the current round.\r\n     * @return timestamp unix time of when the current round will end.\r\n     */\r\n    function computeRoundEndTime(Data storage data, uint256 roundId) internal view returns (uint256) {\r\n        uint256 roundLength = data.phaseLength * uint256(VotingAncillaryInterface.Phase.NUM_PHASES);\r\n        return roundLength * (roundId + 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the current phase based only on the current time.\r\n     * @param data input data object.\r\n     * @param currentTime input unix timestamp used to compute the current roundId.\r\n     * @return current voting phase based on current time and vote phases configuration.\r\n     */\r\n    function computeCurrentPhase(Data storage data, uint256 currentTime)\r\n        internal\r\n        view\r\n        returns (VotingAncillaryInterface.Phase)\r\n    {\r\n        // This employs some hacky casting. We could make this an if-statement if we're worried about type safety.\r\n        return\r\n            VotingAncillaryInterface.Phase(\r\n                (currentTime / data.phaseLength) % uint256(VotingAncillaryInterface.Phase.NUM_PHASES)\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/Voting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../interfaces/FinderInterface.sol\";\r\nimport \"../interfaces/OracleInterface.sol\";\r\nimport \"../interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../interfaces/VotingInterface.sol\";\r\nimport \"../interfaces/VotingAncillaryInterface.sol\";\r\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"./Registry.sol\";\r\nimport \"./ResultComputation.sol\";\r\nimport \"./VoteTiming.sol\";\r\nimport \"./VotingToken.sol\";\r\nimport \"./Constants.sol\";\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\r\n\r\n/**\r\n * @title Voting system for Oracle.\r\n * @dev Handles receiving and resolving price requests via a commit-reveal voting scheme.\r\n */\r\ncontract Voting is\r\n    Testable,\r\n    Ownable,\r\n    OracleInterface,\r\n    OracleAncillaryInterface, // Interface to support ancillary data with price requests.\r\n    VotingInterface,\r\n    VotingAncillaryInterface // Interface to support ancillary data with voting rounds.\r\n{\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SafeMath for uint256;\r\n    using VoteTiming for VoteTiming.Data;\r\n    using ResultComputation for ResultComputation.Data;\r\n\r\n    /****************************************\r\n     *        VOTING DATA STRUCTURES        *\r\n     ****************************************/\r\n\r\n    // Identifies a unique price request for which the Oracle will always return the same value.\r\n    // Tracks ongoing votes as well as the result of the vote.\r\n    struct PriceRequest {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        // A map containing all votes for this price in various rounds.\r\n        mapping(uint256 => VoteInstance) voteInstances;\r\n        // If in the past, this was the voting round where this price was resolved. If current or the upcoming round,\r\n        // this is the voting round where this price will be voted on, but not necessarily resolved.\r\n        uint256 lastVotingRound;\r\n        // The index in the `pendingPriceRequests` that references this PriceRequest. A value of UINT_MAX means that\r\n        // this PriceRequest is resolved and has been cleaned up from `pendingPriceRequests`.\r\n        uint256 index;\r\n        bytes ancillaryData;\r\n    }\r\n\r\n    struct VoteInstance {\r\n        // Maps (voterAddress) to their submission.\r\n        mapping(address => VoteSubmission) voteSubmissions;\r\n        // The data structure containing the computed voting results.\r\n        ResultComputation.Data resultComputation;\r\n    }\r\n\r\n    struct VoteSubmission {\r\n        // A bytes32 of `0` indicates no commit or a commit that was already revealed.\r\n        bytes32 commit;\r\n        // The hash of the value that was revealed.\r\n        // Note: this is only used for computation of rewards.\r\n        bytes32 revealHash;\r\n    }\r\n\r\n    struct Round {\r\n        uint256 snapshotId; // Voting token snapshot ID for this round.  0 if no snapshot has been taken.\r\n        FixedPoint.Unsigned inflationRate; // Inflation rate set for this round.\r\n        FixedPoint.Unsigned gatPercentage; // Gat rate set for this round.\r\n        uint256 rewardsExpirationTime; // Time that rewards for this round can be claimed until.\r\n    }\r\n\r\n    // Represents the status a price request has.\r\n    enum RequestStatus {\r\n        NotRequested, // Was never requested.\r\n        Active, // Is being voted on in the current round.\r\n        Resolved, // Was resolved in a previous round.\r\n        Future // Is scheduled to be voted on in a future round.\r\n    }\r\n\r\n    // Only used as a return value in view methods -- never stored in the contract.\r\n    struct RequestState {\r\n        RequestStatus status;\r\n        uint256 lastVotingRound;\r\n    }\r\n\r\n    /****************************************\r\n     *          INTERNAL TRACKING           *\r\n     ****************************************/\r\n\r\n    // Maps round numbers to the rounds.\r\n    mapping(uint256 => Round) public rounds;\r\n\r\n    // Maps price request IDs to the PriceRequest struct.\r\n    mapping(bytes32 => PriceRequest) private priceRequests;\r\n\r\n    // Price request ids for price requests that haven't yet been marked as resolved.\r\n    // These requests may be for future rounds.\r\n    bytes32[] internal pendingPriceRequests;\r\n\r\n    VoteTiming.Data public voteTiming;\r\n\r\n    // Percentage of the total token supply that must be used in a vote to\r\n    // create a valid price resolution. 1 == 100%.\r\n    FixedPoint.Unsigned public gatPercentage;\r\n\r\n    // Global setting for the rate of inflation per vote. This is the percentage of the snapshotted total supply that\r\n    // should be split among the correct voters.\r\n    // Note: this value is used to set per-round inflation at the beginning of each round. 1 = 100%.\r\n    FixedPoint.Unsigned public inflationRate;\r\n\r\n    // Time in seconds from the end of the round in which a price request is\r\n    // resolved that voters can still claim their rewards.\r\n    uint256 public rewardsExpirationTimeout;\r\n\r\n    // Reference to the voting token.\r\n    VotingToken public votingToken;\r\n\r\n    // Reference to the Finder.\r\n    FinderInterface private finder;\r\n\r\n    // If non-zero, this contract has been migrated to this address. All voters and\r\n    // financial contracts should query the new address only.\r\n    address public migratedAddress;\r\n\r\n    // Max value of an unsigned integer.\r\n    uint256 private constant UINT_MAX = ~uint256(0);\r\n\r\n    // Max length in bytes of ancillary data that can be appended to a price request.\r\n    // As of December 2020, the current Ethereum gas limit is 12.5 million. This requestPrice function's gas primarily\r\n    // comes from computing a Keccak-256 hash in _encodePriceRequest and writing a new PriceRequest to\r\n    // storage. We have empirically determined an ancillary data limit of 8192 bytes that keeps this function\r\n    // well within the gas limit at ~8 million gas. To learn more about the gas limit and EVM opcode costs go here:\r\n    // - https://etherscan.io/chart/gaslimit\r\n    // - https://github.com/djrtwo/evm-opcode-gas-costs\r\n    uint256 public constant ancillaryBytesLimit = 8192;\r\n\r\n    bytes32 public snapshotMessageHash = ECDSA.toEthSignedMessageHash(keccak256(bytes(\"Sign For Snapshot\")));\r\n\r\n    /***************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event VoteCommitted(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData\r\n    );\r\n\r\n    event EncryptedVote(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        bytes encryptedVote\r\n    );\r\n\r\n    event VoteRevealed(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes ancillaryData,\r\n        uint256 numTokens\r\n    );\r\n\r\n    event RewardsRetrieved(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        uint256 numTokens\r\n    );\r\n\r\n    event PriceRequestAdded(uint256 indexed roundId, bytes32 indexed identifier, uint256 time);\r\n\r\n    event PriceResolved(\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes ancillaryData\r\n    );\r\n\r\n    /**\r\n     * @notice Construct the Voting contract.\r\n     * @param _phaseLength length of the commit and reveal phases in seconds.\r\n     * @param _gatPercentage of the total token supply that must be used in a vote to create a valid price resolution.\r\n     * @param _inflationRate percentage inflation per round used to increase token supply of correct voters.\r\n     * @param _rewardsExpirationTimeout timeout, in seconds, within which rewards must be claimed.\r\n     * @param _votingToken address of the UMA token contract used to commit votes.\r\n     * @param _finder keeps track of all contracts within the system based on their interfaceName.\r\n     * @param _timerAddress Contract that stores the current time in a testing environment.\r\n     * Must be set to 0x0 for production environments that use live time.\r\n     */\r\n    constructor(\r\n        uint256 _phaseLength,\r\n        FixedPoint.Unsigned memory _gatPercentage,\r\n        FixedPoint.Unsigned memory _inflationRate,\r\n        uint256 _rewardsExpirationTimeout,\r\n        address _votingToken,\r\n        address _finder,\r\n        address _timerAddress\r\n    ) Testable(_timerAddress) {\r\n        voteTiming.init(_phaseLength);\r\n        require(_gatPercentage.isLessThanOrEqual(1), \"GAT percentage must be <= 100%\");\r\n        gatPercentage = _gatPercentage;\r\n        inflationRate = _inflationRate;\r\n        votingToken = VotingToken(_votingToken);\r\n        finder = FinderInterface(_finder);\r\n        rewardsExpirationTimeout = _rewardsExpirationTimeout;\r\n    }\r\n\r\n    /***************************************\r\n                    MODIFIERS\r\n    ****************************************/\r\n\r\n    modifier onlyRegisteredContract() {\r\n        if (migratedAddress != address(0)) {\r\n            require(msg.sender == migratedAddress, \"Caller must be migrated address\");\r\n        } else {\r\n            Registry registry = Registry(finder.getImplementationAddress(OracleInterfaces.Registry));\r\n            require(registry.isContractRegistered(msg.sender), \"Called must be registered\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotMigrated() {\r\n        require(migratedAddress == address(0), \"Only call this if not migrated\");\r\n        _;\r\n    }\r\n\r\n    /****************************************\r\n     *  PRICE REQUEST AND ACCESS FUNCTIONS  *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\r\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data\r\n     * is limited such that this method abides by the EVM transaction gas limit.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public override onlyRegisteredContract() {\r\n        uint256 blockTime = getCurrentTime();\r\n        require(time <= blockTime, \"Can only request in past\");\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier request\");\r\n        require(ancillaryData.length <= ancillaryBytesLimit, \"Invalid ancillary data\");\r\n\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\r\n        PriceRequest storage priceRequest = priceRequests[priceRequestId];\r\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\r\n\r\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\r\n\r\n        if (requestStatus == RequestStatus.NotRequested) {\r\n            // Price has never been requested.\r\n            // Price requests always go in the next round, so add 1 to the computed current round.\r\n            uint256 nextRoundId = currentRoundId.add(1);\r\n\r\n            PriceRequest storage newPriceRequest = priceRequests[priceRequestId];\r\n            newPriceRequest.identifier = identifier;\r\n            newPriceRequest.time = time;\r\n            newPriceRequest.lastVotingRound = nextRoundId;\r\n            newPriceRequest.index = pendingPriceRequests.length;\r\n            newPriceRequest.ancillaryData = ancillaryData;\r\n\r\n            pendingPriceRequests.push(priceRequestId);\r\n            emit PriceRequestAdded(nextRoundId, identifier, time);\r\n        }\r\n    }\r\n\r\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\r\n    function requestPrice(bytes32 identifier, uint256 time) public override {\r\n        requestPrice(identifier, time, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Whether the price for `identifier` and `time` is available.\r\n     * @dev Time must be in the past and the identifier must be supported.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp of for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return _hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.\r\n     */\r\n    function hasPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override onlyRegisteredContract() returns (bool) {\r\n        (bool _hasPrice, , ) = _getPriceOrError(identifier, time, ancillaryData);\r\n        return _hasPrice;\r\n    }\r\n\r\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\r\n    function hasPrice(bytes32 identifier, uint256 time) public view override returns (bool) {\r\n        return hasPrice(identifier, time, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\r\n     * @dev If the price is not available, the method reverts.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp of for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return int256 representing the resolved price for the given identifier and timestamp.\r\n     */\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override onlyRegisteredContract() returns (int256) {\r\n        (bool _hasPrice, int256 price, string memory message) = _getPriceOrError(identifier, time, ancillaryData);\r\n\r\n        // If the price wasn't available, revert with the provided message.\r\n        require(_hasPrice, message);\r\n        return price;\r\n    }\r\n\r\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\r\n    function getPrice(bytes32 identifier, uint256 time) public view override returns (int256) {\r\n        return getPrice(identifier, time, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the status of a list of price requests, identified by their identifier and time.\r\n     * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.\r\n     * @param requests array of type PendingRequest which includes an identifier and timestamp for each request.\r\n     * @return requestStates a list, in the same order as the input list, giving the status of each of the specified price requests.\r\n     */\r\n    function getPriceRequestStatuses(PendingRequestAncillary[] memory requests)\r\n        public\r\n        view\r\n        returns (RequestState[] memory)\r\n    {\r\n        RequestState[] memory requestStates = new RequestState[](requests.length);\r\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\r\n        for (uint256 i = 0; i < requests.length; i++) {\r\n            PriceRequest storage priceRequest =\r\n                _getPriceRequest(requests[i].identifier, requests[i].time, requests[i].ancillaryData);\r\n\r\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\r\n\r\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\r\n            if (status == RequestStatus.Active) {\r\n                requestStates[i].lastVotingRound = currentRoundId;\r\n            } else {\r\n                requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\r\n            }\r\n            requestStates[i].status = status;\r\n        }\r\n        return requestStates;\r\n    }\r\n\r\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\r\n    function getPriceRequestStatuses(PendingRequest[] memory requests) public view returns (RequestState[] memory) {\r\n        PendingRequestAncillary[] memory requestsAncillary = new PendingRequestAncillary[](requests.length);\r\n\r\n        for (uint256 i = 0; i < requests.length; i++) {\r\n            requestsAncillary[i].identifier = requests[i].identifier;\r\n            requestsAncillary[i].time = requests[i].time;\r\n            requestsAncillary[i].ancillaryData = \"\";\r\n        }\r\n        return getPriceRequestStatuses(requestsAncillary);\r\n    }\r\n\r\n    /****************************************\r\n     *            VOTING FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Commit a vote for a price request for `identifier` at `time`.\r\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\r\n     * Commits can be changed.\r\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the systems expected behavior,\r\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\r\n     * they can determine the vote pre-reveal.\r\n     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\r\n     * @param time unix timestamp of the price being voted on.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\r\n     */\r\n    function commitVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bytes32 hash\r\n    ) public override onlyIfNotMigrated() {\r\n        require(hash != bytes32(0), \"Invalid provided hash\");\r\n        // Current time is required for all vote timing queries.\r\n        uint256 blockTime = getCurrentTime();\r\n        require(\r\n            voteTiming.computeCurrentPhase(blockTime) == VotingAncillaryInterface.Phase.Commit,\r\n            \"Cannot commit in reveal phase\"\r\n        );\r\n\r\n        // At this point, the computed and last updated round ID should be equal.\r\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\r\n\r\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\r\n        require(\r\n            _getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active,\r\n            \"Cannot commit inactive request\"\r\n        );\r\n\r\n        priceRequest.lastVotingRound = currentRoundId;\r\n        VoteInstance storage voteInstance = priceRequest.voteInstances[currentRoundId];\r\n        voteInstance.voteSubmissions[msg.sender].commit = hash;\r\n\r\n        emit VoteCommitted(msg.sender, currentRoundId, identifier, time, ancillaryData);\r\n    }\r\n\r\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\r\n    function commitVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes32 hash\r\n    ) public override onlyIfNotMigrated() {\r\n        commitVote(identifier, time, \"\", hash);\r\n    }\r\n\r\n    /**\r\n     * @notice Snapshot the current round's token balances and lock in the inflation rate and GAT.\r\n     * @dev This function can be called multiple times, but only the first call per round into this function or `revealVote`\r\n     * will create the round snapshot. Any later calls will be a no-op. Will revert unless called during reveal period.\r\n     * @param signature  signature required to prove caller is an EOA to prevent flash loans from being included in the\r\n     * snapshot.\r\n     */\r\n    function snapshotCurrentRound(bytes calldata signature)\r\n        external\r\n        override(VotingInterface, VotingAncillaryInterface)\r\n        onlyIfNotMigrated()\r\n    {\r\n        uint256 blockTime = getCurrentTime();\r\n        require(voteTiming.computeCurrentPhase(blockTime) == Phase.Reveal, \"Only snapshot in reveal phase\");\r\n        // Require public snapshot require signature to ensure caller is an EOA.\r\n        require(ECDSA.recover(snapshotMessageHash, signature) == msg.sender, \"Signature must match sender\");\r\n        uint256 roundId = voteTiming.computeCurrentRoundId(blockTime);\r\n        _freezeRoundVariables(roundId);\r\n    }\r\n\r\n    /**\r\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\r\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\r\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\r\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\r\n     * @param time specifies the unix timestamp of the price being voted on.\r\n     * @param price voted on during the commit phase.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param salt value used to hide the commitment price during the commit phase.\r\n     */\r\n    function revealVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes memory ancillaryData,\r\n        int256 salt\r\n    ) public override onlyIfNotMigrated() {\r\n        require(voteTiming.computeCurrentPhase(getCurrentTime()) == Phase.Reveal, \"Cannot reveal in commit phase\");\r\n        // Note: computing the current round is required to disallow people from revealing an old commit after the round is over.\r\n        uint256 roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\r\n\r\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\r\n        VoteInstance storage voteInstance = priceRequest.voteInstances[roundId];\r\n        VoteSubmission storage voteSubmission = voteInstance.voteSubmissions[msg.sender];\r\n\r\n        // Scoping to get rid of a stack too deep error.\r\n        {\r\n            // 0 hashes are disallowed in the commit phase, so they indicate a different error.\r\n            // Cannot reveal an uncommitted or previously revealed hash\r\n            require(voteSubmission.commit != bytes32(0), \"Invalid hash reveal\");\r\n            require(\r\n                keccak256(abi.encodePacked(price, salt, msg.sender, time, ancillaryData, roundId, identifier)) ==\r\n                    voteSubmission.commit,\r\n                \"Revealed data != commit hash\"\r\n            );\r\n            // To protect against flash loans, we require snapshot be validated as EOA.\r\n            require(rounds[roundId].snapshotId != 0, \"Round has no snapshot\");\r\n        }\r\n\r\n        // Get the frozen snapshotId\r\n        uint256 snapshotId = rounds[roundId].snapshotId;\r\n\r\n        delete voteSubmission.commit;\r\n\r\n        // Get the voter's snapshotted balance. Since balances are returned pre-scaled by 10**18, we can directly\r\n        // initialize the Unsigned value with the returned uint.\r\n        FixedPoint.Unsigned memory balance = FixedPoint.Unsigned(votingToken.balanceOfAt(msg.sender, snapshotId));\r\n\r\n        // Set the voter's submission.\r\n        voteSubmission.revealHash = keccak256(abi.encode(price));\r\n\r\n        // Add vote to the results.\r\n        voteInstance.resultComputation.addVote(price, balance);\r\n\r\n        emit VoteRevealed(msg.sender, roundId, identifier, time, price, ancillaryData, balance.rawValue);\r\n    }\r\n\r\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\r\n    function revealVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        int256 salt\r\n    ) public override {\r\n        revealVote(identifier, time, price, \"\", salt);\r\n    }\r\n\r\n    /**\r\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\r\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\r\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\r\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\r\n     * @param time unix timestamp of for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\r\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\r\n     */\r\n    function commitAndEmitEncryptedVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bytes32 hash,\r\n        bytes memory encryptedVote\r\n    ) public override {\r\n        commitVote(identifier, time, ancillaryData, hash);\r\n\r\n        uint256 roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\r\n        emit EncryptedVote(msg.sender, roundId, identifier, time, ancillaryData, encryptedVote);\r\n    }\r\n\r\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\r\n    function commitAndEmitEncryptedVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes32 hash,\r\n        bytes memory encryptedVote\r\n    ) public override {\r\n        commitVote(identifier, time, \"\", hash);\r\n\r\n        commitAndEmitEncryptedVote(identifier, time, \"\", hash, encryptedVote);\r\n    }\r\n\r\n    /**\r\n     * @notice Submit a batch of commits in a single transaction.\r\n     * @dev Using `encryptedVote` is optional. If included then commitment is emitted in an event.\r\n     * Look at `project-root/common/Constants.js` for the tested maximum number of\r\n     * commitments that can fit in one transaction.\r\n     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\r\n     */\r\n    function batchCommit(CommitmentAncillary[] memory commits) public override {\r\n        for (uint256 i = 0; i < commits.length; i++) {\r\n            if (commits[i].encryptedVote.length == 0) {\r\n                commitVote(commits[i].identifier, commits[i].time, commits[i].ancillaryData, commits[i].hash);\r\n            } else {\r\n                commitAndEmitEncryptedVote(\r\n                    commits[i].identifier,\r\n                    commits[i].time,\r\n                    commits[i].ancillaryData,\r\n                    commits[i].hash,\r\n                    commits[i].encryptedVote\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\r\n    function batchCommit(Commitment[] memory commits) public override {\r\n        CommitmentAncillary[] memory commitsAncillary = new CommitmentAncillary[](commits.length);\r\n\r\n        for (uint256 i = 0; i < commits.length; i++) {\r\n            commitsAncillary[i].identifier = commits[i].identifier;\r\n            commitsAncillary[i].time = commits[i].time;\r\n            commitsAncillary[i].ancillaryData = \"\";\r\n            commitsAncillary[i].hash = commits[i].hash;\r\n            commitsAncillary[i].encryptedVote = commits[i].encryptedVote;\r\n        }\r\n        batchCommit(commitsAncillary);\r\n    }\r\n\r\n    /**\r\n     * @notice Reveal multiple votes in a single transaction.\r\n     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\r\n     * that can fit in one transaction.\r\n     * @dev For more info on reveals, review the comment for `revealVote`.\r\n     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\r\n     */\r\n    function batchReveal(RevealAncillary[] memory reveals) public override {\r\n        for (uint256 i = 0; i < reveals.length; i++) {\r\n            revealVote(\r\n                reveals[i].identifier,\r\n                reveals[i].time,\r\n                reveals[i].price,\r\n                reveals[i].ancillaryData,\r\n                reveals[i].salt\r\n            );\r\n        }\r\n    }\r\n\r\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\r\n    function batchReveal(Reveal[] memory reveals) public override {\r\n        RevealAncillary[] memory revealsAncillary = new RevealAncillary[](reveals.length);\r\n\r\n        for (uint256 i = 0; i < reveals.length; i++) {\r\n            revealsAncillary[i].identifier = reveals[i].identifier;\r\n            revealsAncillary[i].time = reveals[i].time;\r\n            revealsAncillary[i].price = reveals[i].price;\r\n            revealsAncillary[i].ancillaryData = \"\";\r\n            revealsAncillary[i].salt = reveals[i].salt;\r\n        }\r\n        batchReveal(revealsAncillary);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves rewards owed for a set of resolved price requests.\r\n     * @dev Can only retrieve rewards if calling for a valid round and if the call is done within the timeout threshold\r\n     * (not expired). Note that a named return value is used here to avoid a stack to deep error.\r\n     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\r\n     * @param roundId the round from which voting rewards will be retrieved from.\r\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\r\n     * @return totalRewardToIssue total amount of rewards returned to the voter.\r\n     */\r\n    function retrieveRewards(\r\n        address voterAddress,\r\n        uint256 roundId,\r\n        PendingRequestAncillary[] memory toRetrieve\r\n    ) public override returns (FixedPoint.Unsigned memory totalRewardToIssue) {\r\n        if (migratedAddress != address(0)) {\r\n            require(msg.sender == migratedAddress, \"Can only call from migrated\");\r\n        }\r\n        require(roundId < voteTiming.computeCurrentRoundId(getCurrentTime()), \"Invalid roundId\");\r\n\r\n        Round storage round = rounds[roundId];\r\n        bool isExpired = getCurrentTime() > round.rewardsExpirationTime;\r\n        FixedPoint.Unsigned memory snapshotBalance =\r\n            FixedPoint.Unsigned(votingToken.balanceOfAt(voterAddress, round.snapshotId));\r\n\r\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\r\n        FixedPoint.Unsigned memory snapshotTotalSupply =\r\n            FixedPoint.Unsigned(votingToken.totalSupplyAt(round.snapshotId));\r\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\r\n\r\n        // Keep track of the voter's accumulated token reward.\r\n        totalRewardToIssue = FixedPoint.Unsigned(0);\r\n\r\n        for (uint256 i = 0; i < toRetrieve.length; i++) {\r\n            PriceRequest storage priceRequest =\r\n                _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time, toRetrieve[i].ancillaryData);\r\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\r\n            // Only retrieve rewards for votes resolved in same round\r\n            require(priceRequest.lastVotingRound == roundId, \"Retrieve for votes same round\");\r\n\r\n            _resolvePriceRequest(priceRequest, voteInstance);\r\n\r\n            if (voteInstance.voteSubmissions[voterAddress].revealHash == 0) {\r\n                continue;\r\n            } else if (isExpired) {\r\n                // Emit a 0 token retrieval on expired rewards.\r\n                emit RewardsRetrieved(\r\n                    voterAddress,\r\n                    roundId,\r\n                    toRetrieve[i].identifier,\r\n                    toRetrieve[i].time,\r\n                    toRetrieve[i].ancillaryData,\r\n                    0\r\n                );\r\n            } else if (\r\n                voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)\r\n            ) {\r\n                // The price was successfully resolved during the voter's last voting round, the voter revealed\r\n                // and was correct, so they are eligible for a reward.\r\n                // Compute the reward and add to the cumulative reward.\r\n\r\n                FixedPoint.Unsigned memory reward =\r\n                    snapshotBalance.mul(totalRewardPerVote).div(\r\n                        voteInstance.resultComputation.getTotalCorrectlyVotedTokens()\r\n                    );\r\n                totalRewardToIssue = totalRewardToIssue.add(reward);\r\n\r\n                // Emit reward retrieval for this vote.\r\n                emit RewardsRetrieved(\r\n                    voterAddress,\r\n                    roundId,\r\n                    toRetrieve[i].identifier,\r\n                    toRetrieve[i].time,\r\n                    toRetrieve[i].ancillaryData,\r\n                    reward.rawValue\r\n                );\r\n            } else {\r\n                // Emit a 0 token retrieval on incorrect votes.\r\n                emit RewardsRetrieved(\r\n                    voterAddress,\r\n                    roundId,\r\n                    toRetrieve[i].identifier,\r\n                    toRetrieve[i].time,\r\n                    toRetrieve[i].ancillaryData,\r\n                    0\r\n                );\r\n            }\r\n\r\n            // Delete the submission to capture any refund and clean up storage.\r\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\r\n        }\r\n\r\n        // Issue any accumulated rewards.\r\n        if (totalRewardToIssue.isGreaterThan(0)) {\r\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue), \"Voting token issuance failed\");\r\n        }\r\n    }\r\n\r\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\r\n    function retrieveRewards(\r\n        address voterAddress,\r\n        uint256 roundId,\r\n        PendingRequest[] memory toRetrieve\r\n    ) public override returns (FixedPoint.Unsigned memory) {\r\n        PendingRequestAncillary[] memory toRetrieveAncillary = new PendingRequestAncillary[](toRetrieve.length);\r\n\r\n        for (uint256 i = 0; i < toRetrieve.length; i++) {\r\n            toRetrieveAncillary[i].identifier = toRetrieve[i].identifier;\r\n            toRetrieveAncillary[i].time = toRetrieve[i].time;\r\n            toRetrieveAncillary[i].ancillaryData = \"\";\r\n        }\r\n\r\n        return retrieveRewards(voterAddress, roundId, toRetrieveAncillary);\r\n    }\r\n\r\n    /****************************************\r\n     *        VOTING GETTER FUNCTIONS       *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Gets the queries that are being voted on this round.\r\n     * @return pendingRequests array containing identifiers of type `PendingRequest`.\r\n     * and timestamps for all pending requests.\r\n     */\r\n    function getPendingRequests()\r\n        external\r\n        view\r\n        override(VotingInterface, VotingAncillaryInterface)\r\n        returns (PendingRequestAncillary[] memory)\r\n    {\r\n        uint256 blockTime = getCurrentTime();\r\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\r\n\r\n        // Solidity memory arrays aren't resizable (and reading storage is expensive). Hence this hackery to filter\r\n        // `pendingPriceRequests` only to those requests that have an Active RequestStatus.\r\n        PendingRequestAncillary[] memory unresolved = new PendingRequestAncillary[](pendingPriceRequests.length);\r\n        uint256 numUnresolved = 0;\r\n\r\n        for (uint256 i = 0; i < pendingPriceRequests.length; i++) {\r\n            PriceRequest storage priceRequest = priceRequests[pendingPriceRequests[i]];\r\n            if (_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active) {\r\n                unresolved[numUnresolved] = PendingRequestAncillary({\r\n                    identifier: priceRequest.identifier,\r\n                    time: priceRequest.time,\r\n                    ancillaryData: priceRequest.ancillaryData\r\n                });\r\n                numUnresolved++;\r\n            }\r\n        }\r\n\r\n        PendingRequestAncillary[] memory pendingRequests = new PendingRequestAncillary[](numUnresolved);\r\n        for (uint256 i = 0; i < numUnresolved; i++) {\r\n            pendingRequests[i] = unresolved[i];\r\n        }\r\n        return pendingRequests;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current voting phase, as a function of the current time.\r\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES_PLACEHOLDER }.\r\n     */\r\n    function getVotePhase() external view override(VotingInterface, VotingAncillaryInterface) returns (Phase) {\r\n        return voteTiming.computeCurrentPhase(getCurrentTime());\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current round ID, as a function of the current time.\r\n     * @return uint256 representing the unique round ID.\r\n     */\r\n    function getCurrentRoundId() external view override(VotingInterface, VotingAncillaryInterface) returns (uint256) {\r\n        return voteTiming.computeCurrentRoundId(getCurrentTime());\r\n    }\r\n\r\n    /****************************************\r\n     *        OWNER ADMIN FUNCTIONS         *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Disables this Voting contract in favor of the migrated one.\r\n     * @dev Can only be called by the contract owner.\r\n     * @param newVotingAddress the newly migrated contract address.\r\n     */\r\n    function setMigrated(address newVotingAddress)\r\n        external\r\n        override(VotingInterface, VotingAncillaryInterface)\r\n        onlyOwner\r\n    {\r\n        migratedAddress = newVotingAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\r\n     * @dev This method is public because calldata structs are not currently supported by solidity.\r\n     * @param newInflationRate sets the next round's inflation rate.\r\n     */\r\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate)\r\n        public\r\n        override(VotingInterface, VotingAncillaryInterface)\r\n        onlyOwner\r\n    {\r\n        inflationRate = newInflationRate;\r\n    }\r\n\r\n    /**\r\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\r\n     * @dev This method is public because calldata structs are not currently supported by solidity.\r\n     * @param newGatPercentage sets the next round's Gat percentage.\r\n     */\r\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage)\r\n        public\r\n        override(VotingInterface, VotingAncillaryInterface)\r\n        onlyOwner\r\n    {\r\n        require(newGatPercentage.isLessThan(1), \"GAT percentage must be < 100%\");\r\n        gatPercentage = newGatPercentage;\r\n    }\r\n\r\n    /**\r\n     * @notice Resets the rewards expiration timeout.\r\n     * @dev This change only applies to rounds that have not yet begun.\r\n     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\r\n     */\r\n    function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout)\r\n        public\r\n        override(VotingInterface, VotingAncillaryInterface)\r\n        onlyOwner\r\n    {\r\n        rewardsExpirationTimeout = NewRewardsExpirationTimeout;\r\n    }\r\n\r\n    /****************************************\r\n     *    PRIVATE AND INTERNAL FUNCTIONS    *\r\n     ****************************************/\r\n\r\n    // Returns the price for a given identifer. Three params are returns: bool if there was an error, int to represent\r\n    // the resolved price and a string which is filled with an error message, if there was an error or \"\".\r\n    function _getPriceOrError(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    )\r\n        private\r\n        view\r\n        returns (\r\n            bool,\r\n            int256,\r\n            string memory\r\n        )\r\n    {\r\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\r\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\r\n\r\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\r\n        if (requestStatus == RequestStatus.Active) {\r\n            return (false, 0, \"Current voting round not ended\");\r\n        } else if (requestStatus == RequestStatus.Resolved) {\r\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\r\n            (, int256 resolvedPrice) =\r\n                voteInstance.resultComputation.getResolvedPrice(_computeGat(priceRequest.lastVotingRound));\r\n            return (true, resolvedPrice, \"\");\r\n        } else if (requestStatus == RequestStatus.Future) {\r\n            return (false, 0, \"Price is still to be voted on\");\r\n        } else {\r\n            return (false, 0, \"Price was never requested\");\r\n        }\r\n    }\r\n\r\n    function _getPriceRequest(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) private view returns (PriceRequest storage) {\r\n        return priceRequests[_encodePriceRequest(identifier, time, ancillaryData)];\r\n    }\r\n\r\n    function _encodePriceRequest(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) private pure returns (bytes32) {\r\n        return keccak256(abi.encode(identifier, time, ancillaryData));\r\n    }\r\n\r\n    function _freezeRoundVariables(uint256 roundId) private {\r\n        Round storage round = rounds[roundId];\r\n        // Only on the first reveal should the snapshot be captured for that round.\r\n        if (round.snapshotId == 0) {\r\n            // There is no snapshot ID set, so create one.\r\n            round.snapshotId = votingToken.snapshot();\r\n\r\n            // Set the round inflation rate to the current global inflation rate.\r\n            rounds[roundId].inflationRate = inflationRate;\r\n\r\n            // Set the round gat percentage to the current global gat rate.\r\n            rounds[roundId].gatPercentage = gatPercentage;\r\n\r\n            // Set the rewards expiration time based on end of time of this round and the current global timeout.\r\n            rounds[roundId].rewardsExpirationTime = voteTiming.computeRoundEndTime(roundId).add(\r\n                rewardsExpirationTimeout\r\n            );\r\n        }\r\n    }\r\n\r\n    function _resolvePriceRequest(PriceRequest storage priceRequest, VoteInstance storage voteInstance) private {\r\n        if (priceRequest.index == UINT_MAX) {\r\n            return;\r\n        }\r\n        (bool isResolved, int256 resolvedPrice) =\r\n            voteInstance.resultComputation.getResolvedPrice(_computeGat(priceRequest.lastVotingRound));\r\n        require(isResolved, \"Can't resolve unresolved request\");\r\n\r\n        // Delete the resolved price request from pendingPriceRequests.\r\n        uint256 lastIndex = pendingPriceRequests.length - 1;\r\n        PriceRequest storage lastPriceRequest = priceRequests[pendingPriceRequests[lastIndex]];\r\n        lastPriceRequest.index = priceRequest.index;\r\n        pendingPriceRequests[priceRequest.index] = pendingPriceRequests[lastIndex];\r\n        pendingPriceRequests.pop();\r\n\r\n        priceRequest.index = UINT_MAX;\r\n        emit PriceResolved(\r\n            priceRequest.lastVotingRound,\r\n            priceRequest.identifier,\r\n            priceRequest.time,\r\n            resolvedPrice,\r\n            priceRequest.ancillaryData\r\n        );\r\n    }\r\n\r\n    function _computeGat(uint256 roundId) private view returns (FixedPoint.Unsigned memory) {\r\n        uint256 snapshotId = rounds[roundId].snapshotId;\r\n        if (snapshotId == 0) {\r\n            // No snapshot - return max value to err on the side of caution.\r\n            return FixedPoint.Unsigned(UINT_MAX);\r\n        }\r\n\r\n        // Grab the snapshotted supply from the voting token. It's already scaled by 10**18, so we can directly\r\n        // initialize the Unsigned value with the returned uint.\r\n        FixedPoint.Unsigned memory snapshottedSupply = FixedPoint.Unsigned(votingToken.totalSupplyAt(snapshotId));\r\n\r\n        // Multiply the total supply at the snapshot by the gatPercentage to get the GAT in number of tokens.\r\n        return snapshottedSupply.mul(rounds[roundId].gatPercentage);\r\n    }\r\n\r\n    function _getRequestStatus(PriceRequest storage priceRequest, uint256 currentRoundId)\r\n        private\r\n        view\r\n        returns (RequestStatus)\r\n    {\r\n        if (priceRequest.lastVotingRound == 0) {\r\n            return RequestStatus.NotRequested;\r\n        } else if (priceRequest.lastVotingRound < currentRoundId) {\r\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\r\n            (bool isResolved, ) =\r\n                voteInstance.resultComputation.getResolvedPrice(_computeGat(priceRequest.lastVotingRound));\r\n            return isResolved ? RequestStatus.Resolved : RequestStatus.Active;\r\n        } else if (priceRequest.lastVotingRound == currentRoundId) {\r\n            return RequestStatus.Active;\r\n        } else {\r\n            // Means than priceRequest.lastVotingRound > currentRoundId\r\n            return RequestStatus.Future;\r\n        }\r\n    }\r\n\r\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface supportedIdentifiers) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/VotingToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/ExpandedERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\r\n\r\n/**\r\n * @title Ownership of this token allows a voter to respond to price requests.\r\n * @dev Supports snapshotting and allows the Oracle to mint new tokens as rewards.\r\n */\r\ncontract VotingToken is ExpandedERC20, ERC20Snapshot {\r\n    /**\r\n     * @notice Constructs the VotingToken.\r\n     */\r\n    constructor() ExpandedERC20(\"UMA Voting Token v1\", \"UMA\", 18) ERC20Snapshot() {}\r\n\r\n    function decimals() public view virtual override(ERC20, ExpandedERC20) returns (uint8) {\r\n        return super.decimals();\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new snapshot ID.\r\n     * @return uint256 Thew new snapshot ID.\r\n     */\r\n    function snapshot() external returns (uint256) {\r\n        return _snapshot();\r\n    }\r\n\r\n    // _transfer, _mint and _burn are ERC20 internal methods that are overridden by ERC20Snapshot,\r\n    // therefore the compiler will complain that VotingToken must override these methods\r\n    // because the two base classes (ERC20 and ERC20Snapshot) both define the same functions\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal override(ERC20) {\r\n        super._transfer(from, to, value);\r\n    }\r\n\r\n    function _mint(address account, uint256 value) internal virtual override(ERC20) {\r\n        super._mint(account, value);\r\n    }\r\n\r\n    function _burn(address account, uint256 value) internal virtual override(ERC20) {\r\n        super._burn(account, value);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual override(ERC20, ERC20Snapshot) {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/implementation/VotingV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\n\r\nimport \"./ResultComputationV2.sol\";\r\nimport \"./Staker.sol\";\r\nimport \"./VoteTiming.sol\";\r\nimport \"./Constants.sol\";\r\n\r\nimport \"../interfaces/MinimumVotingAncillaryInterface.sol\";\r\nimport \"../interfaces/FinderInterface.sol\";\r\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../interfaces/OracleGovernanceInterface.sol\";\r\nimport \"../interfaces/OracleInterface.sol\";\r\nimport \"../interfaces/VotingV2Interface.sol\";\r\nimport \"../interfaces/RegistryInterface.sol\";\r\nimport \"../interfaces/SlashingLibraryInterface.sol\";\r\n\r\n/**\r\n * @title VotingV2 contract for the UMA DVM.\r\n * @dev Handles receiving and resolving price requests via a commit-reveal voting schelling scheme.\r\n */\r\n\r\ncontract VotingV2 is Staker, OracleInterface, OracleAncillaryInterface, OracleGovernanceInterface, VotingV2Interface {\r\n    using VoteTiming for VoteTiming.Data;\r\n    using ResultComputationV2 for ResultComputationV2.Data;\r\n\r\n    /****************************************\r\n     *        VOTING DATA STRUCTURES        *\r\n     ****************************************/\r\n\r\n    // Identifies a unique price request. Tracks ongoing votes as well as the result of the vote.\r\n    struct PriceRequest {\r\n        uint32 lastVotingRound; // Last round that this price request was voted on. Updated when a request is rolled.\r\n        bool isGovernance; // Denotes whether this is a governance request or not.\r\n        uint64 time; // Timestamp used when evaluating the request.\r\n        uint32 rollCount; // The number of rounds that a price request has rolled. Informs if a request can be deleted.\r\n        bytes32 identifier; // Identifier that defines how the voters should resolve the request.\r\n        mapping(uint32 => VoteInstance) voteInstances; // A map containing all votes for this price in various rounds.\r\n        bytes ancillaryData; // Additional data used to resolve the request.\r\n    }\r\n\r\n    struct VoteInstance {\r\n        mapping(address => VoteSubmission) voteSubmissions; // Maps (voter) to their submission.\r\n        ResultComputationV2.Data results; // The data structure containing the computed voting results.\r\n    }\r\n\r\n    struct VoteSubmission {\r\n        bytes32 commit; // A bytes32 of 0 indicates no commit or a commit that was already revealed.\r\n        bytes32 revealHash; // The hash of the value that was revealed. This is only used for computation of rewards.\r\n    }\r\n\r\n    struct Round {\r\n        SlashingLibraryInterface slashingLibrary; // Slashing library used to compute voter participation slash at this round.\r\n        uint128 minParticipationRequirement; // Minimum staked tokens that must vote to resolve a request.\r\n        uint128 minAgreementRequirement; // Minimum staked tokens that must agree on an outcome to resolve a request.\r\n        uint128 cumulativeStakeAtRound; // Total staked tokens at the start of the round.\r\n        uint32 numberOfRequestsToVote; // The number of requests to vote in this round.\r\n    }\r\n\r\n    struct SlashingTracker {\r\n        uint256 wrongVoteSlashPerToken; // The amount of tokens slashed per token staked for a wrong vote.\r\n        uint256 noVoteSlashPerToken; // The amount of tokens slashed per token staked for a no vote.\r\n        uint256 totalSlashed; // The total amount of tokens slashed for a given request.\r\n        uint256 totalCorrectVotes; // The total number of correct votes for a given request.\r\n        uint32 lastVotingRound; // The last round that this request was voted on (when it resolved).\r\n    }\r\n\r\n    enum VoteParticipation {\r\n        DidNotVote, // Voter did not vote.\r\n        WrongVote, // Voter voted against the resolved price.\r\n        CorrectVote // Voter voted with the resolved price.\r\n    }\r\n\r\n    // Represents the status a price request has.\r\n    enum RequestStatus {\r\n        NotRequested, // Was never requested.\r\n        Active, // Is being voted on in the current round.\r\n        Resolved, // Was resolved in a previous round.\r\n        Future, // Is scheduled to be voted on in a future round.\r\n        ToDelete // Is scheduled to be deleted.\r\n    }\r\n\r\n    // Only used as a return value in view methods -- never stored in the contract.\r\n    struct RequestState {\r\n        RequestStatus status;\r\n        uint32 lastVotingRound;\r\n    }\r\n\r\n    /****************************************\r\n     *            VOTING STATE              *\r\n     ****************************************/\r\n\r\n    uint32 public lastRoundIdProcessed; // The last round pendingPriceRequestsIds were traversed in.\r\n\r\n    uint64 public nextPendingIndexToProcess; // Next pendingPriceRequestsIds index to process in lastRoundIdProcessed.\r\n\r\n    FinderInterface public immutable finder; // Reference to the UMA Finder contract, used to find other UMA contracts.\r\n\r\n    SlashingLibraryInterface public slashingLibrary; // Reference to Slashing Library, used to compute slashing amounts.\r\n\r\n    VoteTiming.Data public voteTiming; // Vote timing library used to compute round timing related logic.\r\n\r\n    OracleAncillaryInterface public immutable previousVotingContract; // Previous voting contract, if migrated.\r\n\r\n    mapping(uint256 => Round) public rounds; // Maps round numbers to the rounds.\r\n\r\n    mapping(bytes32 => PriceRequest) public priceRequests; // Maps price request IDs to the PriceRequest struct.\r\n\r\n    bytes32[] public resolvedPriceRequestIds; // Array of resolved price requestIds. Used to track resolved requests.\r\n\r\n    bytes32[] public pendingPriceRequestsIds; // Array of pending price requestIds. Can be resolved in the future.\r\n\r\n    uint32 public maxRolls; // The maximum number of times a request can roll before it is deleted automatically.\r\n\r\n    uint32 public maxRequestsPerRound; // The maximum number of requests that can be enqueued in a single round.\r\n\r\n    address public migratedAddress; // If non-zero, this contract has been migrated to this address.\r\n\r\n    uint128 public gat; // GAT: A minimum number of tokens that must participate to resolve a vote.\r\n\r\n    uint64 public spat; // SPAT: Minimum percentage of staked tokens that must agree on the answer to resolve a vote.\r\n\r\n    uint64 public constant UINT64_MAX = type(uint64).max; // Max value of an unsigned integer.\r\n\r\n    uint256 public constant ANCILLARY_BYTES_LIMIT = 8192; // Max length in bytes of ancillary data.\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event VoteCommitted(\r\n        address indexed voter,\r\n        address indexed caller,\r\n        uint32 roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData\r\n    );\r\n\r\n    event EncryptedVote(\r\n        address indexed caller,\r\n        uint32 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        bytes encryptedVote\r\n    );\r\n\r\n    event VoteRevealed(\r\n        address indexed voter,\r\n        address indexed caller,\r\n        uint32 roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        int256 price,\r\n        uint128 numTokens\r\n    );\r\n\r\n    event RequestAdded(\r\n        address indexed requester,\r\n        uint32 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        bool isGovernance\r\n    );\r\n\r\n    event RequestResolved(\r\n        uint32 indexed roundId,\r\n        uint256 indexed resolvedPriceRequestIndex,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        int256 price\r\n    );\r\n\r\n    event VotingContractMigrated(address newAddress);\r\n\r\n    event RequestDeleted(bytes32 indexed identifier, uint256 indexed time, bytes ancillaryData, uint32 rollCount);\r\n\r\n    event RequestRolled(bytes32 indexed identifier, uint256 indexed time, bytes ancillaryData, uint32 rollCount);\r\n\r\n    event GatAndSpatChanged(uint128 newGat, uint64 newSpat);\r\n\r\n    event SlashingLibraryChanged(address newAddress);\r\n\r\n    event MaxRollsChanged(uint32 newMaxRolls);\r\n\r\n    event MaxRequestsPerRoundChanged(uint32 newMaxRequestsPerRound);\r\n\r\n    event VoterSlashApplied(address indexed voter, int128 slashedTokens, uint128 postStake);\r\n\r\n    event VoterSlashed(address indexed voter, uint256 indexed requestIndex, int128 slashedTokens);\r\n\r\n    /**\r\n     * @notice Construct the VotingV2 contract.\r\n     * @param _emissionRate amount of voting tokens that are emitted per second, split prorate between stakers.\r\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\r\n     * @param _phaseLength length of the voting phases in seconds.\r\n     * @param _maxRolls number of times a vote must roll to be auto deleted by the DVM.\r\n     * @param _maxRequestsPerRound maximum number of requests that can be enqueued in a single round.\r\n     * @param _gat number of tokens that must participate to resolve a vote.\r\n     * @param _spat percentage of staked tokens that must agree on the result to resolve a vote.\r\n     * @param _votingToken address of the UMA token contract used to commit votes.\r\n     * @param _finder keeps track of all contracts within the system based on their interfaceName.\r\n     * @param _slashingLibrary contract used to calculate voting slashing penalties based on voter participation.\r\n     * @param _previousVotingContract previous voting contract address.\r\n     */\r\n    constructor(\r\n        uint128 _emissionRate,\r\n        uint64 _unstakeCoolDown,\r\n        uint64 _phaseLength,\r\n        uint32 _maxRolls,\r\n        uint32 _maxRequestsPerRound,\r\n        uint128 _gat,\r\n        uint64 _spat,\r\n        address _votingToken,\r\n        address _finder,\r\n        address _slashingLibrary,\r\n        address _previousVotingContract\r\n    ) Staker(_emissionRate, _unstakeCoolDown, _votingToken) {\r\n        voteTiming.init(_phaseLength);\r\n        finder = FinderInterface(_finder);\r\n        previousVotingContract = OracleAncillaryInterface(_previousVotingContract);\r\n        setGatAndSpat(_gat, _spat);\r\n        setSlashingLibrary(_slashingLibrary);\r\n        setMaxRequestPerRound(_maxRequestsPerRound);\r\n        setMaxRolls(_maxRolls);\r\n    }\r\n\r\n    /***************************************\r\n                    MODIFIERS\r\n    ****************************************/\r\n\r\n    modifier onlyRegisteredContract() {\r\n        _requireRegisteredContract();\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotMigrated() {\r\n        _requireNotMigrated();\r\n        _;\r\n    }\r\n\r\n    /****************************************\r\n     *  PRICE REQUEST AND ACCESS FUNCTIONS  *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the identifier, time and ancillary data.\r\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data is limited.\r\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public override nonReentrant onlyIfNotMigrated onlyRegisteredContract {\r\n        _requestPrice(identifier, time, ancillaryData, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Enqueues a governance action request (if not already present) for identifier, time and ancillary data.\r\n     * @dev Only the owner of the Voting contract can call this. In normal operation this is the Governor contract.\r\n     * @param identifier uniquely identifies the price requested. E.g. Admin 0 (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     */\r\n    function requestGovernanceAction(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) external override onlyOwner onlyIfNotMigrated {\r\n        _requestPrice(identifier, time, ancillaryData, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the identifier, time pair.\r\n     * @dev Overloaded method to enable short term backwards compatibility when ancillary data is not included.\r\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     */\r\n    function requestPrice(bytes32 identifier, uint256 time) external override {\r\n        requestPrice(identifier, time, \"\");\r\n    }\r\n\r\n    // Enqueues a request (if a request isn't already present) for the given identifier, time and ancillary data.\r\n    function _requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bool isGovernance\r\n    ) internal {\r\n        require(time <= getCurrentTime(), \"Can only request in past\");\r\n        require(isGovernance || _getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\r\n        require(ancillaryData.length <= ANCILLARY_BYTES_LIMIT, \"Invalid ancillary data\");\r\n\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\r\n        PriceRequest storage priceRequest = priceRequests[priceRequestId];\r\n\r\n        // Price has never been requested.\r\n        uint32 currentRoundId = getCurrentRoundId();\r\n        if (_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.NotRequested) {\r\n            uint32 roundIdToVoteOn = getRoundIdToVoteOnRequest(currentRoundId + 1);\r\n            ++rounds[roundIdToVoteOn].numberOfRequestsToVote;\r\n            priceRequest.identifier = identifier;\r\n            priceRequest.time = uint64(time);\r\n            priceRequest.ancillaryData = ancillaryData;\r\n            priceRequest.lastVotingRound = roundIdToVoteOn;\r\n            if (isGovernance) priceRequest.isGovernance = isGovernance;\r\n\r\n            pendingPriceRequestsIds.push(priceRequestId);\r\n            emit RequestAdded(msg.sender, roundIdToVoteOn, identifier, time, ancillaryData, isGovernance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the round ID that a request should be voted on.\r\n     * @param targetRoundId round ID to start searching for a round to vote on.\r\n     * @return uint32 round ID that a request should be voted on.\r\n     */\r\n    function getRoundIdToVoteOnRequest(uint32 targetRoundId) public view returns (uint32) {\r\n        while (rounds[targetRoundId].numberOfRequestsToVote >= maxRequestsPerRound) ++targetRoundId;\r\n        return targetRoundId;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the price for identifier, time and ancillary data is available.\r\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp of the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return bool if the DVM has resolved to a price for the given identifier, timestamp and ancillary data.\r\n     */\r\n    function hasPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override onlyRegisteredContract returns (bool) {\r\n        (bool _hasPrice, , ) = _getPriceOrError(identifier, time, ancillaryData);\r\n        return _hasPrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether the price for identifier and time is available.\r\n     * @dev Overloaded method to enable short term backwards compatibility when ancillary data is not included.\r\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp of the price request.\r\n     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\r\n     */\r\n    function hasPrice(bytes32 identifier, uint256 time) external view override returns (bool) {\r\n        return hasPrice(identifier, time, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the price for identifier, time and ancillary data if it has already been requested and resolved.\r\n     * @dev If the price is not available, the method reverts.\r\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp of the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return int256 representing the resolved price for the given identifier, timestamp and ancillary data.\r\n     */\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override onlyRegisteredContract returns (int256) {\r\n        (bool _hasPrice, int256 price, string memory message) = _getPriceOrError(identifier, time, ancillaryData);\r\n\r\n        // If the price wasn't available, revert with the provided message.\r\n        require(_hasPrice, message);\r\n        return price;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the price for identifier and time if it has already been requested and resolved.\r\n     * @dev Overloaded method to enable short term backwards compatibility when ancillary data is not included.\r\n     * @dev If the price is not available, the method reverts.\r\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp of the price request.\r\n     * @return int256 representing the resolved price for the given identifier and timestamp.\r\n     */\r\n    function getPrice(bytes32 identifier, uint256 time) external view override returns (int256) {\r\n        return getPrice(identifier, time, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the status of a list of price requests, identified by their identifier, time and ancillary data.\r\n     * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.\r\n     * @param requests array of pending requests which includes identifier, timestamp & ancillary data for the requests.\r\n     * @return requestStates a list, in the same order as the input list, giving the status of the specified requests.\r\n     */\r\n    function getPriceRequestStatuses(PendingRequestAncillary[] memory requests)\r\n        public\r\n        view\r\n        returns (RequestState[] memory)\r\n    {\r\n        RequestState[] memory requestStates = new RequestState[](requests.length);\r\n        uint32 currentRoundId = getCurrentRoundId();\r\n        for (uint256 i = 0; i < requests.length; i = unsafe_inc(i)) {\r\n            PriceRequest storage priceRequest =\r\n                _getPriceRequest(requests[i].identifier, requests[i].time, requests[i].ancillaryData);\r\n\r\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\r\n\r\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\r\n            if (status == RequestStatus.Active) requestStates[i].lastVotingRound = currentRoundId;\r\n            else requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\r\n            requestStates[i].status = status;\r\n        }\r\n        return requestStates;\r\n    }\r\n\r\n    /****************************************\r\n     *          VOTING FUNCTIONS            *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Commit a vote for a price request for identifier at time.\r\n     * @dev identifier, time must correspond to a price request that's currently in the commit phase.\r\n     * Commits can be changed.\r\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the systems\r\n     * expected behavior, voters should never reuse salts. If someone else is able to guess the voted price and knows\r\n     * that a salt will be reused, then they can determine the vote pre-reveal.\r\n     * @param identifier uniquely identifies the committed vote. E.g. BTC/USD price pair.\r\n     * @param time unix timestamp of the price being voted on.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param hash keccak256 hash of the price, salt, voter address, time, ancillaryData, current roundId, identifier.\r\n     */\r\n    function commitVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bytes32 hash\r\n    ) public override nonReentrant {\r\n        uint32 currentRoundId = getCurrentRoundId();\r\n        address voter = getVoterFromDelegate(msg.sender);\r\n        _updateTrackers(voter);\r\n\r\n        require(hash != bytes32(0), \"Invalid commit hash\");\r\n        require(getVotePhase() == Phase.Commit, \"Cannot commit in reveal phase\");\r\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\r\n        require(_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active, \"Request must be active\");\r\n\r\n        priceRequest.voteInstances[currentRoundId].voteSubmissions[voter].commit = hash;\r\n\r\n        emit VoteCommitted(voter, msg.sender, currentRoundId, identifier, time, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Reveal a previously committed vote for identifier at time.\r\n     * @dev The revealed price, salt, voter address, time, ancillaryData, current roundId, identifier must hash to the\r\n     * latest hash that commitVote() was called with. Only the committer can reveal their vote.\r\n     * @param identifier voted on in the commit phase. E.g. BTC/USD price pair.\r\n     * @param time specifies the unix timestamp of the price being voted on.\r\n     * @param price voted on during the commit phase.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param salt value used to hide the commitment price during the commit phase.\r\n     */\r\n    function revealVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes memory ancillaryData,\r\n        int256 salt\r\n    ) public override nonReentrant {\r\n        uint32 currentRoundId = getCurrentRoundId();\r\n        _freezeRoundVariables(currentRoundId);\r\n        VoteInstance storage voteInstance =\r\n            _getPriceRequest(identifier, time, ancillaryData).voteInstances[currentRoundId];\r\n        address voter = getVoterFromDelegate(msg.sender);\r\n        VoteSubmission storage voteSubmission = voteInstance.voteSubmissions[voter];\r\n\r\n        require(getVotePhase() == Phase.Reveal, \"Reveal phase has not started yet\"); // Can only reveal in reveal phase.\r\n\r\n        // Zero hashes are blocked in commit; they indicate a different error: voter did not commit or already revealed.\r\n        require(voteSubmission.commit != bytes32(0), \"Invalid hash reveal\");\r\n\r\n        // Check that the hash that was committed matches to the one that was revealed. Note that if the voter had\r\n        // then they must reveal with the same account they had committed with.\r\n        require(\r\n            keccak256(abi.encodePacked(price, salt, voter, time, ancillaryData, uint256(currentRoundId), identifier)) ==\r\n                voteSubmission.commit,\r\n            \"Revealed data != commit hash\"\r\n        );\r\n\r\n        delete voteSubmission.commit; // Small gas refund for clearing up storage.\r\n        voteSubmission.revealHash = keccak256(abi.encode(price)); // Set the voter's submission.\r\n\r\n        // Calculate the voters effective stake for this round as the difference between their stake and pending stake.\r\n        // This allows for the voter to have staked during this reveal phase and not consider their pending stake.\r\n        uint128 effectiveStake = voterStakes[voter].stake - voterStakes[voter].pendingStakes[currentRoundId];\r\n        voteInstance.results.addVote(price, effectiveStake); // Add vote to the results.\r\n        emit VoteRevealed(voter, msg.sender, currentRoundId, identifier, time, ancillaryData, price, effectiveStake);\r\n    }\r\n\r\n    /**\r\n     * @notice Commits a vote and logs an event with a data blob, typically an encrypted version of the vote\r\n     * @dev An encrypted version of the vote is emitted in an event EncryptedVote to allow off-chain infrastructure to\r\n     * retrieve the commit. The contents of encryptedVote are never used on chain: it is purely for convenience.\r\n     * @param identifier unique price pair identifier. E.g. BTC/USD price pair.\r\n     * @param time unix timestamp of the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param hash keccak256 hash of the price you want to vote for and a int256 salt.\r\n     * @param encryptedVote offchain encrypted blob containing the voter's amount, time and salt.\r\n     */\r\n    function commitAndEmitEncryptedVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bytes32 hash,\r\n        bytes memory encryptedVote\r\n    ) public override {\r\n        commitVote(identifier, time, ancillaryData, hash);\r\n        emit EncryptedVote(msg.sender, getCurrentRoundId(), identifier, time, ancillaryData, encryptedVote);\r\n    }\r\n\r\n    /****************************************\r\n     *        VOTING GETTER FUNCTIONS       *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Gets the requests that are being voted on this round.\r\n     * @dev This view method returns requests with Active status that may be ahead of the stored contract state as this\r\n     * also filters out requests that would be resolvable or deleted if the resolvable requests were processed with the\r\n     * processResolvablePriceRequests() method.\r\n     * @return pendingRequests array containing identifiers of type PendingRequestAncillaryAugmented.\r\n     */\r\n    function getPendingRequests() public view override returns (PendingRequestAncillaryAugmented[] memory) {\r\n        // Solidity memory arrays aren't resizable (and reading storage is expensive). Hence this hackery to filter\r\n        // pendingPriceRequestsIds only to those requests that have an Active RequestStatus.\r\n        PendingRequestAncillaryAugmented[] memory unresolved =\r\n            new PendingRequestAncillaryAugmented[](pendingPriceRequestsIds.length);\r\n        uint256 numUnresolved = 0;\r\n        uint32 currentRoundId = getCurrentRoundId();\r\n\r\n        for (uint256 i = 0; i < pendingPriceRequestsIds.length; i = unsafe_inc(i)) {\r\n            PriceRequest storage priceRequest = priceRequests[pendingPriceRequestsIds[i]];\r\n            if (_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active) {\r\n                unresolved[numUnresolved] = PendingRequestAncillaryAugmented({\r\n                    lastVotingRound: priceRequest.lastVotingRound,\r\n                    isGovernance: priceRequest.isGovernance,\r\n                    time: priceRequest.time,\r\n                    rollCount: _getActualRollCount(priceRequest, currentRoundId),\r\n                    identifier: priceRequest.identifier,\r\n                    ancillaryData: priceRequest.ancillaryData\r\n                });\r\n                numUnresolved++;\r\n            }\r\n        }\r\n\r\n        PendingRequestAncillaryAugmented[] memory pendingRequests =\r\n            new PendingRequestAncillaryAugmented[](numUnresolved);\r\n        for (uint256 i = 0; i < numUnresolved; i = unsafe_inc(i)) pendingRequests[i] = unresolved[i];\r\n\r\n        return pendingRequests;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if there are current active requests.\r\n     * @return bool true if there are active requests, false otherwise.\r\n     */\r\n    function currentActiveRequests() public view returns (bool) {\r\n        uint32 currentRoundId = getCurrentRoundId();\r\n        for (uint256 i = 0; i < pendingPriceRequestsIds.length; i = unsafe_inc(i))\r\n            if (_getRequestStatus(priceRequests[pendingPriceRequestsIds[i]], currentRoundId) == RequestStatus.Active)\r\n                return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current voting phase, as a function of the current time.\r\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES }.\r\n     */\r\n    function getVotePhase() public view override returns (Phase) {\r\n        return Phase(uint256(voteTiming.computeCurrentPhase(getCurrentTime())));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current round ID, as a function of the current time.\r\n     * @return uint32 the unique round ID.\r\n     */\r\n    function getCurrentRoundId() public view override returns (uint32) {\r\n        return uint32(voteTiming.computeCurrentRoundId(getCurrentTime()));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the round end time, as a function of the round number.\r\n     * @param roundId representing the unique round ID.\r\n     * @return uint256 representing the round end time.\r\n     */\r\n    function getRoundEndTime(uint256 roundId) external view returns (uint256) {\r\n        return voteTiming.computeRoundEndTime(roundId);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of current pending price requests to be voted and the number of resolved price\r\n       requests over all time.\r\n     * @dev This method might return stale values if the state of the contract has changed since the last time\r\n       `processResolvablePriceRequests()` was called. To get the most up-to-date values, call\r\n       `getNumberOfPriceRequestsPostUpdate()` instead.\r\n     * @return numberPendingPriceRequests the total number of pending prices requests.\r\n     * @return numberResolvedPriceRequests the total number of prices resolved over all time.\r\n     */\r\n    function getNumberOfPriceRequests()\r\n        public\r\n        view\r\n        returns (uint256 numberPendingPriceRequests, uint256 numberResolvedPriceRequests)\r\n    {\r\n        return (pendingPriceRequestsIds.length, resolvedPriceRequestIds.length);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of current pending price requests to be voted and the number of resolved price\r\n       requests over all time after processing any resolvable price requests.\r\n     * @return numberPendingPriceRequests the total number of pending prices requests.\r\n     * @return numberResolvedPriceRequests the total number of prices resolved over all time.\r\n     */\r\n    function getNumberOfPriceRequestsPostUpdate()\r\n        external\r\n        returns (uint256 numberPendingPriceRequests, uint256 numberResolvedPriceRequests)\r\n    {\r\n        processResolvablePriceRequests();\r\n        return getNumberOfPriceRequests();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns aggregate slashing trackers for a given request index.\r\n     * @param requestIndex requestIndex the index of the request to fetch slashing trackers for.\r\n     * @return SlashingTracker Tracker object contains the slashed UMA per staked UMA per wrong vote and no vote, the\r\n     * total UMA slashed in the round and the total number of correct votes in the round.\r\n     */\r\n    function requestSlashingTrackers(uint256 requestIndex) public view returns (SlashingTracker memory) {\r\n        PriceRequest storage priceRequest = priceRequests[resolvedPriceRequestIds[requestIndex]];\r\n        uint32 lastVotingRound = priceRequest.lastVotingRound;\r\n        VoteInstance storage voteInstance = priceRequest.voteInstances[lastVotingRound];\r\n\r\n        uint256 totalVotes = voteInstance.results.totalVotes;\r\n        uint256 totalCorrectVotes = voteInstance.results.getTotalCorrectlyVotedTokens();\r\n        uint256 totalStaked = rounds[lastVotingRound].cumulativeStakeAtRound;\r\n\r\n        (uint256 wrongVoteSlash, uint256 noVoteSlash) =\r\n            rounds[lastVotingRound].slashingLibrary.calcSlashing(\r\n                totalStaked,\r\n                totalVotes,\r\n                totalCorrectVotes,\r\n                requestIndex,\r\n                priceRequest.isGovernance\r\n            );\r\n\r\n        uint256 totalSlashed =\r\n            ((noVoteSlash * (totalStaked - totalVotes)) + (wrongVoteSlash * (totalVotes - totalCorrectVotes))) / 1e18;\r\n\r\n        return SlashingTracker(wrongVoteSlash, noVoteSlash, totalSlashed, totalCorrectVotes, lastVotingRound);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the voter's participation in the vote for a given request index.\r\n     * @param requestIndex requestIndex the index of the request to fetch slashing trackers for.\r\n     * @param lastVotingRound the round to get voter participation for.\r\n     * @param voter the voter to get participation for.\r\n     * @return VoteParticipation enum representing the voter's participation in the vote.\r\n     */\r\n    function getVoterParticipation(\r\n        uint256 requestIndex,\r\n        uint32 lastVotingRound,\r\n        address voter\r\n    ) public view returns (VoteParticipation) {\r\n        VoteInstance storage voteInstance =\r\n            priceRequests[resolvedPriceRequestIds[requestIndex]].voteInstances[lastVotingRound];\r\n        bytes32 revealHash = voteInstance.voteSubmissions[voter].revealHash;\r\n        if (revealHash == bytes32(0)) return VoteParticipation.DidNotVote;\r\n        if (voteInstance.results.wasVoteCorrect(revealHash)) return VoteParticipation.CorrectVote;\r\n        return VoteParticipation.WrongVote;\r\n    }\r\n\r\n    /****************************************\r\n     *        OWNER ADMIN FUNCTIONS         *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Disables this Voting contract in favor of the migrated one.\r\n     * @dev Can only be called by the contract owner.\r\n     * @param newVotingAddress the newly migrated contract address.\r\n     */\r\n    function setMigrated(address newVotingAddress) external override onlyOwner {\r\n        migratedAddress = newVotingAddress;\r\n        emit VotingContractMigrated(newVotingAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the maximum number of rounds to roll a request can have before the DVM auto deletes it.\r\n     * @dev Can only be called by the contract owner.\r\n     * @param newMaxRolls the new number of rounds to roll a request before the DVM auto deletes it.\r\n     */\r\n    function setMaxRolls(uint32 newMaxRolls) public override onlyOwner {\r\n        // Changes to max rolls can impact unresolved requests. To protect against this process requests first.\r\n        processResolvablePriceRequests();\r\n        maxRolls = newMaxRolls;\r\n        emit MaxRollsChanged(newMaxRolls);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the maximum number of requests that can be made in a single round. Used to bound the maximum\r\n     * sequential slashing that can be applied within a single round.\r\n     * @dev Can only be called by the contract owner.\r\n     * @param newMaxRequestsPerRound the new maximum number of requests that can be made in a single round.\r\n     */\r\n    function setMaxRequestPerRound(uint32 newMaxRequestsPerRound) public override onlyOwner {\r\n        require(newMaxRequestsPerRound > 0);\r\n        maxRequestsPerRound = newMaxRequestsPerRound;\r\n        emit MaxRequestsPerRoundChanged(newMaxRequestsPerRound);\r\n    }\r\n\r\n    /**\r\n     * @notice Resets the GAT number and SPAT percentage. GAT is the minimum number of tokens that must participate in a\r\n     * vote for it to resolve (quorum number). SPAT is the minimum percentage of tokens that must agree on a result\r\n     * for it to resolve (percentage of staked tokens) This change only applies to subsequent rounds.\r\n     * @param newGat sets the next round's GAT and going forward.\r\n     * @param newSpat sets the next round's SPAT and going forward.\r\n     */\r\n    function setGatAndSpat(uint128 newGat, uint64 newSpat) public override onlyOwner {\r\n        require(newGat < votingToken.totalSupply() && newGat > 0);\r\n        require(newSpat > 0 && newSpat < 1e18);\r\n        gat = newGat;\r\n        spat = newSpat;\r\n\r\n        emit GatAndSpatChanged(newGat, newSpat);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the slashing library used by this contract.\r\n     * @param _newSlashingLibrary new slashing library address.\r\n     */\r\n    function setSlashingLibrary(address _newSlashingLibrary) public override onlyOwner {\r\n        slashingLibrary = SlashingLibraryInterface(_newSlashingLibrary);\r\n        emit SlashingLibraryChanged(_newSlashingLibrary);\r\n    }\r\n\r\n    /****************************************\r\n     *          STAKING FUNCTIONS           *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Updates the voter's trackers for staking and slashing. Applies all unapplied slashing to given staker.\r\n     * @dev Can be called by anyone, but it is not necessary for the contract to function is run the other functions.\r\n     * @param voter address of the voter to update the trackers for.\r\n     */\r\n    function updateTrackers(address voter) external {\r\n        _updateTrackers(voter);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the voter's trackers for staking and voting, specifying a maximum number of resolved requests to\r\n     * traverse. This function can be used in place of updateTrackers to process the trackers in batches, hence avoiding\r\n     * potential issues if the number of elements to be processed is large and the associated gas cost is too high.\r\n     * @param voter address of the voter to update the trackers for.\r\n     * @param maxTraversals maximum number of resolved requests to traverse in this call.\r\n     */\r\n    function updateTrackersRange(address voter, uint64 maxTraversals) external {\r\n        processResolvablePriceRequests();\r\n        _updateAccountSlashingTrackers(voter, maxTraversals);\r\n    }\r\n\r\n    // Updates the global and selected wallet's trackers for staking and voting. Note that the order of these calls is\r\n    // very important due to the interplay between slashing and inactive/active liquidity.\r\n    function _updateTrackers(address voter) internal override {\r\n        processResolvablePriceRequests();\r\n        _updateAccountSlashingTrackers(voter, UINT64_MAX);\r\n        super._updateTrackers(voter);\r\n    }\r\n\r\n    /**\r\n     * @notice Process and resolve all resolvable price requests. This function traverses all pending price requests and\r\n     *  resolves them if they are resolvable. It also rolls and deletes requests, if required.\r\n     */\r\n    function processResolvablePriceRequests() public {\r\n        _processResolvablePriceRequests(UINT64_MAX);\r\n    }\r\n\r\n    /**\r\n     * @notice Process and resolve all resolvable price requests. This function traverses all pending price requests and\r\n     * resolves them if they are resolvable. It also rolls and deletes requests, if required. This function can be used\r\n     * in place of processResolvablePriceRequests to process the requests in batches, hence avoiding potential issues if\r\n     * the number of elements to be processed is large and the associated gas cost is too high.\r\n     * @param maxTraversals maximum number of resolved requests to traverse in this call.\r\n     */\r\n    function processResolvablePriceRequestsRange(uint64 maxTraversals) external {\r\n        _processResolvablePriceRequests(maxTraversals);\r\n    }\r\n\r\n    // Starting index for a staker is the first value that nextIndexToProcess is set to and defines the first index that\r\n    // a staker is suspectable to receiving slashing on. This is set to current length of the resolvedPriceRequestIds.\r\n    // Note first call processResolvablePriceRequests to ensure that the resolvedPriceRequestIds array is up to date.\r\n    function _getStartingIndexForStaker() internal override returns (uint64) {\r\n        processResolvablePriceRequests();\r\n        return SafeCast.toUint64(resolvedPriceRequestIds.length);\r\n    }\r\n\r\n    // Checks if we are in an active voting reveal phase (currently revealing votes). This impacts if a new staker's\r\n    // stake should be activated immediately or if it should be frozen until the end of the reveal phase.\r\n    function _inActiveReveal() internal view override returns (bool) {\r\n        return (currentActiveRequests() && getVotePhase() == Phase.Reveal);\r\n    }\r\n\r\n    // This function must be called before any tokens are staked. It updates the voter's pending stakes to reflect the\r\n    // new amount to stake. These updates are only made if we are in an active reveal. This is required to appropriately\r\n    // calculate a voter's trackers and avoid slashing them for amounts staked during an active reveal phase.\r\n    function _computePendingStakes(address voter, uint128 amount) internal override {\r\n        if (_inActiveReveal()) {\r\n            uint32 currentRoundId = getCurrentRoundId();\r\n            // Freeze round variables to prevent cumulativeActiveStakeAtRound from changing based on the stakes during\r\n            // the active reveal phase. This will happen if the first action within the reveal is someone staking.\r\n            _freezeRoundVariables(currentRoundId);\r\n            // Increment pending stake for voter by amount. With the omission of stake from cumulativeActiveStakeAtRound\r\n            // for this round, ensure that the pending stakes is not included in the slashing calculation for this round.\r\n            _incrementPendingStake(voter, currentRoundId, amount);\r\n        }\r\n    }\r\n\r\n    // Updates the slashing trackers of a given account based on previous voting activity. This traverses all resolved\r\n    // requests for each voter and for each request checks if the voter voted correctly or not. Based on the voters\r\n    // voting activity the voters balance is updated accordingly. The caller can provide a maxTraversals parameter to\r\n    // limit the number of resolved requests to traverse in this call to bound the gas used. Note each iteration of\r\n    // this function re-uses a fresh slash variable to produce useful logs on the amount a voter is slashed.\r\n    function _updateAccountSlashingTrackers(address voter, uint64 maxTraversals) internal {\r\n        VoterStake storage voterStake = voterStakes[voter];\r\n        uint64 requestIndex = voterStake.nextIndexToProcess; // Traverse all requests from the last considered request.\r\n\r\n        // Traverse all elements within the resolvedPriceRequestIds array and update the voter's trackers according to\r\n        // their voting activity. Bound the number of iterations to the maxTraversals parameter to cap the gas used.\r\n        while (requestIndex < resolvedPriceRequestIds.length && maxTraversals > 0) {\r\n            maxTraversals = unsafe_dec_64(maxTraversals); // reduce the number of traversals left & re-use the prop.\r\n\r\n            // Get the slashing for this request. This comes from the slashing library and informs to the voter slash.\r\n            SlashingTracker memory trackers = requestSlashingTrackers(requestIndex);\r\n\r\n            // Use the effective stake as the difference between the current stake and pending stake. The staker will\r\n            //have a pending stake if they staked during an active reveal for the voting round in question.\r\n            uint256 effectiveStake = voterStake.stake - voterStake.pendingStakes[trackers.lastVotingRound];\r\n            int256 slash; // The amount to slash the voter by for this request. Reset on each entry to emit useful logs.\r\n\r\n            // Get the voter participation for this request. This informs if the voter voted correctly or not.\r\n            VoteParticipation participation = getVoterParticipation(requestIndex, trackers.lastVotingRound, voter);\r\n\r\n            // The voter did not reveal or did not commit. Slash at noVote rate.\r\n            if (participation == VoteParticipation.DidNotVote)\r\n                slash = -int256(Math.ceilDiv(effectiveStake * trackers.noVoteSlashPerToken, 1e18));\r\n\r\n                // The voter did not vote with the majority. Slash at wrongVote rate.\r\n            else if (participation == VoteParticipation.WrongVote)\r\n                slash = -int256(Math.ceilDiv(effectiveStake * trackers.wrongVoteSlashPerToken, 1e18));\r\n\r\n                // Else, the voter voted correctly. Receive a pro-rate share of the other voters slash.\r\n            else slash = int256((effectiveStake * trackers.totalSlashed) / trackers.totalCorrectVotes);\r\n\r\n            emit VoterSlashed(voter, requestIndex, int128(slash));\r\n            voterStake.unappliedSlash += int128(slash);\r\n\r\n            // If the next round is different to the current considered round, apply the slash to the voter.\r\n            if (isNextRequestRoundDifferent(requestIndex)) _applySlashToVoter(voterStake, voter);\r\n\r\n            requestIndex = unsafe_inc_64(requestIndex); // Increment the request index.\r\n        }\r\n\r\n        // Set the account's nextIndexToProcess to the requestIndex so the next entry starts where we left off.\r\n        voterStake.nextIndexToProcess = requestIndex;\r\n    }\r\n\r\n    // Applies a given slash to a given voter's stake. In the event the sum of the slash and the voter's stake is less\r\n    // than 0, the voter's stake is set to 0 to prevent the voter's stake from going negative. unappliedSlash tracked\r\n    // all slashing the staker has received but not yet applied to their stake. Apply it then set it to zero.\r\n    function _applySlashToVoter(VoterStake storage voterStake, address voter) internal {\r\n        if (voterStake.unappliedSlash + int128(voterStake.stake) > 0)\r\n            voterStake.stake = uint128(int128(voterStake.stake) + voterStake.unappliedSlash);\r\n        else voterStake.stake = 0;\r\n        emit VoterSlashApplied(voter, voterStake.unappliedSlash, voterStake.stake);\r\n        voterStake.unappliedSlash = 0;\r\n    }\r\n\r\n    // Checks if the next round (index+1) is different to the current round (index).\r\n    function isNextRequestRoundDifferent(uint64 index) internal view returns (bool) {\r\n        if (index + 1 >= resolvedPriceRequestIds.length) return true;\r\n\r\n        return\r\n            priceRequests[resolvedPriceRequestIds[index]].lastVotingRound !=\r\n            priceRequests[resolvedPriceRequestIds[index + 1]].lastVotingRound;\r\n    }\r\n\r\n    /****************************************\r\n     *      MIGRATION SUPPORT FUNCTIONS     *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Enable retrieval of rewards on a previously migrated away from voting contract. This function is intended\r\n     * on being removed from future versions of the Voting contract and aims to solve a short term migration pain point.\r\n     * @param voter voter for which rewards will be retrieved. Does not have to be the caller.\r\n     * @param roundId the round from which voting rewards will be retrieved from.\r\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\r\n     * @return uint256 the amount of rewards.\r\n     */\r\n    function retrieveRewardsOnMigratedVotingContract(\r\n        address voter,\r\n        uint256 roundId,\r\n        MinimumVotingAncillaryInterface.PendingRequestAncillary[] memory toRetrieve\r\n    ) external returns (uint256) {\r\n        uint256 rewards =\r\n            MinimumVotingAncillaryInterface(address(previousVotingContract))\r\n                .retrieveRewards(voter, roundId, toRetrieve)\r\n                .rawValue;\r\n        return rewards;\r\n    }\r\n\r\n    /****************************************\r\n     *    PRIVATE AND INTERNAL FUNCTIONS    *\r\n     ****************************************/\r\n\r\n    // Deletes a request from the pending requests array, based on index. Swap and pop.\r\n    function _removeRequestFromPendingPriceRequestsIds(uint64 pendingRequestIndex) internal {\r\n        pendingPriceRequestsIds[pendingRequestIndex] = pendingPriceRequestsIds[pendingPriceRequestsIds.length - 1];\r\n        pendingPriceRequestsIds.pop();\r\n    }\r\n\r\n    // Returns the price for a given identifier. Three params are returns: bool if there was an error, int to represent\r\n    // the resolved price and a string which is filled with an error message, if there was an error or \"\".\r\n    // This method considers actual request status that might be ahead of the stored contract state that gets updated\r\n    // only after processResolvablePriceRequests() is called.\r\n    function _getPriceOrError(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            bool,\r\n            int256,\r\n            string memory\r\n        )\r\n    {\r\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\r\n        uint32 currentRoundId = getCurrentRoundId();\r\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\r\n\r\n        if (requestStatus == RequestStatus.Active) return (false, 0, \"Current voting round not ended\");\r\n        if (requestStatus == RequestStatus.Resolved) {\r\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\r\n            (, int256 resolvedPrice) = _getResolvedPrice(voteInstance, priceRequest.lastVotingRound);\r\n            return (true, resolvedPrice, \"\");\r\n        }\r\n\r\n        if (requestStatus == RequestStatus.Future) return (false, 0, \"Price is still to be voted on\");\r\n        if (requestStatus == RequestStatus.ToDelete) return (false, 0, \"Price will be deleted\");\r\n        (bool previouslyResolved, int256 previousPrice) =\r\n            _getPriceFromPreviousVotingContract(identifier, time, ancillaryData);\r\n        if (previouslyResolved) return (true, previousPrice, \"\");\r\n        return (false, 0, \"Price was never requested\");\r\n    }\r\n\r\n    // Check the previousVotingContract to see if a given price request was resolved.\r\n    // Returns true or false, and the resolved price or zero, depending on whether it was found or not.\r\n    function _getPriceFromPreviousVotingContract(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) private view returns (bool, int256) {\r\n        if (address(previousVotingContract) == address(0)) return (false, 0);\r\n        if (previousVotingContract.hasPrice(identifier, time, ancillaryData))\r\n            return (true, previousVotingContract.getPrice(identifier, time, ancillaryData));\r\n        return (false, 0);\r\n    }\r\n\r\n    // Returns a price request object for a given identifier, time and ancillary data.\r\n    function _getPriceRequest(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) private view returns (PriceRequest storage) {\r\n        return priceRequests[_encodePriceRequest(identifier, time, ancillaryData)];\r\n    }\r\n\r\n    // Returns an encoded bytes32 representing a price request. Used when storing/referencing price requests.\r\n    function _encodePriceRequest(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) private pure returns (bytes32) {\r\n        return keccak256(abi.encode(identifier, time, ancillaryData));\r\n    }\r\n\r\n    // Stores (\"freezes\") variables that should not shift within an active voting round. Called on reveal but only makes\r\n    // a state change if and only if the this is the first reveal.\r\n    function _freezeRoundVariables(uint256 roundId) private {\r\n        // Only freeze the round if this is the first request in the round.\r\n        if (rounds[roundId].minParticipationRequirement == 0) {\r\n            rounds[roundId].slashingLibrary = slashingLibrary;\r\n\r\n            // The minimum required participation for a vote to settle within this round is the GAT (fixed number).\r\n            rounds[roundId].minParticipationRequirement = gat;\r\n\r\n            // The minimum votes on the modal outcome for the vote to settle within this round is the SPAT (percentage).\r\n            rounds[roundId].minAgreementRequirement = uint128((spat * uint256(cumulativeStake)) / 1e18);\r\n            rounds[roundId].cumulativeStakeAtRound = cumulativeStake; // Store the cumulativeStake to work slashing.\r\n        }\r\n    }\r\n\r\n    // Traverse pending price requests and resolve any that are resolvable. If requests are rollable (they did not\r\n    // resolve in the previous round and are to be voted in a subsequent round) then roll them. If requests can be\r\n    // deleted (they have been rolled up to the maxRolls counter) then delete them. The caller can pass in maxTraversals\r\n    // to limit the number of requests that are resolved in a single call to bound the total gas used by this function.\r\n    // Note that the resolved index is stores for each round. This means that only the first caller of this function\r\n    // per round needs to traverse the pending requests. After that subsequent calls to this are a no-op for that round.\r\n    function _processResolvablePriceRequests(uint64 maxTraversals) private {\r\n        uint32 currentRoundId = getCurrentRoundId();\r\n\r\n        // Load in the last resolved index for this round to continue off from where the last caller left.\r\n        uint64 requestIndex = lastRoundIdProcessed == currentRoundId ? nextPendingIndexToProcess : 0;\r\n        // Traverse pendingPriceRequestsIds array and update the requests status according to the state of the request\r\n        //(i.e settle, roll or delete request). Bound iterations to the maxTraversals parameter to cap the gas used.\r\n        while (requestIndex < pendingPriceRequestsIds.length && maxTraversals > 0) {\r\n            maxTraversals = unsafe_dec_64(maxTraversals);\r\n            PriceRequest storage request = priceRequests[pendingPriceRequestsIds[requestIndex]];\r\n\r\n            // If the last voting round is greater than or equal to the current round then this request is currently\r\n            // being voted on or is enqueued for the next round. In this case, skip it and increment the request index.\r\n            if (request.lastVotingRound >= currentRoundId) {\r\n                requestIndex = unsafe_inc_64(requestIndex);\r\n                continue; // Continue to the next request.\r\n            }\r\n\r\n            // Else, we are dealing with a request that can either be: a) deleted, b) rolled or c) resolved.\r\n            VoteInstance storage voteInstance = request.voteInstances[request.lastVotingRound];\r\n            (bool isResolvable, int256 resolvedPrice) = _getResolvedPrice(voteInstance, request.lastVotingRound);\r\n\r\n            if (isResolvable) {\r\n                // If resolvable, resolve. This involves a) moving the requestId from pendingPriceRequestsIds array to\r\n                // resolvedPriceRequestIds array and b) removing requestId from pendingPriceRequestsIds. Don't need to\r\n                // increment requestIndex as from pendingPriceRequestsIds amounts to decreasing the while loop bound.\r\n                resolvedPriceRequestIds.push(pendingPriceRequestsIds[requestIndex]);\r\n                _removeRequestFromPendingPriceRequestsIds(requestIndex);\r\n                emit RequestResolved(\r\n                    request.lastVotingRound,\r\n                    resolvedPriceRequestIds.length - 1,\r\n                    request.identifier,\r\n                    request.time,\r\n                    request.ancillaryData,\r\n                    resolvedPrice\r\n                );\r\n                continue; // Continue to the next request.\r\n            }\r\n            // If not resolvable, but the round has passed its voting round, then it must be deleted or rolled. First,\r\n            // increment the rollCount. Use the difference between the current round and the last voting round to\r\n            // accommodate the contract not being touched for any number of rounds during the roll.\r\n            request.rollCount += currentRoundId - request.lastVotingRound;\r\n\r\n            // If the roll count exceeds the threshold and the request is not governance then it is deletable.\r\n            if (_shouldDeleteRequest(request.rollCount, request.isGovernance)) {\r\n                emit RequestDeleted(request.identifier, request.time, request.ancillaryData, request.rollCount);\r\n                delete priceRequests[pendingPriceRequestsIds[requestIndex]];\r\n                _removeRequestFromPendingPriceRequestsIds(requestIndex);\r\n                continue;\r\n            }\r\n            // Else, the request should be rolled. This involves only moving forward the lastVotingRound.\r\n            request.lastVotingRound = getRoundIdToVoteOnRequest(currentRoundId);\r\n            ++rounds[request.lastVotingRound].numberOfRequestsToVote;\r\n            emit RequestRolled(request.identifier, request.time, request.ancillaryData, request.rollCount);\r\n            requestIndex = unsafe_inc_64(requestIndex);\r\n        }\r\n\r\n        lastRoundIdProcessed = currentRoundId; // Store the roundId that was processed.\r\n        nextPendingIndexToProcess = requestIndex; // Store the index traversed up to for this round.\r\n    }\r\n\r\n    // Returns a price request status. A request is either: NotRequested, Active, Resolved, Future or ToDelete.\r\n    function _getRequestStatus(PriceRequest storage priceRequest, uint32 currentRoundId)\r\n        private\r\n        view\r\n        returns (RequestStatus)\r\n    {\r\n        if (priceRequest.lastVotingRound == 0) return RequestStatus.NotRequested;\r\n        if (priceRequest.lastVotingRound < currentRoundId) {\r\n            // Check if the request has already been resolved\r\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\r\n            (bool isResolved, ) = _getResolvedPrice(voteInstance, priceRequest.lastVotingRound);\r\n            if (isResolved) return RequestStatus.Resolved;\r\n            if (_shouldDeleteRequest(_getActualRollCount(priceRequest, currentRoundId), priceRequest.isGovernance))\r\n                return RequestStatus.ToDelete;\r\n            return RequestStatus.Active;\r\n        }\r\n        if (priceRequest.lastVotingRound == currentRoundId) return RequestStatus.Active;\r\n\r\n        return RequestStatus.Future; // Means than priceRequest.lastVotingRound > currentRoundId\r\n    }\r\n\r\n    function _getResolvedPrice(VoteInstance storage voteInstance, uint256 lastVotingRound)\r\n        internal\r\n        view\r\n        returns (bool isResolved, int256 price)\r\n    {\r\n        return\r\n            voteInstance.results.getResolvedPrice(\r\n                rounds[lastVotingRound].minParticipationRequirement,\r\n                rounds[lastVotingRound].minAgreementRequirement\r\n            );\r\n    }\r\n\r\n    // Gas optimized uint256 increment.\r\n    function unsafe_inc(uint256 x) internal pure returns (uint256) {\r\n        unchecked { return x + 1; }\r\n    }\r\n\r\n    // Gas optimized uint64 increment.\r\n    function unsafe_inc_64(uint64 x) internal pure returns (uint64) {\r\n        unchecked { return x + 1; }\r\n    }\r\n\r\n    // Gas optimized uint64 decrement.\r\n    function unsafe_dec_64(uint64 x) internal pure returns (uint64) {\r\n        unchecked { return x - 1; }\r\n    }\r\n\r\n    // Returns the registered identifier whitelist, stored in the finder.\r\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    // Reverts if the contract has been migrated. Used in a modifier, defined as a private function for gas savings.\r\n    function _requireNotMigrated() private view {\r\n        require(migratedAddress == address(0), \"Contract migrated\");\r\n    }\r\n\r\n    // Enforces that a calling contract is registered.\r\n    function _requireRegisteredContract() private view {\r\n        RegistryInterface registry = RegistryInterface(finder.getImplementationAddress(OracleInterfaces.Registry));\r\n        require(registry.isContractRegistered(msg.sender) || msg.sender == migratedAddress, \"Caller not registered\");\r\n    }\r\n\r\n    // Checks if a request should be deleted. A non-gevernance request should be deleted if it has been rolled more than\r\n    // the maxRolls.\r\n    function _shouldDeleteRequest(uint256 rollCount, bool isGovernance) private view returns (bool) {\r\n        return rollCount > maxRolls && !isGovernance;\r\n    }\r\n\r\n    // Returns the actual roll count of a request. This is the roll count plus the number of rounds that have passed\r\n    // since the last voting round.\r\n    function _getActualRollCount(PriceRequest storage priceRequest, uint32 currentRoundId)\r\n        private\r\n        view\r\n        returns (uint32)\r\n    {\r\n        if (currentRoundId <= priceRequest.lastVotingRound) return priceRequest.rollCount;\r\n        return priceRequest.rollCount + currentRoundId - priceRequest.lastVotingRound;\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/AdministrateeInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n/**\r\n * @title Interface that all financial contracts expose to the admin.\r\n */\r\ninterface AdministrateeInterface {\r\n    /**\r\n     * @notice Initiates the shutdown process, in case of an emergency.\r\n     */\r\n    function emergencyShutdown() external;\r\n\r\n    /**\r\n     * @notice A core contract method called independently or as a part of other financial contract transactions.\r\n     * @dev It pays fees and moves money between margin accounts to make sure they reflect the NAV of the contract.\r\n     */\r\n    function remargin() external;\r\n\r\n    /**\r\n     * @notice Gets the current profit from corruption for this contract in terms of the collateral currency.\r\n     * @dev This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are\r\n     * expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.\r\n     * @return pfc value for equal to the current profit from corruption denominated in collateral currency.\r\n     */\r\n    function pfc() external view returns (FixedPoint.Unsigned memory);\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/FinderInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Provides addresses of the live contracts implementing certain interfaces.\r\n * @dev Examples are the Oracle or Store interfaces.\r\n */\r\ninterface FinderInterface {\r\n    /**\r\n     * @notice Updates the address of the contract that implements `interfaceName`.\r\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\r\n     * @param implementationAddress address of the deployed contract that implements the interface.\r\n     */\r\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\r\n\r\n    /**\r\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\r\n     * @param interfaceName queried interface.\r\n     * @return implementationAddress address of the deployed contract that implements the interface.\r\n     */\r\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Interface for whitelists of supported identifiers that the oracle can provide prices for.\r\n */\r\ninterface IdentifierWhitelistInterface {\r\n    /**\r\n     * @notice Adds the provided identifier as a supported identifier.\r\n     * @dev Price requests using this identifier will succeed after this call.\r\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\r\n     */\r\n    function addSupportedIdentifier(bytes32 identifier) external;\r\n\r\n    /**\r\n     * @notice Removes the identifier from the whitelist.\r\n     * @dev Price requests using this identifier will no longer succeed after this call.\r\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\r\n     */\r\n    function removeSupportedIdentifier(bytes32 identifier) external;\r\n\r\n    /**\r\n     * @notice Checks whether an identifier is on the whitelist.\r\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\r\n     * @return bool if the identifier is supported (or not).\r\n     */\r\n    function isIdentifierSupported(bytes32 identifier) external view returns (bool);\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/MinimumVotingAncillaryInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\ninterface MinimumVotingAncillaryInterface {\r\n    struct Unsigned {\r\n        uint256 rawValue;\r\n    }\r\n\r\n    struct PendingRequestAncillary {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        bytes ancillaryData;\r\n    }\r\n\r\n    function retrieveRewards(\r\n        address voterAddress,\r\n        uint256 roundId,\r\n        PendingRequestAncillary[] memory toRetrieve\r\n    ) external returns (Unsigned memory);\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/OracleAncillaryInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Financial contract facing Oracle interface.\r\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\r\n */\r\nabstract contract OracleAncillaryInterface {\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\r\n     * @dev Time must be in the past and the identifier must be supported.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param time unix timestamp for the price request.\r\n     */\r\n\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public virtual;\r\n\r\n    /**\r\n     * @notice Whether the price for `identifier` and `time` is available.\r\n     * @dev Time must be in the past and the identifier must be supported.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\r\n     */\r\n    function hasPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (bool);\r\n\r\n    /**\r\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\r\n     * @dev If the price is not available, the method reverts.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return int256 representing the resolved price for the given identifier and timestamp.\r\n     */\r\n\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (int256);\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/OracleGovernanceInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./OracleInterface.sol\";\r\nimport \"./OracleAncillaryInterface.sol\";\r\n\r\n/**\r\n * @title Financial contract facing extending the Oracle interface with governance actions.\r\n * @dev Interface used by financial contracts to interact with the Oracle extending governance actions. Voters will use a different interface.\r\n */\r\nabstract contract OracleGovernanceInterface is OracleInterface, OracleAncillaryInterface {\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\r\n     * @dev Time must be in the past and the identifier must be supported.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param time unix timestamp for the price request.\r\n     */\r\n    function requestGovernanceAction(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) external virtual;\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Financial contract facing Oracle interface.\r\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\r\n */\r\nabstract contract OracleInterface {\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\r\n     * @dev Time must be in the past and the identifier must be supported.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     */\r\n    function requestPrice(bytes32 identifier, uint256 time) external virtual;\r\n\r\n    /**\r\n     * @notice Whether the price for `identifier` and `time` is available.\r\n     * @dev Time must be in the past and the identifier must be supported.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\r\n     */\r\n    function hasPrice(bytes32 identifier, uint256 time) external view virtual returns (bool);\r\n\r\n    /**\r\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\r\n     * @dev If the price is not available, the method reverts.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     * @return int256 representing the resolved price for the given identifier and timestamp.\r\n     */\r\n    function getPrice(bytes32 identifier, uint256 time) external view virtual returns (int256);\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/RegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Interface for a registry of contracts and contract creators.\r\n */\r\ninterface RegistryInterface {\r\n    /**\r\n     * @notice Registers a new contract.\r\n     * @dev Only authorized contract creators can call this method.\r\n     * @param parties an array of addresses who become parties in the contract.\r\n     * @param contractAddress defines the address of the deployed contract.\r\n     */\r\n    function registerContract(address[] calldata parties, address contractAddress) external;\r\n\r\n    /**\r\n     * @notice Returns whether the contract has been registered with the registry.\r\n     * @dev If it is registered, it is an authorized participant in the UMA system.\r\n     * @param contractAddress address of the contract.\r\n     * @return bool indicates whether the contract is registered.\r\n     */\r\n    function isContractRegistered(address contractAddress) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns a list of all contracts that are associated with a particular party.\r\n     * @param party address of the party.\r\n     * @return an array of the contracts the party is registered to.\r\n     */\r\n    function getRegisteredContracts(address party) external view returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Returns all registered contracts.\r\n     * @return all registered contract addresses within the system.\r\n     */\r\n    function getAllRegisteredContracts() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Adds a party to the calling contract.\r\n     * @dev msg.sender must be the contract to which the party member is added.\r\n     * @param party address to be added to the contract.\r\n     */\r\n    function addPartyToContract(address party) external;\r\n\r\n    /**\r\n     * @notice Removes a party member to the calling contract.\r\n     * @dev msg.sender must be the contract to which the party member is added.\r\n     * @param party address to be removed from the contract.\r\n     */\r\n    function removePartyFromContract(address party) external;\r\n\r\n    /**\r\n     * @notice checks if an address is a party in a contract.\r\n     * @param party party to check.\r\n     * @param contractAddress address to check against the party.\r\n     * @return bool indicating if the address is a party of the contract.\r\n     */\r\n    function isPartyMemberOfContract(address party, address contractAddress) external view returns (bool);\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/SlashingLibraryInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\ninterface SlashingLibraryInterface {\r\n    /**\r\n     * @notice Calculates the wrong vote slash per token.\r\n     * @param totalStaked The total amount of tokens staked.\r\n     * @param totalVotes The total amount of votes.\r\n     * @param totalCorrectVotes The total amount of correct votes.\r\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\r\n     * @return uint256 The amount of tokens to slash per token staked.\r\n     */\r\n    function calcWrongVoteSlashPerToken(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Calculates the wrong vote slash per token for governance requests.\r\n     * @param totalStaked The total amount of tokens staked.\r\n     * @param totalVotes The total amount of votes.\r\n     * @param totalCorrectVotes The total amount of correct votes.\r\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\r\n     * @return uint256 The amount of tokens to slash per token staked.\r\n     */\r\n    function calcWrongVoteSlashPerTokenGovernance(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Calculates the no vote slash per token.\r\n     * @param totalStaked The total amount of tokens staked.\r\n     * @param totalVotes The total amount of votes.\r\n     * @param totalCorrectVotes The total amount of correct votes.\r\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\r\n     * @return uint256 The amount of tokens to slash per token staked.\r\n     */\r\n    function calcNoVoteSlashPerToken(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Calculates all slashing trackers in one go to decrease cross-contract calls needed.\r\n     * @param totalStaked The total amount of tokens staked.\r\n     * @param totalVotes The total amount of votes.\r\n     * @param totalCorrectVotes The total amount of correct votes.\r\n     * @param priceRequestIndex The price request index within the resolvedPriceRequestIds array.\r\n     * @param isGovernance Whether the request is a governance request.\r\n     * @return wrongVoteSlashPerToken The amount of tokens to slash for voting wrong.\r\n     * @return noVoteSlashPerToken The amount of tokens to slash for not voting.\r\n     */\r\n    function calcSlashing(\r\n        uint256 totalStaked,\r\n        uint256 totalVotes,\r\n        uint256 totalCorrectVotes,\r\n        uint256 priceRequestIndex,\r\n        bool isGovernance\r\n    ) external view returns (uint256 wrongVoteSlashPerToken, uint256 noVoteSlashPerToken);\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/StakerInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../implementation/VotingToken.sol\";\r\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\r\n\r\ninterface StakerInterface {\r\n    function votingToken() external returns (ExpandedIERC20);\r\n\r\n    function stake(uint128 amount) external;\r\n\r\n    function requestUnstake(uint128 amount) external;\r\n\r\n    function executeUnstake() external;\r\n\r\n    function withdrawRewards() external returns (uint128);\r\n\r\n    function withdrawAndRestake() external returns (uint128);\r\n\r\n    function setEmissionRate(uint128 newEmissionRate) external;\r\n\r\n    function setUnstakeCoolDown(uint64 newUnstakeCoolDown) external;\r\n\r\n    /**\r\n     * @notice Sets the delegate of a voter. This delegate can vote on behalf of the staker. The staker will still own\r\n     * all staked balances, receive rewards and be slashed based on the actions of the delegate. Intended use is using a\r\n     * low-security available wallet for voting while keeping access to staked amounts secure by a more secure wallet.\r\n     * @param delegate the address of the delegate.\r\n     */\r\n    function setDelegate(address delegate) external virtual;\r\n\r\n    /**\r\n     * @notice Sets the delegator of a voter. Acts to accept a delegation. The delegate can only vote for the delegator\r\n     * if the delegator also selected the delegate to do so (two-way relationship needed).\r\n     * @param delegator the address of the delegator.\r\n     */\r\n    function setDelegator(address delegator) external virtual;\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/StoreInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n/**\r\n * @title Interface that allows financial contracts to pay oracle fees for their use of the system.\r\n */\r\ninterface StoreInterface {\r\n    /**\r\n     * @notice Pays Oracle fees in ETH to the store.\r\n     * @dev To be used by contracts whose margin currency is ETH.\r\n     */\r\n    function payOracleFees() external payable;\r\n\r\n    /**\r\n     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\r\n     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\r\n     * @param erc20Address address of the ERC20 token used to pay the fee.\r\n     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\r\n     */\r\n    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external;\r\n\r\n    /**\r\n     * @notice Computes the regular oracle fees that a contract should pay for a period.\r\n     * @param startTime defines the beginning time from which the fee is paid.\r\n     * @param endTime end time until which the fee is paid.\r\n     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a\r\n     * token sponsor could extract from the contract through corrupting the price feed in their favor.\r\n     * @return regularFee amount owed for the duration from start to end time for the given pfc.\r\n     * @return latePenalty for paying the fee after the deadline.\r\n     */\r\n    function computeRegularFee(\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        FixedPoint.Unsigned calldata pfc\r\n    ) external view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty);\r\n\r\n    /**\r\n     * @notice Computes the final oracle fees that a contract should pay at settlement.\r\n     * @param currency token used to pay the final fee.\r\n     * @return finalFee amount due.\r\n     */\r\n    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory);\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/VotingAncillaryInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n/**\r\n * @title Interface that voters must use to Vote on price request resolutions.\r\n */\r\nabstract contract VotingAncillaryInterface {\r\n    struct PendingRequestAncillary {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        bytes ancillaryData;\r\n    }\r\n\r\n    // Captures the necessary data for making a commitment.\r\n    // Used as a parameter when making batch commitments.\r\n    // Not used as a data structure for storage.\r\n    struct CommitmentAncillary {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        bytes ancillaryData;\r\n        bytes32 hash;\r\n        bytes encryptedVote;\r\n    }\r\n\r\n    // Captures the necessary data for revealing a vote.\r\n    // Used as a parameter when making batch reveals.\r\n    // Not used as a data structure for storage.\r\n    struct RevealAncillary {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        int256 price;\r\n        bytes ancillaryData;\r\n        int256 salt;\r\n    }\r\n\r\n    // Note: the phases must be in order. Meaning the first enum value must be the first phase, etc.\r\n    // `NUM_PHASES` is to get the number of phases. It isn't an actual phase, and it should always be last.\r\n    enum Phase { Commit, Reveal, NUM_PHASES }\r\n\r\n    /**\r\n     * @notice Commit a vote for a price request for `identifier` at `time`.\r\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\r\n     * Commits can be changed.\r\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the systems expected behavior,\r\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\r\n     * they can determine the vote pre-reveal.\r\n     * @param identifier uniquely identifies the committed vote. E.G. BTC/USD price pair.\r\n     * @param time unix timestamp of the price being voted on.\r\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\r\n     */\r\n    function commitVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bytes32 hash\r\n    ) public virtual;\r\n\r\n    /**\r\n     * @notice Submit a batch of commits in a single transaction.\r\n     * @dev Using `encryptedVote` is optional. If included then commitment is stored on chain.\r\n     * Look at `project-root/common/Constants.js` for the tested maximum number of\r\n     * commitments that can fit in one transaction.\r\n     * @param commits array of structs that encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\r\n     */\r\n    function batchCommit(CommitmentAncillary[] memory commits) public virtual;\r\n\r\n    /**\r\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\r\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\r\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\r\n     * @param identifier unique price pair identifier. E.g. BTC/USD price pair.\r\n     * @param time unix timestamp of for the price request.\r\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\r\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\r\n     */\r\n    function commitAndEmitEncryptedVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bytes32 hash,\r\n        bytes memory encryptedVote\r\n    ) public virtual;\r\n\r\n    /**\r\n     * @notice snapshot the current round's token balances and lock in the inflation rate and GAT.\r\n     * @dev This function can be called multiple times but each round will only every have one snapshot at the\r\n     * time of calling `_freezeRoundVariables`.\r\n     * @param signature  signature required to prove caller is an EOA to prevent flash loans from being included in the\r\n     * snapshot.\r\n     */\r\n    function snapshotCurrentRound(bytes calldata signature) external virtual;\r\n\r\n    /**\r\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\r\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\r\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\r\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\r\n     * @param time specifies the unix timestamp of the price is being voted on.\r\n     * @param price voted on during the commit phase.\r\n     * @param salt value used to hide the commitment price during the commit phase.\r\n     */\r\n    function revealVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes memory ancillaryData,\r\n        int256 salt\r\n    ) public virtual;\r\n\r\n    /**\r\n     * @notice Reveal multiple votes in a single transaction.\r\n     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\r\n     * that can fit in one transaction.\r\n     * @dev For more information on reveals, review the comment for `revealVote`.\r\n     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\r\n     */\r\n    function batchReveal(RevealAncillary[] memory reveals) public virtual;\r\n\r\n    /**\r\n     * @notice Gets the queries that are being voted on this round.\r\n     * @return pendingRequests `PendingRequest` array containing identifiers\r\n     * and timestamps for all pending requests.\r\n     */\r\n    function getPendingRequests() external view virtual returns (PendingRequestAncillary[] memory);\r\n\r\n    /**\r\n     * @notice Returns the current voting phase, as a function of the current time.\r\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES }.\r\n     */\r\n    function getVotePhase() external view virtual returns (Phase);\r\n\r\n    /**\r\n     * @notice Returns the current round ID, as a function of the current time.\r\n     * @return uint256 representing the unique round ID.\r\n     */\r\n    function getCurrentRoundId() external view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice Retrieves rewards owed for a set of resolved price requests.\r\n     * @dev Can only retrieve rewards if calling for a valid round and if the\r\n     * call is done within the timeout threshold (not expired).\r\n     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\r\n     * @param roundId the round from which voting rewards will be retrieved from.\r\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\r\n     * @return total amount of rewards returned to the voter.\r\n     */\r\n    function retrieveRewards(\r\n        address voterAddress,\r\n        uint256 roundId,\r\n        PendingRequestAncillary[] memory toRetrieve\r\n    ) public virtual returns (FixedPoint.Unsigned memory);\r\n\r\n    // Voting Owner functions.\r\n\r\n    /**\r\n     * @notice Disables this Voting contract in favor of the migrated one.\r\n     * @dev Can only be called by the contract owner.\r\n     * @param newVotingAddress the newly migrated contract address.\r\n     */\r\n    function setMigrated(address newVotingAddress) external virtual;\r\n\r\n    /**\r\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\r\n     * @dev This method is public because calldata structs are not currently supported by solidity.\r\n     * @param newInflationRate sets the next round's inflation rate.\r\n     */\r\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate) public virtual;\r\n\r\n    /**\r\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\r\n     * @dev This method is public because calldata structs are not currently supported by solidity.\r\n     * @param newGatPercentage sets the next round's Gat percentage.\r\n     */\r\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage) public virtual;\r\n\r\n    /**\r\n     * @notice Resets the rewards expiration timeout.\r\n     * @dev This change only applies to rounds that have not yet begun.\r\n     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\r\n     */\r\n    function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout) public virtual;\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/VotingInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"./VotingAncillaryInterface.sol\";\r\n\r\n/**\r\n * @title Interface that voters must use to Vote on price request resolutions.\r\n */\r\nabstract contract VotingInterface {\r\n    struct PendingRequest {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n    }\r\n\r\n    // Captures the necessary data for making a commitment.\r\n    // Used as a parameter when making batch commitments.\r\n    // Not used as a data structure for storage.\r\n    struct Commitment {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        bytes32 hash;\r\n        bytes encryptedVote;\r\n    }\r\n\r\n    // Captures the necessary data for revealing a vote.\r\n    // Used as a parameter when making batch reveals.\r\n    // Not used as a data structure for storage.\r\n    struct Reveal {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        int256 price;\r\n        int256 salt;\r\n    }\r\n\r\n    /**\r\n     * @notice Commit a vote for a price request for `identifier` at `time`.\r\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\r\n     * Commits can be changed.\r\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the systems expected behavior,\r\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\r\n     * they can determine the vote pre-reveal.\r\n     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\r\n     * @param time unix timestamp of the price being voted on.\r\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\r\n     */\r\n    function commitVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes32 hash\r\n    ) external virtual;\r\n\r\n    /**\r\n     * @notice Submit a batch of commits in a single transaction.\r\n     * @dev Using `encryptedVote` is optional. If included then commitment is stored on chain.\r\n     * Look at `project-root/common/Constants.js` for the tested maximum number of\r\n     * commitments that can fit in one transaction.\r\n     * @param commits array of structs that encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\r\n     */\r\n    function batchCommit(Commitment[] memory commits) public virtual;\r\n\r\n    /**\r\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\r\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\r\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\r\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\r\n     * @param time unix timestamp of for the price request.\r\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\r\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\r\n     */\r\n    function commitAndEmitEncryptedVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes32 hash,\r\n        bytes memory encryptedVote\r\n    ) public virtual;\r\n\r\n    /**\r\n     * @notice snapshot the current round's token balances and lock in the inflation rate and GAT.\r\n     * @dev This function can be called multiple times but each round will only every have one snapshot at the\r\n     * time of calling `_freezeRoundVariables`.\r\n     * @param signature  signature required to prove caller is an EOA to prevent flash loans from being included in the\r\n     * snapshot.\r\n     */\r\n    function snapshotCurrentRound(bytes calldata signature) external virtual;\r\n\r\n    /**\r\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\r\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\r\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\r\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\r\n     * @param time specifies the unix timestamp of the price is being voted on.\r\n     * @param price voted on during the commit phase.\r\n     * @param salt value used to hide the commitment price during the commit phase.\r\n     */\r\n    function revealVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        int256 salt\r\n    ) public virtual;\r\n\r\n    /**\r\n     * @notice Reveal multiple votes in a single transaction.\r\n     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\r\n     * that can fit in one transaction.\r\n     * @dev For more information on reveals, review the comment for `revealVote`.\r\n     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\r\n     */\r\n    function batchReveal(Reveal[] memory reveals) public virtual;\r\n\r\n    /**\r\n     * @notice Gets the queries that are being voted on this round.\r\n     * @return pendingRequests `PendingRequest` array containing identifiers\r\n     * and timestamps for all pending requests.\r\n     */\r\n    function getPendingRequests()\r\n        external\r\n        view\r\n        virtual\r\n        returns (VotingAncillaryInterface.PendingRequestAncillary[] memory);\r\n\r\n    /**\r\n     * @notice Returns the current voting phase, as a function of the current time.\r\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES }.\r\n     */\r\n    function getVotePhase() external view virtual returns (VotingAncillaryInterface.Phase);\r\n\r\n    /**\r\n     * @notice Returns the current round ID, as a function of the current time.\r\n     * @return uint256 representing the unique round ID.\r\n     */\r\n    function getCurrentRoundId() external view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice Retrieves rewards owed for a set of resolved price requests.\r\n     * @dev Can only retrieve rewards if calling for a valid round and if the\r\n     * call is done within the timeout threshold (not expired).\r\n     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\r\n     * @param roundId the round from which voting rewards will be retrieved from.\r\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\r\n     * @return total amount of rewards returned to the voter.\r\n     */\r\n    function retrieveRewards(\r\n        address voterAddress,\r\n        uint256 roundId,\r\n        PendingRequest[] memory toRetrieve\r\n    ) public virtual returns (FixedPoint.Unsigned memory);\r\n\r\n    // Voting Owner functions.\r\n\r\n    /**\r\n     * @notice Disables this Voting contract in favor of the migrated one.\r\n     * @dev Can only be called by the contract owner.\r\n     * @param newVotingAddress the newly migrated contract address.\r\n     */\r\n    function setMigrated(address newVotingAddress) external virtual;\r\n\r\n    /**\r\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\r\n     * @dev This method is public because calldata structs are not currently supported by solidity.\r\n     * @param newInflationRate sets the next round's inflation rate.\r\n     */\r\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate) public virtual;\r\n\r\n    /**\r\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\r\n     * @dev This method is public because calldata structs are not currently supported by solidity.\r\n     * @param newGatPercentage sets the next round's Gat percentage.\r\n     */\r\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage) public virtual;\r\n\r\n    /**\r\n     * @notice Resets the rewards expiration timeout.\r\n     * @dev This change only applies to rounds that have not yet begun.\r\n     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\r\n     */\r\n    function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout) public virtual;\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/interfaces/VotingV2Interface.sol": {
      "content": "// TODO: add staking/snapshot interfaces to this interface file.\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title Interface that voters must use to Vote on price request resolutions.\r\n */\r\nabstract contract VotingV2Interface {\r\n    struct PendingRequest {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n    }\r\n\r\n    struct PendingRequestAncillary {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        bytes ancillaryData;\r\n    }\r\n\r\n    struct PendingRequestAncillaryAugmented {\r\n        uint32 lastVotingRound;\r\n        bool isGovernance;\r\n        uint64 time;\r\n        uint32 rollCount;\r\n        bytes32 identifier;\r\n        bytes ancillaryData;\r\n    }\r\n\r\n    // Captures the necessary data for making a commitment.\r\n    // Used as a parameter when making batch commitments.\r\n    // Not used as a data structure for storage.\r\n    struct Commitment {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        bytes32 hash;\r\n        bytes encryptedVote;\r\n    }\r\n\r\n    // Captures the necessary data for revealing a vote.\r\n    // Used as a parameter when making batch reveals.\r\n    // Not used as a data structure for storage.\r\n    struct Reveal {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        int256 price;\r\n        int256 salt;\r\n    }\r\n\r\n    // Captures the necessary data for making a commitment.\r\n    // Used as a parameter when making batch commitments.\r\n    // Not used as a data structure for storage.\r\n    struct CommitmentAncillary {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        bytes ancillaryData;\r\n        bytes32 hash;\r\n        bytes encryptedVote;\r\n    }\r\n\r\n    // Captures the necessary data for revealing a vote.\r\n    // Used as a parameter when making batch reveals.\r\n    // Not used as a data structure for storage.\r\n    struct RevealAncillary {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        int256 price;\r\n        bytes ancillaryData;\r\n        int256 salt;\r\n    }\r\n\r\n    // Note: the phases must be in order. Meaning the first enum value must be the first phase, etc.\r\n    // `NUM_PHASES` is to get the number of phases. It isn't an actual phase, and it should always be last.\r\n    enum Phase { Commit, Reveal, NUM_PHASES }\r\n\r\n    /**\r\n     * @notice Commit a vote for a price request for `identifier` at `time`.\r\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\r\n     * Commits can be changed.\r\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the systems expected behavior,\r\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\r\n     * they can determine the vote pre-reveal.\r\n     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\r\n     * @param time unix timestamp of the price being voted on.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\r\n     */\r\n    function commitVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bytes32 hash\r\n    ) public virtual;\r\n\r\n    /**\r\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\r\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\r\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\r\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\r\n     * @param time unix timestamp of for the price request.\r\n     * @param ancillaryData  arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\r\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\r\n     */\r\n    function commitAndEmitEncryptedVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bytes32 hash,\r\n        bytes memory encryptedVote\r\n    ) external virtual;\r\n\r\n    /**\r\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\r\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\r\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\r\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\r\n     * @param time specifies the unix timestamp of the price is being voted on.\r\n     * @param price voted on during the commit phase.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param salt value used to hide the commitment price during the commit phase.\r\n     */\r\n    function revealVote(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes memory ancillaryData,\r\n        int256 salt\r\n    ) public virtual;\r\n\r\n    /**\r\n     * @notice Gets the requests that are being voted on this round.\r\n     * @return pendingRequests array containing identifiers of type PendingRequestAncillaryAugmented.\r\n     */\r\n    function getPendingRequests() external virtual returns (PendingRequestAncillaryAugmented[] memory);\r\n\r\n    /**\r\n     * @notice Returns the current voting phase, as a function of the current time.\r\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES }.\r\n     */\r\n    function getVotePhase() external view virtual returns (Phase);\r\n\r\n    /**\r\n     * @notice Returns the current round ID, as a function of the current time.\r\n     * @return uint256 representing the unique round ID.\r\n     */\r\n    function getCurrentRoundId() external view virtual returns (uint32);\r\n\r\n    // Voting Owner functions.\r\n\r\n    /**\r\n     * @notice Disables this Voting contract in favor of the migrated one.\r\n     * @dev Can only be called by the contract owner.\r\n     * @param newVotingAddress the newly migrated contract address.\r\n     */\r\n    function setMigrated(address newVotingAddress) external virtual;\r\n\r\n    /**\r\n     * @notice Sets the maximum number of rounds to roll a request can have before the DVM auto deletes it.\r\n     * @dev Can only be called by the contract owner.\r\n     * @param newMaxRolls the new number of rounds to roll a request before the DVM auto deletes it.\r\n     */\r\n    function setMaxRolls(uint32 newMaxRolls) external virtual;\r\n\r\n    /**\r\n     * @notice Sets the maximum number of requests that can be made in a single round. Used to bound the maximum\r\n     * sequential slashing that can be applied within a single round.\r\n     * @dev Can only be called by the contract owner.\r\n     * @param newMaxRequestsPerRound the new maximum number of requests that can be made in a single round.\r\n     */\r\n    function setMaxRequestPerRound(uint32 newMaxRequestsPerRound) external virtual;\r\n\r\n    /**\r\n     * @notice Resets the GAT number and SPAT percentage. The GAT is the minimum number of tokens that must participate\r\n     * in a vote for it to resolve (quorum number). The SPAT is is the minimum percentage of tokens that must agree\r\n     * in a vote for it to resolve (percentage of staked tokens) Note: this change only applies to rounds that\r\n     * have not yet begun.\r\n     * @param newGat sets the next round's GAT and going forward.\r\n     * @param newSpat sets the next round's SPAT and going forward.\r\n     */\r\n    function setGatAndSpat(uint128 newGat, uint64 newSpat) external virtual;\r\n\r\n    /**\r\n     * @notice Changes the slashing library used by this contract.\r\n     * @param _newSlashingLibrary new slashing library address.\r\n     */\r\n    function setSlashingLibrary(address _newSlashingLibrary) external virtual;\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/test/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../interfaces/OracleInterface.sol\";\r\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../interfaces/FinderInterface.sol\";\r\nimport \"../implementation/Constants.sol\";\r\n\r\n// A mock oracle used for testing.\r\ncontract MockOracle is OracleInterface, Testable {\r\n    // Represents an available price. Have to keep a separate bool to allow for price=0.\r\n    struct Price {\r\n        bool isAvailable;\r\n        int256 price;\r\n        // Time the verified price became available.\r\n        uint256 verifiedTime;\r\n    }\r\n\r\n    // The two structs below are used in an array and mapping to keep track of prices that have been requested but are\r\n    // not yet available.\r\n    struct QueryIndex {\r\n        bool isValid;\r\n        uint256 index;\r\n    }\r\n\r\n    // Represents a (identifier, time) point that has been queried.\r\n    struct QueryPoint {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n    }\r\n\r\n    // Reference to the Finder.\r\n    FinderInterface private finder;\r\n\r\n    // Maps request IDs to their resolved Price structs.\r\n    mapping(bytes32 => Price) private verifiedPrices;\r\n\r\n    // Maps request IDs to their pending QueryIndex structs.\r\n    mapping(bytes32 => QueryIndex) private queryIndices;\r\n\r\n    // Array of pending QueryPoint structs.\r\n    QueryPoint[] private requestedPrices;\r\n\r\n    event PriceRequestAdded(\r\n        address indexed requester,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes32 indexed requestId\r\n    );\r\n    event PushedPrice(\r\n        address indexed pusher,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes32 indexed requestId\r\n    );\r\n\r\n    constructor(address _finderAddress, address _timerAddress) Testable(_timerAddress) {\r\n        finder = FinderInterface(_finderAddress);\r\n    }\r\n\r\n    // Enqueues a request (if a request isn't already present) for the given (identifier, time) pair.\r\n\r\n    function requestPrice(bytes32 identifier, uint256 time) public override {\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\r\n        bytes32 requestId = _encodePriceRequest(identifier, time);\r\n        Price storage lookup = verifiedPrices[requestId];\r\n        if (!lookup.isAvailable && !queryIndices[requestId].isValid) {\r\n            // New query, enqueue it for review.\r\n            queryIndices[requestId] = QueryIndex(true, requestedPrices.length);\r\n            requestedPrices.push(QueryPoint(identifier, time));\r\n            emit PriceRequestAdded(msg.sender, identifier, time, requestId);\r\n        }\r\n    }\r\n\r\n    // Pushes the verified price for a requested query.\r\n    function pushPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        int256 price\r\n    ) public {\r\n        bytes32 requestId = _encodePriceRequest(identifier, time);\r\n        verifiedPrices[requestId] = Price(true, price, getCurrentTime());\r\n\r\n        QueryIndex storage queryIndex = queryIndices[requestId];\r\n        require(queryIndex.isValid, \"Can't push prices that haven't been requested\");\r\n        // Delete from the array. Instead of shifting the queries over, replace the contents of `indexToReplace` with\r\n        // the contents of the last index (unless it is the last index).\r\n        uint256 indexToReplace = queryIndex.index;\r\n        delete queryIndices[requestId];\r\n        uint256 lastIndex = requestedPrices.length - 1;\r\n        if (lastIndex != indexToReplace) {\r\n            QueryPoint storage queryToCopy = requestedPrices[lastIndex];\r\n            queryIndices[_encodePriceRequest(queryToCopy.identifier, queryToCopy.time)].index = indexToReplace;\r\n            requestedPrices[indexToReplace] = queryToCopy;\r\n        }\r\n        requestedPrices.pop();\r\n\r\n        emit PushedPrice(msg.sender, identifier, time, price, requestId);\r\n    }\r\n\r\n    // Wrapper function to push the verified price by request ID.\r\n    function pushPriceByRequestId(bytes32 requestId, int256 price) external {\r\n        QueryPoint memory queryPoint = getRequestParameters(requestId);\r\n        pushPrice(queryPoint.identifier, queryPoint.time, price);\r\n    }\r\n\r\n    // Checks whether a price has been resolved.\r\n    function hasPrice(bytes32 identifier, uint256 time) public view override returns (bool) {\r\n        Price storage lookup = verifiedPrices[_encodePriceRequest(identifier, time)];\r\n        return lookup.isAvailable;\r\n    }\r\n\r\n    // Gets a price that has already been resolved.\r\n    function getPrice(bytes32 identifier, uint256 time) public view override returns (int256) {\r\n        Price storage lookup = verifiedPrices[_encodePriceRequest(identifier, time)];\r\n        require(lookup.isAvailable);\r\n        return lookup.price;\r\n    }\r\n\r\n    // Gets the queries that still need verified prices.\r\n    function getPendingQueries() external view returns (QueryPoint[] memory) {\r\n        return requestedPrices;\r\n    }\r\n\r\n    // Gets the request parameters by request ID.\r\n    function getRequestParameters(bytes32 requestId) public view returns (QueryPoint memory) {\r\n        QueryIndex storage queryIndex = queryIndices[requestId];\r\n        require(queryIndex.isValid, \"Request ID not found\");\r\n        return requestedPrices[queryIndex.index];\r\n    }\r\n\r\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface supportedIdentifiers) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    // Returns an encoded bytes32 representing a price request ID. Used when storing/referencing price requests.\r\n    function _encodePriceRequest(bytes32 identifier, uint256 time) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(identifier, time));\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/test/MockOracleAncillary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../interfaces/FinderInterface.sol\";\r\nimport \"../implementation/Constants.sol\";\r\n\r\n// A mock oracle used for testing.\r\ncontract MockOracleAncillary is OracleAncillaryInterface, Testable {\r\n    // Represents an available price. Have to keep a separate bool to allow for price=0.\r\n    struct Price {\r\n        bool isAvailable;\r\n        int256 price;\r\n        // Time the verified price became available.\r\n        uint256 verifiedTime;\r\n    }\r\n\r\n    // The two structs below are used in an array and mapping to keep track of prices that have been requested but are\r\n    // not yet available.\r\n    struct QueryIndex {\r\n        bool isValid;\r\n        uint256 index;\r\n    }\r\n\r\n    // Represents a (identifier, time, ancillary data) point that has been queried.\r\n    struct QueryPoint {\r\n        bytes32 identifier;\r\n        uint256 time;\r\n        bytes ancillaryData;\r\n    }\r\n\r\n    // Reference to the Finder.\r\n    FinderInterface private finder;\r\n\r\n    // Maps request IDs to their resolved Price structs.\r\n    mapping(bytes32 => Price) internal verifiedPrices;\r\n\r\n    // Maps request IDs to their pending QueryIndex structs.\r\n    mapping(bytes32 => QueryIndex) internal queryIndices;\r\n\r\n    // Array of pending QueryPoint structs.\r\n    QueryPoint[] internal requestedPrices;\r\n\r\n    event PriceRequestAdded(\r\n        address indexed requester,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        bytes32 indexed requestId\r\n    );\r\n    event PushedPrice(\r\n        address indexed pusher,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        int256 price,\r\n        bytes32 indexed requestId\r\n    );\r\n\r\n    constructor(address _finderAddress, address _timerAddress) Testable(_timerAddress) {\r\n        finder = FinderInterface(_finderAddress);\r\n    }\r\n\r\n    // Enqueues a request (if a request isn't already present) for the given identifier, time and ancillary data.\r\n\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public override {\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\r\n        bytes32 requestId = _encodePriceRequest(identifier, time, ancillaryData);\r\n        Price storage lookup = verifiedPrices[requestId];\r\n        if (!lookup.isAvailable && !queryIndices[requestId].isValid) {\r\n            // New query, enqueue it for review.\r\n            queryIndices[requestId] = QueryIndex(true, requestedPrices.length);\r\n            requestedPrices.push(QueryPoint(identifier, time, ancillaryData));\r\n            emit PriceRequestAdded(msg.sender, identifier, time, ancillaryData, requestId);\r\n        }\r\n    }\r\n\r\n    // Pushes the verified price for a requested query.\r\n    function pushPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) public {\r\n        bytes32 requestId = _encodePriceRequest(identifier, time, ancillaryData);\r\n        verifiedPrices[requestId] = Price(true, price, getCurrentTime());\r\n\r\n        QueryIndex storage queryIndex = queryIndices[requestId];\r\n        require(queryIndex.isValid, \"Can't push prices that haven't been requested\");\r\n        // Delete from the array. Instead of shifting the queries over, replace the contents of `indexToReplace` with\r\n        // the contents of the last index (unless it is the last index).\r\n        uint256 indexToReplace = queryIndex.index;\r\n        delete queryIndices[requestId];\r\n        uint256 lastIndex = requestedPrices.length - 1;\r\n        if (lastIndex != indexToReplace) {\r\n            QueryPoint storage queryToCopy = requestedPrices[lastIndex];\r\n            queryIndices[_encodePriceRequest(queryToCopy.identifier, queryToCopy.time, queryToCopy.ancillaryData)]\r\n                .index = indexToReplace;\r\n            requestedPrices[indexToReplace] = queryToCopy;\r\n        }\r\n        requestedPrices.pop();\r\n\r\n        emit PushedPrice(msg.sender, identifier, time, ancillaryData, price, requestId);\r\n    }\r\n\r\n    // Wrapper function to push the verified price by request ID.\r\n    function pushPriceByRequestId(bytes32 requestId, int256 price) external {\r\n        QueryPoint memory queryPoint = getRequestParameters(requestId);\r\n        pushPrice(queryPoint.identifier, queryPoint.time, queryPoint.ancillaryData, price);\r\n    }\r\n\r\n    // Checks whether a price has been resolved.\r\n    function hasPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override returns (bool) {\r\n        Price storage lookup = verifiedPrices[_encodePriceRequest(identifier, time, ancillaryData)];\r\n        return lookup.isAvailable;\r\n    }\r\n\r\n    // Gets a price that has already been resolved.\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override returns (int256) {\r\n        Price storage lookup = verifiedPrices[_encodePriceRequest(identifier, time, ancillaryData)];\r\n        require(lookup.isAvailable);\r\n        return lookup.price;\r\n    }\r\n\r\n    // Gets the queries that still need verified prices.\r\n    function getPendingQueries() external view returns (QueryPoint[] memory) {\r\n        return requestedPrices;\r\n    }\r\n\r\n    // Gets the request parameters by request ID.\r\n    function getRequestParameters(bytes32 requestId) public view returns (QueryPoint memory) {\r\n        QueryIndex storage queryIndex = queryIndices[requestId];\r\n        require(queryIndex.isValid, \"Request ID not found\");\r\n        return requestedPrices[queryIndex.index];\r\n    }\r\n\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface supportedIdentifiers) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    // Returns an encoded bytes32 representing a price request ID. Used when storing/referencing price requests.\r\n    function _encodePriceRequest(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(identifier, time, ancillaryData));\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/test/MockOracleCombined.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./MockOracleAncillary.sol\";\r\n\r\n// A mock oracle used for testing. Allows both ancillary and non-ancillary methods to be called.\r\ncontract MockOracleCombined is MockOracleAncillary {\r\n    constructor(address _finderAddress, address _timerAddress) MockOracleAncillary(_finderAddress, _timerAddress) {}\r\n\r\n    // Enqueues a request (if a request isn't already present) for the given (identifier, time) pair.\r\n    function requestPrice(bytes32 identifier, uint256 time) public {\r\n        requestPrice(identifier, time, \"\");\r\n    }\r\n\r\n    // Pushes the verified price for a requested query.\r\n    function pushPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        int256 price\r\n    ) external {\r\n        pushPrice(identifier, time, \"\", price);\r\n    }\r\n\r\n    // Checks whether a price has been resolved.\r\n    function hasPrice(bytes32 identifier, uint256 time) public view returns (bool) {\r\n        return hasPrice(identifier, time, \"\");\r\n    }\r\n\r\n    // Gets a price that has already been resolved.\r\n    function getPrice(bytes32 identifier, uint256 time) public view returns (int256) {\r\n        return getPrice(identifier, time, \"\");\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/test/MockOracleGovernance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/OracleGovernanceInterface.sol\";\r\nimport \"./MockOracleAncillary.sol\";\r\n\r\n// A mock oracle used for testing.\r\ncontract MockOracleGovernance is MockOracleAncillary {\r\n    constructor(address _finderAddress, address _timerAddress) MockOracleAncillary(_finderAddress, _timerAddress) {}\r\n\r\n    // Enqueues a governance request (if a request isn't already present) for the given (identifier, time) pair.\r\n    function requestGovernanceAction(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public {\r\n        _requestPrice(identifier, time, ancillaryData, true);\r\n    }\r\n\r\n    function _requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bool isGovernance\r\n    ) internal {\r\n        require(isGovernance || _getIdentifierWhitelist().isIdentifierSupported(identifier));\r\n        bytes32 requestId = _encodePriceRequest(identifier, time, ancillaryData);\r\n        Price storage lookup = verifiedPrices[requestId];\r\n        if (!lookup.isAvailable && !queryIndices[requestId].isValid) {\r\n            // New query, enqueue it for review.\r\n            queryIndices[requestId] = QueryIndex(true, requestedPrices.length);\r\n            QueryPoint memory queryPoint = QueryPoint(identifier, time, ancillaryData);\r\n            requestedPrices.push(queryPoint);\r\n            emit PriceRequestAdded(msg.sender, identifier, time, ancillaryData, requestId);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/test/VotingAncillaryInterfaceTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../interfaces/VotingAncillaryInterface.sol\";\r\n\r\n// A mock oracle used for testing. Exports the voting & oracle interfaces and events that contain ancillary data.\r\nabstract contract VotingAncillaryInterfaceTesting is OracleAncillaryInterface, VotingAncillaryInterface, Testable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    // Events, data structures and functions not exported in the base interfaces, used for testing.\r\n    event VoteCommitted(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData\r\n    );\r\n\r\n    event EncryptedVote(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        bytes encryptedVote\r\n    );\r\n\r\n    event VoteRevealed(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes ancillaryData,\r\n        uint256 numTokens\r\n    );\r\n\r\n    event RewardsRetrieved(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        uint256 numTokens\r\n    );\r\n\r\n    event PriceRequestAdded(uint256 indexed roundId, bytes32 indexed identifier, uint256 time);\r\n\r\n    event PriceResolved(\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes ancillaryData\r\n    );\r\n\r\n    struct Round {\r\n        uint256 snapshotId; // Voting token snapshot ID for this round.  0 if no snapshot has been taken.\r\n        FixedPoint.Unsigned inflationRate; // Inflation rate set for this round.\r\n        FixedPoint.Unsigned gatPercentage; // Gat rate set for this round.\r\n        uint256 rewardsExpirationTime; // Time that rewards for this round can be claimed until.\r\n    }\r\n\r\n    // Represents the status a price request has.\r\n    enum RequestStatus {\r\n        NotRequested, // Was never requested.\r\n        Active, // Is being voted on in the current round.\r\n        Resolved, // Was resolved in a previous round.\r\n        Future // Is scheduled to be voted on in a future round.\r\n    }\r\n\r\n    // Only used as a return value in view methods -- never stored in the contract.\r\n    struct RequestState {\r\n        RequestStatus status;\r\n        uint256 lastVotingRound;\r\n    }\r\n\r\n    function rounds(uint256 roundId) public view virtual returns (Round memory);\r\n\r\n    function getPriceRequestStatuses(VotingAncillaryInterface.PendingRequestAncillary[] memory requests)\r\n        public\r\n        view\r\n        virtual\r\n        returns (RequestState[] memory);\r\n\r\n    function getPendingPriceRequestsArray() external view virtual returns (bytes32[] memory);\r\n}\r\n"
    },
    "contracts/data-verification-mechanism/test/VotingInterfaceTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../interfaces/OracleInterface.sol\";\r\nimport \"../interfaces/VotingInterface.sol\";\r\n\r\n// A mock oracle used for testing. Exports the voting & oracle interfaces and events that contain no ancillary data.\r\nabstract contract VotingInterfaceTesting is OracleInterface, VotingInterface, Testable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    // Events, data structures and functions not exported in the base interfaces, used for testing.\r\n    event VoteCommitted(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData\r\n    );\r\n\r\n    event EncryptedVote(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        bytes encryptedVote\r\n    );\r\n\r\n    event VoteRevealed(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes ancillaryData,\r\n        uint256 numTokens\r\n    );\r\n\r\n    event RewardsRetrieved(\r\n        address indexed voter,\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        uint256 numTokens\r\n    );\r\n\r\n    event PriceRequestAdded(uint256 indexed roundId, bytes32 indexed identifier, uint256 time);\r\n\r\n    event PriceResolved(\r\n        uint256 indexed roundId,\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        int256 price,\r\n        bytes ancillaryData\r\n    );\r\n\r\n    struct Round {\r\n        uint256 snapshotId; // Voting token snapshot ID for this round.  0 if no snapshot has been taken.\r\n        FixedPoint.Unsigned inflationRate; // Inflation rate set for this round.\r\n        FixedPoint.Unsigned gatPercentage; // Gat rate set for this round.\r\n        uint256 rewardsExpirationTime; // Time that rewards for this round can be claimed until.\r\n    }\r\n\r\n    // Represents the status a price request has.\r\n    enum RequestStatus {\r\n        NotRequested, // Was never requested.\r\n        Active, // Is being voted on in the current round.\r\n        Resolved, // Was resolved in a previous round.\r\n        Future // Is scheduled to be voted on in a future round.\r\n    }\r\n\r\n    // Only used as a return value in view methods -- never stored in the contract.\r\n    struct RequestState {\r\n        RequestStatus status;\r\n        uint256 lastVotingRound;\r\n    }\r\n\r\n    function rounds(uint256 roundId) public view virtual returns (Round memory);\r\n\r\n    function getPriceRequestStatuses(VotingInterface.PendingRequest[] memory requests)\r\n        public\r\n        view\r\n        virtual\r\n        returns (RequestState[] memory);\r\n\r\n    function getPendingPriceRequestsArray() external view virtual returns (bytes32[] memory);\r\n}\r\n"
    },
    "contracts/external/avm/Arbitrum_CrossDomainEnabled.sol": {
      "content": "// Copied logic from https://github.com/makerdao/arbitrum-dai-bridge/blob/34acc39bc6f3a2da0a837ea3c5dbc634ec61c7de/contracts/l1/L1CrossDomainEnabled.sol\r\n// with a change to the solidity version.\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../external/avm/interfaces/iArbitrum_Inbox.sol\";\r\nimport \"../../external/avm/interfaces/iArbitrum_Outbox.sol\";\r\n\r\nabstract contract Arbitrum_CrossDomainEnabled {\r\n    iArbitrum_Inbox public immutable inbox;\r\n\r\n    /**\r\n     * @param _inbox Contract that sends generalized messages to the Arbitrum chain.\r\n     */\r\n    constructor(address _inbox) {\r\n        inbox = iArbitrum_Inbox(_inbox);\r\n    }\r\n\r\n    // More details about retryable ticket parameters here: https://developer.offchainlabs.com/docs/l1_l2_messages#parameters\r\n    // This function will not apply aliassing to the `user` address on L2.\r\n    // Note: If `l1CallValue > 0`, then this contract must contain at least that much ETH to send as msg.value to the\r\n    // inbox.\r\n    function sendTxToL2NoAliassing(\r\n        address target, // Address where transaction will initiate on L2.\r\n        address user, // Address where excess gas is credited on L2.\r\n        uint256 l1CallValue, // msg.value deposited to `user` on L2.\r\n        uint256 maxSubmissionCost, // Amount of ETH allocated to pay for base submission fee. The user is charged this\r\n        // fee to cover the storage costs of keeping their retryable ticket's calldata in the retry buffer. This should\r\n        // also cover the `l2CallValue`, but we set that to 0. This amount is proportional to the size of `data`.\r\n        uint256 maxGas, // Gas limit for immediate L2 execution attempt.\r\n        uint256 gasPriceBid, // L2 gas price bid for immediate L2 execution attempt.\r\n        bytes memory data // ABI encoded data to send to target.\r\n    ) internal returns (uint256) {\r\n        // createRetryableTicket API: https://developer.offchainlabs.com/docs/sol_contract_docs/md_docs/arb-bridge-eth/bridge/inbox#createretryableticketaddress-destaddr-uint256-l2callvalue-uint256-maxsubmissioncost-address-excessfeerefundaddress-address-callvaluerefundaddress-uint256-maxgas-uint256-gaspricebid-bytes-data-%E2%86%92-uint256-external\r\n        // - address destAddr: destination L2 contract address\r\n        // - uint256 l2CallValue: call value for retryable L2 message\r\n        // - uint256 maxSubmissionCost: Max gas deducted from user's L2 balance to cover base submission fee\r\n        // - address excessFeeRefundAddress: maxgas x gasprice - execution cost gets credited here on L2\r\n        // - address callValueRefundAddress: l2CallValue gets credited here on L2 if retryable txn times out or gets cancelled\r\n        // - uint256 maxGas: Max gas deducted from user's L2 balance to cover L2 execution\r\n        // - uint256 gasPriceBid: price bid for L2 execution\r\n        // - bytes data: ABI encoded data of L2 message\r\n        uint256 seqNum =\r\n            inbox.createRetryableTicketNoRefundAliasRewrite{ value: l1CallValue }(\r\n                target,\r\n                0, // we always assume that l2CallValue = 0\r\n                maxSubmissionCost,\r\n                user,\r\n                user,\r\n                maxGas,\r\n                gasPriceBid,\r\n                data\r\n            );\r\n        return seqNum;\r\n    }\r\n\r\n    // Copied mostly from: https://github.com/makerdao/arbitrum-dai-bridge/blob/34acc39bc6f3a2da0a837ea3c5dbc634ec61c7de/contracts/l1/L1CrossDomainEnabled.sol#L31\r\n    modifier onlyFromCrossDomainAccount(address l2Counterpart) {\r\n        // a message coming from the counterpart gateway was executed by the bridge\r\n        IBridge bridge = IBridge(inbox.bridge());\r\n        require(msg.sender == address(bridge), \"NOT_FROM_BRIDGE\");\r\n\r\n        // and the outbox reports that the L2 address of the sender is the counterpart gateway\r\n        address l2ToL1Sender = iArbitrum_Outbox(bridge.activeOutbox()).l2ToL1Sender();\r\n        require(l2ToL1Sender == l2Counterpart, \"ONLY_COUNTERPART_GATEWAY\");\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/external/avm/Arbitrum_Messenger.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Arbitrum_CrossDomainEnabled.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @notice Sends cross chain messages Arbitrum L2 network.\r\n * @dev This contract's owner should be set to the BridgeAdmin deployed on the same L1 network so that only the\r\n * BridgeAdmin can call cross-chain administrative functions on the L2 DepositBox via this messenger.\r\n * @dev This address will be the sender of any L1 --> L2 retryable tickets, so it should be set as the cross domain\r\n * owner for L2 contracts that expect to receive cross domain messages.\r\n */\r\ncontract Arbitrum_Messenger is Ownable, Arbitrum_CrossDomainEnabled {\r\n    event RelayedMessage(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed seqNum,\r\n        address userToRefund,\r\n        uint256 l1CallValue,\r\n        uint256 gasLimit,\r\n        uint256 gasPrice,\r\n        uint256 maxSubmissionCost,\r\n        bytes data\r\n    );\r\n\r\n    /**\r\n     * @param _inbox Contract that sends generalized messages to the Arbitrum chain.\r\n     */\r\n    constructor(address _inbox) Arbitrum_CrossDomainEnabled(_inbox) {}\r\n\r\n    /**\r\n     * @notice Sends a message to an account on L2. If this message reverts on l2 for any reason it can either be\r\n     * resent on L1, or redeemed on L2 manually. To learn more see how \"retryable tickets\" work on Arbitrum\r\n     * https://developer.offchainlabs.com/docs/l1_l2_messages#parameters\r\n     * @param target The intended recipient on L2.\r\n     * @param userToRefund User on L2 to refund extra fees to.\r\n     * @param l1CallValue Amount of ETH deposited to `target` contract on L2. Used to pay for L2 submission fee and\r\n     * l2CallValue. This will usually be > 0.\r\n     * @param gasLimit The gasLimit for the receipt of the message on L2.\r\n     * @param gasPrice Gas price bid for L2 execution.\r\n     * @param maxSubmissionCost: Max gas deducted from user's L2 balance to cover base submission fee.\r\n     * This amount is proportional to the size of `data`.\r\n     * @param message The data to send to the target (usually calldata to a function with\r\n     *  `onlyFromCrossDomainAccount()`)\r\n     */\r\n    function relayMessage(\r\n        address target,\r\n        address userToRefund,\r\n        uint256 l1CallValue,\r\n        uint256 gasLimit,\r\n        uint256 gasPrice,\r\n        uint256 maxSubmissionCost,\r\n        bytes memory message\r\n    ) external payable onlyOwner {\r\n        // Since we know the L2 target's address in advance, we don't need to alias an L1 address.\r\n        uint256 seqNumber =\r\n            sendTxToL2NoAliassing(target, userToRefund, l1CallValue, maxSubmissionCost, gasLimit, gasPrice, message);\r\n        emit RelayedMessage(\r\n            msg.sender,\r\n            target,\r\n            seqNumber,\r\n            userToRefund,\r\n            l1CallValue,\r\n            gasLimit,\r\n            gasPrice,\r\n            maxSubmissionCost,\r\n            message\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/external/avm/AVM_CrossDomainEnabled.sol": {
      "content": "// Copied logic from https://github.com/makerdao/arbitrum-dai-bridge/blob/34acc39bc6f3a2da0a837ea3c5dbc634ec61c7de/contracts/l2/L2CrossDomainEnabled.sol\r\n// with a change to the solidity version.\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./interfaces/ArbSys.sol\";\r\n\r\nabstract contract AVM_CrossDomainEnabled {\r\n    event SentCrossDomainMessage(address indexed from, address indexed to, uint256 indexed id, bytes data);\r\n\r\n    modifier onlyFromCrossDomainAccount(address l1Counterpart) {\r\n        require(msg.sender == applyL1ToL2Alias(l1Counterpart), \"ONLY_COUNTERPART_GATEWAY\");\r\n        _;\r\n    }\r\n\r\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\r\n\r\n    // l1 addresses are transformed during l1->l2 calls. See https://developer.offchainlabs.com/docs/l1_l2_messages#address-aliasing for more information.\r\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\r\n        l2Address = address(uint160(l1Address) + offset);\r\n    }\r\n\r\n    // Sends a message to L1 via the ArbSys contract. See https://developer.offchainlabs.com/docs/arbsys.\r\n    // After the Arbitrum chain advances some set amount of time, ArbOS gathers all outgoing messages, Merklizes them,\r\n    // and publishes the root as an OutboxEntry in the chain's outbox. Note that this happens \"automatically\";\r\n    // i.e., it requires no additional action from the user. After the Outbox entry is published on the L1 chain,\r\n    // the user (or anybody) can compute the Merkle proof of inclusion of their outgoing message. Anytime after the\r\n    // dispute window passes (~7 days), any user can execute the L1 message by calling Outbox.executeTransaction;\r\n    // if it reverts, it can be re-executed any number of times and with no upper time-bound.\r\n    // To read more about the L2 --> L1 lifecycle, see: https://developer.offchainlabs.com/docs/l1_l2_messages#explanation.\r\n    function sendCrossDomainMessage(\r\n        address user,\r\n        address to,\r\n        bytes memory data\r\n    ) internal returns (uint256) {\r\n        // note: this method doesn't support sending ether to L1 together with a call\r\n        uint256 id = ArbSys(address(100)).sendTxToL1(to, data);\r\n\r\n        emit SentCrossDomainMessage(user, to, id, data);\r\n\r\n        return id;\r\n    }\r\n}\r\n"
    },
    "contracts/external/avm/interfaces/ArbSys.sol": {
      "content": "// Copied logic from https://github.com/makerdao/arbitrum-dai-bridge/blob/54a2109a97c5b1504824c6317d358e2d2733b5a3/contracts/arbitrum/ArbSys.sol\r\n// with changes only to the solidity version and comments.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @notice Precompiled contract that exists in every Arbitrum chain at address(100),\r\n * 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality. ArbSys provides\r\n * systems functionality useful to some Arbitrum contracts. Any contract running on an Arbitrum Chain can call the\r\n * chain's ArbSys.\r\n */\r\ninterface ArbSys {\r\n    /**\r\n     * @notice Get internal version number identifying an ArbOS build\r\n     * @return version number as int\r\n     */\r\n    function arbOSVersion() external pure returns (uint256);\r\n\r\n    function arbChainID() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\r\n     * @return block number as int\r\n     */\r\n    function arbBlockNumber() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Send given amount of Eth to dest from sender.\r\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\r\n     * @param destination recipient address on L1\r\n     * @return unique identifier for this L2-to-L1 transaction.\r\n     */\r\n    function withdrawEth(address destination) external payable returns (uint256);\r\n\r\n    /**\r\n     * @notice Send a transaction to L1\r\n     * @param destination recipient address on L1\r\n     * @param calldataForL1 (optional) calldata for L1 contract call\r\n     * @return a unique identifier for this L2-to-L1 transaction.\r\n     */\r\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint256);\r\n\r\n    /**\r\n     * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\r\n     * @param account target account\r\n     * @return the number of transactions issued by the given external account or the account sequence number of the given contract\r\n     */\r\n    function getTransactionCount(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice get the value of target L2 storage slot\r\n     * This function is only callable from address 0 to prevent contracts from being able to call it\r\n     * @param account target account\r\n     * @param index target index of storage slot\r\n     * @return stotage value for the given account at the given index\r\n     */\r\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice check if current call is coming from l1\r\n     * @return true if the caller of this was called directly from L1\r\n     */\r\n    function isTopLevelCall() external view returns (bool);\r\n\r\n    event EthWithdrawal(address indexed destAddr, uint256 amount);\r\n\r\n    event L2ToL1Transaction(\r\n        address caller,\r\n        address indexed destination,\r\n        uint256 indexed uniqueId,\r\n        uint256 indexed batchNumber,\r\n        uint256 indexInBatch,\r\n        uint256 arbBlockNum,\r\n        uint256 ethBlockNum,\r\n        uint256 timestamp,\r\n        uint256 callvalue,\r\n        bytes data\r\n    );\r\n}\r\n"
    },
    "contracts/external/avm/interfaces/iArbitrum_Inbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBridge {\r\n    function activeOutbox() external view returns (address);\r\n}\r\n\r\ninterface iArbitrum_Inbox {\r\n    // Retryable tickets are the Arbitrum protocols canonical method for passing generalized messages from Ethereum to\r\n    // Arbitrum. A retryable ticket is an L2 message encoded and delivered by L1; if gas is provided, it will be executed\r\n    // immediately. If no gas is provided or the execution reverts, it will be placed in the L2 retry buffer,\r\n    // where any user can re-execute for some fixed period (roughly one week).\r\n    // Retryable tickets are created by calling Inbox.createRetryableTicket.\r\n    // More details here: https://developer.offchainlabs.com/docs/l1_l2_messages#ethereum-to-arbitrum-retryable-tickets\r\n    function createRetryableTicketNoRefundAliasRewrite(\r\n        address destAddr,\r\n        uint256 l2CallValue,\r\n        uint256 maxSubmissionCost,\r\n        address excessFeeRefundAddress,\r\n        address callValueRefundAddress,\r\n        uint256 maxGas,\r\n        uint256 gasPriceBid,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    function bridge() external view returns (address);\r\n}\r\n"
    },
    "contracts/external/avm/interfaces/iArbitrum_Outbox.sol": {
      "content": "// Copied logic from https://github.com/OffchainLabs/arbitrum-tutorials/blob/4761fa1ba1f1eca95e8c03f24f1442ed5aecd8bd/packages/arb-shared-dependencies/contracts/Outbox.sol\r\n// with changes only to the solidity version.\r\n\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2021, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface iArbitrum_Outbox {\r\n    function l2ToL1Sender() external view returns (address);\r\n}\r\n"
    },
    "contracts/external/boba/BobaAddressManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nabstract contract BobaAddressManager {\r\n    /**\r\n     * Retrieves the address associated with a given name.\r\n     * @param _name Name to retrieve an address for.\r\n     * @return Address associated with the given name.\r\n     */\r\n    function getAddress(string memory _name) external view virtual returns (address);\r\n}\r\n"
    },
    "contracts/external/chainbridge/Bridge.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./interfaces/IDepositExecute.sol\";\r\nimport \"./interfaces/IBridge.sol\";\r\nimport \"./interfaces/IERCHandler.sol\";\r\nimport \"./interfaces/IGenericHandler.sol\";\r\n\r\n/**\r\n    @title Facilitates deposits, creation and votiing of deposit proposals, and deposit executions.\r\n    @author ChainSafe Systems.\r\n */\r\ncontract Bridge is Pausable, AccessControl {\r\n    using SafeMath for uint256;\r\n\r\n    uint8 public _chainID;\r\n    uint256 public _relayerThreshold;\r\n    uint256 public _totalRelayers;\r\n    uint256 public _totalProposals;\r\n    uint256 public _fee;\r\n    uint256 public _expiry;\r\n\r\n    enum Vote { No, Yes }\r\n\r\n    enum ProposalStatus { Inactive, Active, Passed, Executed, Cancelled }\r\n\r\n    struct Proposal {\r\n        bytes32 _resourceID;\r\n        bytes32 _dataHash;\r\n        address[] _yesVotes;\r\n        address[] _noVotes;\r\n        ProposalStatus _status;\r\n        uint256 _proposedBlock;\r\n    }\r\n\r\n    // destinationChainID => number of deposits\r\n    mapping(uint8 => uint64) public _depositCounts;\r\n    // resourceID => handler address\r\n    mapping(bytes32 => address) public _resourceIDToHandlerAddress;\r\n    // depositNonce => destinationChainID => bytes\r\n    mapping(uint64 => mapping(uint8 => bytes)) public _depositRecords;\r\n    // destinationChainID + depositNonce => dataHash => Proposal\r\n    mapping(uint72 => mapping(bytes32 => Proposal)) public _proposals;\r\n    // destinationChainID + depositNonce => dataHash => relayerAddress => bool\r\n    mapping(uint72 => mapping(bytes32 => mapping(address => bool))) public _hasVotedOnProposal;\r\n\r\n    event RelayerThresholdChanged(uint256 indexed newThreshold);\r\n    event RelayerAdded(address indexed relayer);\r\n    event RelayerRemoved(address indexed relayer);\r\n    event Deposit(uint8 indexed destinationChainID, bytes32 indexed resourceID, uint64 indexed depositNonce);\r\n    event ProposalEvent(\r\n        uint8 indexed originChainID,\r\n        uint64 indexed depositNonce,\r\n        ProposalStatus indexed status,\r\n        bytes32 resourceID,\r\n        bytes32 dataHash\r\n    );\r\n\r\n    event ProposalVote(\r\n        uint8 indexed originChainID,\r\n        uint64 indexed depositNonce,\r\n        ProposalStatus indexed status,\r\n        bytes32 resourceID\r\n    );\r\n\r\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\r\n\r\n    modifier onlyAdmin() {\r\n        _onlyAdmin();\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdminOrRelayer() {\r\n        _onlyAdminOrRelayer();\r\n        _;\r\n    }\r\n\r\n    modifier onlyRelayers() {\r\n        _onlyRelayers();\r\n        _;\r\n    }\r\n\r\n    function _onlyAdminOrRelayer() private view {\r\n        require(\r\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) || hasRole(RELAYER_ROLE, msg.sender),\r\n            \"sender is not relayer or admin\"\r\n        );\r\n    }\r\n\r\n    function _onlyAdmin() private view {\r\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"sender doesn't have admin role\");\r\n    }\r\n\r\n    function _onlyRelayers() private view {\r\n        require(hasRole(RELAYER_ROLE, msg.sender), \"sender doesn't have relayer role\");\r\n    }\r\n\r\n    /**\r\n        @notice Initializes Bridge, creates and grants {msg.sender} the admin role,\r\n        creates and grants {initialRelayers} the relayer role.\r\n        @param chainID ID of chain the Bridge contract exists on.\r\n        @param initialRelayers Addresses that should be initially granted the relayer role.\r\n        @param initialRelayerThreshold Number of votes needed for a deposit proposal to be considered passed.\r\n     */\r\n    constructor(\r\n        uint8 chainID,\r\n        address[] memory initialRelayers,\r\n        uint256 initialRelayerThreshold,\r\n        uint256 fee,\r\n        uint256 expiry\r\n    ) {\r\n        _chainID = chainID;\r\n        _relayerThreshold = initialRelayerThreshold;\r\n        _fee = fee;\r\n        _expiry = expiry;\r\n\r\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _setRoleAdmin(RELAYER_ROLE, DEFAULT_ADMIN_ROLE);\r\n\r\n        for (uint256 i; i < initialRelayers.length; i++) {\r\n            grantRole(RELAYER_ROLE, initialRelayers[i]);\r\n            _totalRelayers++;\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Returns true if {relayer} has the relayer role.\r\n        @param relayer Address to check.\r\n     */\r\n    function isRelayer(address relayer) external view returns (bool) {\r\n        return hasRole(RELAYER_ROLE, relayer);\r\n    }\r\n\r\n    /**\r\n        @notice Removes admin role from {msg.sender} and grants it to {newAdmin}.\r\n        @notice Only callable by an address that currently has the admin role.\r\n        @param newAdmin Address that admin role will be granted to.\r\n     */\r\n    function renounceAdmin(address newAdmin) external onlyAdmin {\r\n        grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\r\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n    }\r\n\r\n    /**\r\n        @notice Pauses deposits, proposal creation and voting, and deposit executions.\r\n        @notice Only callable by an address that currently has the admin role.\r\n     */\r\n    function adminPauseTransfers() external onlyAdmin {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n        @notice Unpauses deposits, proposal creation and voting, and deposit executions.\r\n        @notice Only callable by an address that currently has the admin role.\r\n     */\r\n    function adminUnpauseTransfers() external onlyAdmin {\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n        @notice Modifies the number of votes required for a proposal to be considered passed.\r\n        @notice Only callable by an address that currently has the admin role.\r\n        @param newThreshold Value {_relayerThreshold} will be changed to.\r\n        @notice Emits {RelayerThresholdChanged} event.\r\n     */\r\n    function adminChangeRelayerThreshold(uint256 newThreshold) external onlyAdmin {\r\n        _relayerThreshold = newThreshold;\r\n        emit RelayerThresholdChanged(newThreshold);\r\n    }\r\n\r\n    /**\r\n        @notice Grants {relayerAddress} the relayer role and increases {_totalRelayer} count.\r\n        @notice Only callable by an address that currently has the admin role.\r\n        @param relayerAddress Address of relayer to be added.\r\n        @notice Emits {RelayerAdded} event.\r\n     */\r\n    function adminAddRelayer(address relayerAddress) external onlyAdmin {\r\n        require(!hasRole(RELAYER_ROLE, relayerAddress), \"addr already has relayer role!\");\r\n        grantRole(RELAYER_ROLE, relayerAddress);\r\n        emit RelayerAdded(relayerAddress);\r\n        _totalRelayers++;\r\n    }\r\n\r\n    /**\r\n        @notice Removes relayer role for {relayerAddress} and decreases {_totalRelayer} count.\r\n        @notice Only callable by an address that currently has the admin role.\r\n        @param relayerAddress Address of relayer to be removed.\r\n        @notice Emits {RelayerRemoved} event.\r\n     */\r\n    function adminRemoveRelayer(address relayerAddress) external onlyAdmin {\r\n        require(hasRole(RELAYER_ROLE, relayerAddress), \"addr doesn't have relayer role!\");\r\n        revokeRole(RELAYER_ROLE, relayerAddress);\r\n        emit RelayerRemoved(relayerAddress);\r\n        _totalRelayers--;\r\n    }\r\n\r\n    /**\r\n        @notice Sets a new resource for handler contracts that use the IERCHandler interface,\r\n        and maps the {handlerAddress} to {resourceID} in {_resourceIDToHandlerAddress}.\r\n        @notice Only callable by an address that currently has the admin role.\r\n        @param handlerAddress Address of handler resource will be set for.\r\n        @param resourceID ResourceID to be used when making deposits.\r\n        @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.\r\n     */\r\n    function adminSetResource(\r\n        address handlerAddress,\r\n        bytes32 resourceID,\r\n        address tokenAddress\r\n    ) external onlyAdmin {\r\n        _resourceIDToHandlerAddress[resourceID] = handlerAddress;\r\n        IERCHandler handler = IERCHandler(handlerAddress);\r\n        handler.setResource(resourceID, tokenAddress);\r\n    }\r\n\r\n    /**\r\n        @notice Sets a new resource for handler contracts that use the IGenericHandler interface,\r\n        and maps the {handlerAddress} to {resourceID} in {_resourceIDToHandlerAddress}.\r\n        @notice Only callable by an address that currently has the admin role.\r\n        @param handlerAddress Address of handler resource will be set for.\r\n        @param resourceID ResourceID to be used when making deposits.\r\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\r\n     */\r\n    function adminSetGenericResource(\r\n        address handlerAddress,\r\n        bytes32 resourceID,\r\n        address contractAddress,\r\n        bytes4 depositFunctionSig,\r\n        bytes4 executeFunctionSig\r\n    ) external onlyAdmin {\r\n        _resourceIDToHandlerAddress[resourceID] = handlerAddress;\r\n        IGenericHandler handler = IGenericHandler(handlerAddress);\r\n        handler.setResource(resourceID, contractAddress, depositFunctionSig, executeFunctionSig);\r\n    }\r\n\r\n    /**\r\n        @notice Sets a resource as burnable for handler contracts that use the IERCHandler interface.\r\n        @notice Only callable by an address that currently has the admin role.\r\n        @param handlerAddress Address of handler resource will be set for.\r\n        @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.\r\n     */\r\n    function adminSetBurnable(address handlerAddress, address tokenAddress) external onlyAdmin {\r\n        IERCHandler handler = IERCHandler(handlerAddress);\r\n        handler.setBurnable(tokenAddress);\r\n    }\r\n\r\n    /**\r\n        @notice Returns a proposal.\r\n        @param originChainID Chain ID deposit originated from.\r\n        @param depositNonce ID of proposal generated by proposal's origin Bridge contract.\r\n        @param dataHash Hash of data to be provided when deposit proposal is executed.\r\n        @return Proposal which consists of:\r\n        - _dataHash Hash of data to be provided when deposit proposal is executed.\r\n        - _yesVotes Number of votes in favor of proposal.\r\n        - _noVotes Number of votes against proposal.\r\n        - _status Current status of proposal.\r\n     */\r\n    function getProposal(\r\n        uint8 originChainID,\r\n        uint64 depositNonce,\r\n        bytes32 dataHash\r\n    ) external view returns (Proposal memory) {\r\n        uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(originChainID);\r\n        return _proposals[nonceAndID][dataHash];\r\n    }\r\n\r\n    /**\r\n        @notice Changes deposit fee.\r\n        @notice Only callable by admin.\r\n        @param newFee Value {_fee} will be updated to.\r\n     */\r\n    function adminChangeFee(uint256 newFee) external onlyAdmin {\r\n        require(_fee != newFee, \"Current fee is equal to new fee\");\r\n        _fee = newFee;\r\n    }\r\n\r\n    /**\r\n        @notice Used to manually withdraw funds from ERC safes.\r\n        @param handlerAddress Address of handler to withdraw from.\r\n        @param tokenAddress Address of token to withdraw.\r\n        @param recipient Address to withdraw tokens to.\r\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to withdraw.\r\n     */\r\n    function adminWithdraw(\r\n        address handlerAddress,\r\n        address tokenAddress,\r\n        address recipient,\r\n        uint256 amountOrTokenID\r\n    ) external onlyAdmin {\r\n        IERCHandler handler = IERCHandler(handlerAddress);\r\n        handler.withdraw(tokenAddress, recipient, amountOrTokenID);\r\n    }\r\n\r\n    /**\r\n        @notice Initiates a transfer using a specified handler contract.\r\n        @notice Only callable when Bridge is not paused.\r\n        @param destinationChainID ID of chain deposit will be bridged to.\r\n        @param resourceID ResourceID used to find address of handler to be used for deposit.\r\n        @param data Additional data to be passed to specified handler.\r\n        @notice Emits {Deposit} event.\r\n     */\r\n    function deposit(\r\n        uint8 destinationChainID,\r\n        bytes32 resourceID,\r\n        bytes calldata data\r\n    ) external payable whenNotPaused {\r\n        require(msg.value == _fee, \"Incorrect fee supplied\");\r\n\r\n        address handler = _resourceIDToHandlerAddress[resourceID];\r\n        require(handler != address(0), \"resourceID not mapped to handler\");\r\n\r\n        uint64 depositNonce = ++_depositCounts[destinationChainID];\r\n        _depositRecords[depositNonce][destinationChainID] = data;\r\n\r\n        IDepositExecute depositHandler = IDepositExecute(handler);\r\n        depositHandler.deposit(resourceID, destinationChainID, depositNonce, msg.sender, data);\r\n\r\n        emit Deposit(destinationChainID, resourceID, depositNonce);\r\n    }\r\n\r\n    /**\r\n        @notice When called, {msg.sender} will be marked as voting in favor of proposal.\r\n        @notice Only callable by relayers when Bridge is not paused.\r\n        @param chainID ID of chain deposit originated from.\r\n        @param depositNonce ID of deposited generated by origin Bridge contract.\r\n        @param dataHash Hash of data provided when deposit was made.\r\n        @notice Proposal must not have already been passed or executed.\r\n        @notice {msg.sender} must not have already voted on proposal.\r\n        @notice Emits {ProposalEvent} event with status indicating the proposal status.\r\n        @notice Emits {ProposalVote} event.\r\n     */\r\n    function voteProposal(\r\n        uint8 chainID,\r\n        uint64 depositNonce,\r\n        bytes32 resourceID,\r\n        bytes32 dataHash\r\n    ) external onlyRelayers whenNotPaused {\r\n        uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(chainID);\r\n        Proposal storage proposal = _proposals[nonceAndID][dataHash];\r\n\r\n        require(_resourceIDToHandlerAddress[resourceID] != address(0), \"no handler for resourceID\");\r\n        require(uint256(proposal._status) <= 1, \"proposal already passed/executed/cancelled\");\r\n        require(!_hasVotedOnProposal[nonceAndID][dataHash][msg.sender], \"relayer already voted\");\r\n\r\n        if (uint256(proposal._status) == 0) {\r\n            ++_totalProposals;\r\n            _proposals[nonceAndID][dataHash] = Proposal({\r\n                _resourceID: resourceID,\r\n                _dataHash: dataHash,\r\n                _yesVotes: new address[](1),\r\n                _noVotes: new address[](0),\r\n                _status: ProposalStatus.Active,\r\n                _proposedBlock: block.number\r\n            });\r\n\r\n            proposal._yesVotes[0] = msg.sender;\r\n            emit ProposalEvent(chainID, depositNonce, ProposalStatus.Active, resourceID, dataHash);\r\n        } else {\r\n            if (block.number.sub(proposal._proposedBlock) > _expiry) {\r\n                // if the number of blocks that has passed since this proposal was\r\n                // submitted exceeds the expiry threshold set, cancel the proposal\r\n                proposal._status = ProposalStatus.Cancelled;\r\n                emit ProposalEvent(chainID, depositNonce, ProposalStatus.Cancelled, resourceID, dataHash);\r\n            } else {\r\n                require(dataHash == proposal._dataHash, \"datahash mismatch\");\r\n                proposal._yesVotes.push(msg.sender);\r\n            }\r\n        }\r\n        if (proposal._status != ProposalStatus.Cancelled) {\r\n            _hasVotedOnProposal[nonceAndID][dataHash][msg.sender] = true;\r\n            emit ProposalVote(chainID, depositNonce, proposal._status, resourceID);\r\n\r\n            // If _depositThreshold is set to 1, then auto finalize\r\n            // or if _relayerThreshold has been exceeded\r\n            if (_relayerThreshold <= 1 || proposal._yesVotes.length >= _relayerThreshold) {\r\n                proposal._status = ProposalStatus.Passed;\r\n\r\n                emit ProposalEvent(chainID, depositNonce, ProposalStatus.Passed, resourceID, dataHash);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Executes a deposit proposal that is considered passed using a specified handler contract.\r\n        @notice Only callable by relayers when Bridge is not paused.\r\n        @param chainID ID of chain deposit originated from.\r\n        @param depositNonce ID of deposited generated by origin Bridge contract.\r\n        @param dataHash Hash of data originally provided when deposit was made.\r\n        @notice Proposal must be past expiry threshold.\r\n        @notice Emits {ProposalEvent} event with status {Cancelled}.\r\n     */\r\n    function cancelProposal(\r\n        uint8 chainID,\r\n        uint64 depositNonce,\r\n        bytes32 dataHash\r\n    ) public onlyAdminOrRelayer {\r\n        uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(chainID);\r\n        Proposal storage proposal = _proposals[nonceAndID][dataHash];\r\n\r\n        require(proposal._status != ProposalStatus.Cancelled, \"Proposal already cancelled\");\r\n        require(block.number.sub(proposal._proposedBlock) > _expiry, \"Proposal not at expiry threshold\");\r\n\r\n        proposal._status = ProposalStatus.Cancelled;\r\n        emit ProposalEvent(chainID, depositNonce, ProposalStatus.Cancelled, proposal._resourceID, proposal._dataHash);\r\n    }\r\n\r\n    /**\r\n        @notice Executes a deposit proposal that is considered passed using a specified handler contract.\r\n        @notice Only callable by relayers when Bridge is not paused.\r\n        @param chainID ID of chain deposit originated from.\r\n        @param resourceID ResourceID to be used when making deposits.\r\n        @param depositNonce ID of deposited generated by origin Bridge contract.\r\n        @param data Data originally provided when deposit was made.\r\n        @notice Proposal must have Passed status.\r\n        @notice Hash of {data} must equal proposal's {dataHash}.\r\n        @notice Emits {ProposalEvent} event with status {Executed}.\r\n     */\r\n    function executeProposal(\r\n        uint8 chainID,\r\n        uint64 depositNonce,\r\n        bytes calldata data,\r\n        bytes32 resourceID\r\n    ) external onlyRelayers whenNotPaused {\r\n        address handler = _resourceIDToHandlerAddress[resourceID];\r\n        uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(chainID);\r\n        bytes32 dataHash = keccak256(abi.encodePacked(handler, data));\r\n        Proposal storage proposal = _proposals[nonceAndID][dataHash];\r\n\r\n        require(proposal._status != ProposalStatus.Inactive, \"proposal is not active\");\r\n        require(proposal._status == ProposalStatus.Passed, \"proposal already transferred\");\r\n        require(dataHash == proposal._dataHash, \"data doesn't match datahash\");\r\n\r\n        proposal._status = ProposalStatus.Executed;\r\n\r\n        IDepositExecute depositHandler = IDepositExecute(_resourceIDToHandlerAddress[proposal._resourceID]);\r\n        depositHandler.executeProposal(proposal._resourceID, data);\r\n\r\n        emit ProposalEvent(chainID, depositNonce, proposal._status, proposal._resourceID, proposal._dataHash);\r\n    }\r\n\r\n    /**\r\n        @notice Transfers eth in the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1.\r\n        This means that the address at index 0 for addrs will receive the amount (in WEI) from amounts at index 0.\r\n        @param addrs Array of addresses to transfer {amounts} to.\r\n        @param amounts Array of amonuts to transfer to {addrs}.\r\n     */\r\n    function transferFunds(address payable[] calldata addrs, uint256[] calldata amounts) external onlyAdmin {\r\n        for (uint256 i = 0; i < addrs.length; i++) {\r\n            addrs[i].transfer(amounts[i]);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/external/chainbridge/handlers/GenericHandler.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/IGenericHandler.sol\";\r\n\r\n/**\r\n    @title Handles generic deposits and deposit executions.\r\n    @author ChainSafe Systems.\r\n    @notice This contract is intended to be used with the Bridge contract.\r\n */\r\ncontract GenericHandler is IGenericHandler {\r\n    address public _bridgeAddress;\r\n\r\n    struct DepositRecord {\r\n        uint8 _destinationChainID;\r\n        address _depositer;\r\n        bytes32 _resourceID;\r\n        bytes _metaData;\r\n    }\r\n\r\n    // depositNonce => Deposit Record\r\n    mapping(uint8 => mapping(uint64 => DepositRecord)) public _depositRecords;\r\n\r\n    // resourceID => contract address\r\n    mapping(bytes32 => address) public _resourceIDToContractAddress;\r\n\r\n    // contract address => resourceID\r\n    mapping(address => bytes32) public _contractAddressToResourceID;\r\n\r\n    // contract address => deposit function signature\r\n    mapping(address => bytes4) public _contractAddressToDepositFunctionSignature;\r\n\r\n    // contract address => execute proposal function signature\r\n    mapping(address => bytes4) public _contractAddressToExecuteFunctionSignature;\r\n\r\n    // token contract address => is whitelisted\r\n    mapping(address => bool) public _contractWhitelist;\r\n\r\n    modifier onlyBridge() {\r\n        _onlyBridge();\r\n        _;\r\n    }\r\n\r\n    function _onlyBridge() private view {\r\n        require(msg.sender == _bridgeAddress, \"sender must be bridge contract\");\r\n    }\r\n\r\n    /**\r\n        @param bridgeAddress Contract address of previously deployed Bridge.\r\n        @param initialResourceIDs Resource IDs used to identify a specific contract address.\r\n        These are the Resource IDs this contract will initially support.\r\n        @param initialContractAddresses These are the addresses the {initialResourceIDs} will point to, and are the contracts that will be\r\n        called to perform deposit and execution calls.\r\n        @param initialDepositFunctionSignatures These are the function signatures {initialContractAddresses} will point to,\r\n        and are the function that will be called when executing {deposit}\r\n        @param initialExecuteFunctionSignatures These are the function signatures {initialContractAddresses} will point to,\r\n        and are the function that will be called when executing {executeProposal}\r\n\r\n        @dev {initialResourceIDs}, {initialContractAddresses}, {initialDepositFunctionSignatures},\r\n        and {initialExecuteFunctionSignatures} must all have the same length. Also,\r\n        values must be ordered in the way that that index x of any mentioned array\r\n        must be intended for value x of any other array, e.g. {initialContractAddresses}[0]\r\n        is the intended address for {initialDepositFunctionSignatures}[0].\r\n     */\r\n    constructor(\r\n        address bridgeAddress,\r\n        bytes32[] memory initialResourceIDs,\r\n        address[] memory initialContractAddresses,\r\n        bytes4[] memory initialDepositFunctionSignatures,\r\n        bytes4[] memory initialExecuteFunctionSignatures\r\n    ) {\r\n        require(\r\n            initialResourceIDs.length == initialContractAddresses.length,\r\n            \"initialResourceIDs and initialContractAddresses len mismatch\"\r\n        );\r\n\r\n        require(\r\n            initialContractAddresses.length == initialDepositFunctionSignatures.length,\r\n            \"provided contract addresses and function signatures len mismatch\"\r\n        );\r\n\r\n        require(\r\n            initialDepositFunctionSignatures.length == initialExecuteFunctionSignatures.length,\r\n            \"provided deposit and execute function signatures len mismatch\"\r\n        );\r\n\r\n        _bridgeAddress = bridgeAddress;\r\n\r\n        for (uint256 i = 0; i < initialResourceIDs.length; i++) {\r\n            _setResource(\r\n                initialResourceIDs[i],\r\n                initialContractAddresses[i],\r\n                initialDepositFunctionSignatures[i],\r\n                initialExecuteFunctionSignatures[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n        @param depositNonce This ID will have been generated by the Bridge contract.\r\n        @param destId ID of chain deposit will be bridged to.\r\n        @return DepositRecord which consists of:\r\n        - _destinationChainID ChainID deposited tokens are intended to end up on.\r\n        - _resourceID ResourceID used when {deposit} was executed.\r\n        - _depositer Address that initially called {deposit} in the Bridge contract.\r\n        - _metaData Data to be passed to method executed in corresponding {resourceID} contract.\r\n    */\r\n    function getDepositRecord(uint64 depositNonce, uint8 destId) external view returns (DepositRecord memory) {\r\n        return _depositRecords[destId][depositNonce];\r\n    }\r\n\r\n    /**\r\n        @notice First verifies {_resourceIDToContractAddress}[{resourceID}] and\r\n        {_contractAddressToResourceID}[{contractAddress}] are not already set,\r\n        then sets {_resourceIDToContractAddress} with {contractAddress},\r\n        {_contractAddressToResourceID} with {resourceID},\r\n        {_contractAddressToDepositFunctionSignature} with {depositFunctionSig},\r\n        {_contractAddressToExecuteFunctionSignature} with {executeFunctionSig},\r\n        and {_contractWhitelist} to true for {contractAddress}.\r\n        @param resourceID ResourceID to be used when making deposits.\r\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\r\n        @param depositFunctionSig Function signature of method to be called in {contractAddress} when a deposit is made.\r\n        @param executeFunctionSig Function signature of method to be called in {contractAddress} when a deposit is executed.\r\n     */\r\n    function setResource(\r\n        bytes32 resourceID,\r\n        address contractAddress,\r\n        bytes4 depositFunctionSig,\r\n        bytes4 executeFunctionSig\r\n    ) external override onlyBridge {\r\n        _setResource(resourceID, contractAddress, depositFunctionSig, executeFunctionSig);\r\n    }\r\n\r\n    /**\r\n        @notice A deposit is initiatied by making a deposit in the Bridge contract.\r\n        @param destinationChainID Chain ID deposit is expected to be bridged to.\r\n        @param depositNonce This value is generated as an ID by the Bridge contract.\r\n        @param depositer Address of account making the deposit in the Bridge contract.\r\n        @notice {contractAddress} is required to be whitelisted\r\n        @notice If {_contractAddressToDepositFunctionSignature}[{contractAddress}] is set,\r\n        {metaData} is expected to consist of needed function arguments.\r\n     */\r\n    function deposit(\r\n        bytes32 resourceID,\r\n        uint8 destinationChainID,\r\n        uint64 depositNonce,\r\n        address depositer,\r\n        bytes calldata\r\n    ) external onlyBridge {\r\n        bytes32 lenMetadata;\r\n        bytes memory metadata;\r\n\r\n        assembly {\r\n            // Load length of metadata from data + 64\r\n            lenMetadata := calldataload(0xC4)\r\n            // Load free memory pointer\r\n            metadata := mload(0x40)\r\n\r\n            mstore(0x40, add(0x20, add(metadata, lenMetadata)))\r\n\r\n            // func sig (4) + destinationChainId (padded to 32) + depositNonce (32) + depositor (32) +\r\n            // bytes length (32) + resourceId (32) + length (32) = 0xC4\r\n\r\n            calldatacopy(\r\n                metadata, // copy to metadata\r\n                0xC4, // copy from calldata after metadata length declaration @0xC4\r\n                sub(calldatasize(), 0xC4) // copy size (calldatasize - (0xC4 + the space metaData takes up))\r\n            )\r\n        }\r\n\r\n        address contractAddress = _resourceIDToContractAddress[resourceID];\r\n        require(_contractWhitelist[contractAddress], \"provided contractAddress is not whitelisted\");\r\n\r\n        bytes4 sig = _contractAddressToDepositFunctionSignature[contractAddress];\r\n        if (sig != bytes4(0)) {\r\n            bytes memory callData = abi.encodePacked(sig, metadata);\r\n            (bool success, ) = contractAddress.call(callData);\r\n            require(success, \"delegatecall to contractAddress failed\");\r\n        }\r\n\r\n        _depositRecords[destinationChainID][depositNonce] = DepositRecord(\r\n            destinationChainID,\r\n            depositer,\r\n            resourceID,\r\n            metadata\r\n        );\r\n    }\r\n\r\n    /**\r\n        @notice Proposal execution should be initiated when a proposal is finalized in the Bridge contract.\r\n        @notice {contractAddress} is required to be whitelisted\r\n        @notice If {_contractAddressToExecuteFunctionSignature}[{contractAddress}] is set,\r\n        {metaData} is expected to consist of needed function arguments.\r\n     */\r\n    function executeProposal(bytes32 resourceID, bytes calldata) external onlyBridge {\r\n        bytes memory metaData;\r\n        assembly {\r\n            // metadata has variable length\r\n            // load free memory pointer to store metadata\r\n            metaData := mload(0x40)\r\n            // first 32 bytes of variable length in storage refer to length\r\n            let lenMeta := calldataload(0x64)\r\n            mstore(0x40, add(0x60, add(metaData, lenMeta)))\r\n\r\n            // in the calldata, metadata is stored @0x64 after accounting for function signature, and 2 previous params\r\n            calldatacopy(\r\n                metaData, // copy to metaData\r\n                0x64, // copy from calldata after data length declaration at 0x64\r\n                sub(calldatasize(), 0x64) // copy size (calldatasize - 0x64)\r\n            )\r\n        }\r\n\r\n        address contractAddress = _resourceIDToContractAddress[resourceID];\r\n        require(_contractWhitelist[contractAddress], \"provided contractAddress is not whitelisted\");\r\n\r\n        bytes4 sig = _contractAddressToExecuteFunctionSignature[contractAddress];\r\n        if (sig != bytes4(0)) {\r\n            bytes memory callData = abi.encodePacked(sig, metaData);\r\n            (bool success, ) = contractAddress.call(callData);\r\n            require(success, \"delegatecall to contractAddress failed\");\r\n        }\r\n    }\r\n\r\n    function _setResource(\r\n        bytes32 resourceID,\r\n        address contractAddress,\r\n        bytes4 depositFunctionSig,\r\n        bytes4 executeFunctionSig\r\n    ) internal {\r\n        _resourceIDToContractAddress[resourceID] = contractAddress;\r\n        _contractAddressToResourceID[contractAddress] = resourceID;\r\n        _contractAddressToDepositFunctionSignature[contractAddress] = depositFunctionSig;\r\n        _contractAddressToExecuteFunctionSignature[contractAddress] = executeFunctionSig;\r\n\r\n        _contractWhitelist[contractAddress] = true;\r\n    }\r\n}\r\n"
    },
    "contracts/external/chainbridge/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n    @title Interface for Bridge contract.\r\n    @author ChainSafe Systems.\r\n */\r\ninterface IBridge {\r\n    /**\r\n        @notice Exposing getter for {_chainID} instead of forcing the use of call.\r\n        @return uint8 The {_chainID} that is currently set for the Bridge contract.\r\n     */\r\n    function _chainID() external returns (uint8);\r\n\r\n    function deposit(\r\n        uint8 destinationChainID,\r\n        bytes32 resourceID,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n"
    },
    "contracts/external/chainbridge/interfaces/IDepositExecute.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n    @title Interface for handler contracts that support deposits and deposit executions.\r\n    @author ChainSafe Systems.\r\n */\r\ninterface IDepositExecute {\r\n    /**\r\n        @notice It is intended that deposit are made using the Bridge contract.\r\n        @param destinationChainID Chain ID deposit is expected to be bridged to.\r\n        @param depositNonce This value is generated as an ID by the Bridge contract.\r\n        @param depositer Address of account making the deposit in the Bridge contract.\r\n        @param data Consists of additional data needed for a specific deposit.\r\n     */\r\n    function deposit(\r\n        bytes32 resourceID,\r\n        uint8 destinationChainID,\r\n        uint64 depositNonce,\r\n        address depositer,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n        @notice It is intended that proposals are executed by the Bridge contract.\r\n        @param data Consists of additional data needed for a specific deposit execution.\r\n     */\r\n    function executeProposal(bytes32 resourceID, bytes calldata data) external;\r\n}\r\n"
    },
    "contracts/external/chainbridge/interfaces/IERCHandler.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n    @title Interface to be used with handlers that support ERC20s and ERC721s.\r\n    @author ChainSafe Systems.\r\n */\r\ninterface IERCHandler {\r\n    /**\r\n        @notice Correlates {resourceID} with {contractAddress}.\r\n        @param resourceID ResourceID to be used when making deposits.\r\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\r\n     */\r\n    function setResource(bytes32 resourceID, address contractAddress) external;\r\n\r\n    /**\r\n        @notice Marks {contractAddress} as mintable/burnable.\r\n        @param contractAddress Address of contract to be used when making or executing deposits.\r\n     */\r\n    function setBurnable(address contractAddress) external;\r\n\r\n    /**\r\n        @notice Used to manually release funds from ERC safes.\r\n        @param tokenAddress Address of token contract to release.\r\n        @param recipient Address to release tokens to.\r\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to release.\r\n     */\r\n    function withdraw(\r\n        address tokenAddress,\r\n        address recipient,\r\n        uint256 amountOrTokenID\r\n    ) external;\r\n}\r\n"
    },
    "contracts/external/chainbridge/interfaces/IGenericHandler.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n    @title Interface for handler that handles generic deposits and deposit executions.\r\n    @dev Copied directly from here: https://github.com/ChainSafe/chainbridge-solidity/releases/tag/v1.0.0.\r\n    @author ChainSafe Systems.\r\n */\r\ninterface IGenericHandler {\r\n    /**\r\n        @notice Correlates {resourceID} with {contractAddress}, {depositFunctionSig}, and {executeFunctionSig}.\r\n        @param resourceID ResourceID to be used when making deposits.\r\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\r\n        @param depositFunctionSig Function signature of method to be called in {contractAddress} when a deposit is made.\r\n        @param executeFunctionSig Function signature of method to be called in {contractAddress} when a deposit is executed.\r\n     */\r\n    function setResource(\r\n        bytes32 resourceID,\r\n        address contractAddress,\r\n        bytes4 depositFunctionSig,\r\n        bytes4 executeFunctionSig\r\n    ) external;\r\n}\r\n"
    },
    "contracts/external/optimism-bridge/interfaces/OptimismL1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title L1StandardBridge\r\n * @dev The L1 ETH and ERC20 Bridge is a contract which stores deposited L1 funds and standard\r\n * tokens that are in use on L2. It synchronizes a corresponding L2 Bridge, informing it of deposits\r\n * and listening to it for newly finalized withdrawals.\r\n *\r\n */\r\ninterface OptimismL1StandardBridge {\r\n    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;\r\n\r\n    function depositERC20(\r\n        address _l1Token,\r\n        address _l2Token,\r\n        uint256 _amount,\r\n        uint32 _l2Gas,\r\n        bytes calldata _data\r\n    ) external;\r\n}\r\n"
    },
    "contracts/external/optimism-bridge/interfaces/OptimismL2StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title L2StandardBridge\r\n * @dev The L2 Standard bridge is a contract which works together with the L1 Standard bridge to\r\n * enable ETH and ERC20 transitions between L1 and L2.\r\n * This contract acts as a minter for new tokens when it hears about deposits into the L1 Standard\r\n * bridge.\r\n * This contract also acts as a burner of the tokens intended for withdrawal, informing the L1\r\n * bridge to release L1 funds.\r\n */\r\ncontract OptimismL2StandardBridge {\r\n    /********************************\r\n     * External Contract References *\r\n     ********************************/\r\n\r\n    address public l1TokenBridge;\r\n}\r\n"
    },
    "contracts/external/optimism-bridge/interfaces/OptimismL2StandardERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\nabstract contract OptimismL2StandardERC20 is ERC20 {\r\n    address public l1Token;\r\n    address public l2Bridge;\r\n}\r\n"
    },
    "contracts/financial-templates/common/EmergencyShutdownable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\n/**\r\n * @title EmergencyShutdownable contract.\r\n * @notice Any contract that inherits this contract will have an emergency shutdown timestamp state variable.\r\n * This contract provides modifiers that can be used by children contracts to determine if the contract is\r\n * in the shutdown state. The child contract is expected to implement the logic that happens\r\n * once a shutdown occurs.\r\n */\r\n\r\nabstract contract EmergencyShutdownable {\r\n    using SafeMath for uint256;\r\n\r\n    /****************************************\r\n     * EMERGENCY SHUTDOWN DATA STRUCTURES *\r\n     ****************************************/\r\n\r\n    // Timestamp used in case of emergency shutdown. 0 if no shutdown has been triggered.\r\n    uint256 public emergencyShutdownTimestamp;\r\n\r\n    /****************************************\r\n     *              MODIFIERS               *\r\n     ****************************************/\r\n\r\n    modifier notEmergencyShutdown() {\r\n        _notEmergencyShutdown();\r\n        _;\r\n    }\r\n\r\n    modifier isEmergencyShutdown() {\r\n        _isEmergencyShutdown();\r\n        _;\r\n    }\r\n\r\n    /****************************************\r\n     *          EXTERNAL FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    constructor() {\r\n        emergencyShutdownTimestamp = 0;\r\n    }\r\n\r\n    /****************************************\r\n     *          INTERNAL FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    function _notEmergencyShutdown() internal view {\r\n        // Note: removed require string to save bytecode.\r\n        require(emergencyShutdownTimestamp == 0);\r\n    }\r\n\r\n    function _isEmergencyShutdown() internal view {\r\n        // Note: removed require string to save bytecode.\r\n        require(emergencyShutdownTimestamp != 0);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/FeePayer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/AdministrateeInterface.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\n\r\n/**\r\n * @title FeePayer contract.\r\n * @notice Provides fee payment functionality for the ExpiringMultiParty contract.\r\n * contract is abstract as each derived contract that inherits `FeePayer` must implement `pfc()`.\r\n */\r\n\r\nabstract contract FeePayer is AdministrateeInterface, Testable, Lockable {\r\n    using SafeMath for uint256;\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /****************************************\r\n     *      FEE PAYER DATA STRUCTURES       *\r\n     ****************************************/\r\n\r\n    // The collateral currency used to back the positions in this contract.\r\n    IERC20 public collateralCurrency;\r\n\r\n    // Finder contract used to look up addresses for UMA system contracts.\r\n    FinderInterface public finder;\r\n\r\n    // Tracks the last block time when the fees were paid.\r\n    uint256 private lastPaymentTime;\r\n\r\n    // Tracks the cumulative fees that have been paid by the contract for use by derived contracts.\r\n    // The multiplier starts at 1, and is updated by computing cumulativeFeeMultiplier * (1 - effectiveFee).\r\n    // Put another way, the cumulativeFeeMultiplier is (1 - effectiveFee1) * (1 - effectiveFee2) ...\r\n    // For example:\r\n    // The cumulativeFeeMultiplier should start at 1.\r\n    // If a 1% fee is charged, the multiplier should update to .99.\r\n    // If another 1% fee is charged, the multiplier should be 0.99^2 (0.9801).\r\n    FixedPoint.Unsigned public cumulativeFeeMultiplier;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event RegularFeesPaid(uint256 indexed regularFee, uint256 indexed lateFee);\r\n    event FinalFeesPaid(uint256 indexed amount);\r\n\r\n    /****************************************\r\n     *              MODIFIERS               *\r\n     ****************************************/\r\n\r\n    // modifier that calls payRegularFees().\r\n    modifier fees virtual {\r\n        // Note: the regular fee is applied on every fee-accruing transaction, where the total change is simply the\r\n        // regular fee applied linearly since the last update. This implies that the compounding rate depends on the\r\n        // frequency of update transactions that have this modifier, and it never reaches the ideal of continuous\r\n        // compounding. This approximate-compounding pattern is common in the Ethereum ecosystem because of the\r\n        // complexity of compounding data on-chain.\r\n        payRegularFees();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructs the FeePayer contract. Called by child contracts.\r\n     * @param _collateralAddress ERC20 token that is used as the underlying collateral for the synthetic.\r\n     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\r\n     * @param _timerAddress Contract that stores the current time in a testing environment.\r\n     * Must be set to 0x0 for production environments that use live time.\r\n     */\r\n    constructor(\r\n        address _collateralAddress,\r\n        address _finderAddress,\r\n        address _timerAddress\r\n    ) Testable(_timerAddress) {\r\n        collateralCurrency = IERC20(_collateralAddress);\r\n        finder = FinderInterface(_finderAddress);\r\n        lastPaymentTime = getCurrentTime();\r\n        cumulativeFeeMultiplier = FixedPoint.fromUnscaledUint(1);\r\n    }\r\n\r\n    /****************************************\r\n     *        FEE PAYMENT FUNCTIONS         *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.\r\n     * @dev These must be paid periodically for the life of the contract. If the contract has not paid its regular fee\r\n     * in a week or more then a late penalty is applied which is sent to the caller. If the amount of\r\n     * fees owed are greater than the pfc, then this will pay as much as possible from the available collateral.\r\n     * An event is only fired if the fees charged are greater than 0.\r\n     * @return totalPaid Amount of collateral that the contract paid (sum of the amount paid to the Store and caller).\r\n     * This returns 0 and exit early if there is no pfc, fees were already paid during the current block, or the fee rate is 0.\r\n     */\r\n    function payRegularFees() public nonReentrant() returns (FixedPoint.Unsigned memory) {\r\n        uint256 time = getCurrentTime();\r\n        FixedPoint.Unsigned memory collateralPool = _pfc();\r\n\r\n        // Fetch the regular fees, late penalty and the max possible to pay given the current collateral within the contract.\r\n        (\r\n            FixedPoint.Unsigned memory regularFee,\r\n            FixedPoint.Unsigned memory latePenalty,\r\n            FixedPoint.Unsigned memory totalPaid\r\n        ) = getOutstandingRegularFees(time);\r\n        lastPaymentTime = time;\r\n\r\n        // If there are no fees to pay then exit early.\r\n        if (totalPaid.isEqual(0)) {\r\n            return totalPaid;\r\n        }\r\n\r\n        emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\r\n\r\n        _adjustCumulativeFeeMultiplier(totalPaid, collateralPool);\r\n\r\n        if (regularFee.isGreaterThan(0)) {\r\n            StoreInterface store = _getStore();\r\n            collateralCurrency.safeIncreaseAllowance(address(store), regularFee.rawValue);\r\n            store.payOracleFeesErc20(address(collateralCurrency), regularFee);\r\n        }\r\n\r\n        if (latePenalty.isGreaterThan(0)) {\r\n            collateralCurrency.safeTransfer(msg.sender, latePenalty.rawValue);\r\n        }\r\n        return totalPaid;\r\n    }\r\n\r\n    /**\r\n     * @notice Fetch any regular fees that the contract has pending but has not yet paid. If the fees to be paid are more\r\n     * than the total collateral within the contract then the totalPaid returned is full contract collateral amount.\r\n     * @dev This returns 0 and exit early if there is no pfc, fees were already paid during the current block, or the fee rate is 0.\r\n     * @return regularFee outstanding unpaid regular fee.\r\n     * @return latePenalty outstanding unpaid late fee for being late in previous fee payments.\r\n     * @return totalPaid Amount of collateral that the contract paid (sum of the amount paid to the Store and caller).\r\n     */\r\n    function getOutstandingRegularFees(uint256 time)\r\n        public\r\n        view\r\n        returns (\r\n            FixedPoint.Unsigned memory regularFee,\r\n            FixedPoint.Unsigned memory latePenalty,\r\n            FixedPoint.Unsigned memory totalPaid\r\n        )\r\n    {\r\n        StoreInterface store = _getStore();\r\n        FixedPoint.Unsigned memory collateralPool = _pfc();\r\n\r\n        // Exit early if there is no collateral or if fees were already paid during this block.\r\n        if (collateralPool.isEqual(0) || lastPaymentTime == time) {\r\n            return (regularFee, latePenalty, totalPaid);\r\n        }\r\n\r\n        (regularFee, latePenalty) = store.computeRegularFee(lastPaymentTime, time, collateralPool);\r\n\r\n        totalPaid = regularFee.add(latePenalty);\r\n        if (totalPaid.isEqual(0)) {\r\n            return (regularFee, latePenalty, totalPaid);\r\n        }\r\n        // If the effective fees paid as a % of the pfc is > 100%, then we need to reduce it and make the contract pay\r\n        // as much of the fee that it can (up to 100% of its pfc). We'll reduce the late penalty first and then the\r\n        // regular fee, which has the effect of paying the store first, followed by the caller if there is any fee remaining.\r\n        if (totalPaid.isGreaterThan(collateralPool)) {\r\n            FixedPoint.Unsigned memory deficit = totalPaid.sub(collateralPool);\r\n            FixedPoint.Unsigned memory latePenaltyReduction = FixedPoint.min(latePenalty, deficit);\r\n            latePenalty = latePenalty.sub(latePenaltyReduction);\r\n            deficit = deficit.sub(latePenaltyReduction);\r\n            regularFee = regularFee.sub(FixedPoint.min(regularFee, deficit));\r\n            totalPaid = collateralPool;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current profit from corruption for this contract in terms of the collateral currency.\r\n     * @dev This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are\r\n     * expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.\r\n     * @return pfc value for equal to the current profit from corruption denominated in collateral currency.\r\n     */\r\n    function pfc() external view override nonReentrantView() returns (FixedPoint.Unsigned memory) {\r\n        return _pfc();\r\n    }\r\n\r\n    /**\r\n     * @notice Removes excess collateral balance not counted in the PfC by distributing it out pro-rata to all sponsors.\r\n     * @dev Multiplying the `cumulativeFeeMultiplier` by the ratio of non-PfC-collateral :: PfC-collateral effectively\r\n     * pays all sponsors a pro-rata portion of the excess collateral.\r\n     * @dev This will revert if PfC is 0 and this contract's collateral balance > 0.\r\n     */\r\n    function gulp() external nonReentrant() {\r\n        _gulp();\r\n    }\r\n\r\n    /****************************************\r\n     *         INTERNAL FUNCTIONS           *\r\n     ****************************************/\r\n\r\n    // Pays UMA Oracle final fees of `amount` in `collateralCurrency` to the Store contract. Final fee is a flat fee\r\n    // charged for each price request. If payer is the contract, adjusts internal bookkeeping variables. If payer is not\r\n    // the contract, pulls in `amount` of collateral currency.\r\n    function _payFinalFees(address payer, FixedPoint.Unsigned memory amount) internal {\r\n        if (amount.isEqual(0)) {\r\n            return;\r\n        }\r\n\r\n        if (payer != address(this)) {\r\n            // If the payer is not the contract pull the collateral from the payer.\r\n            collateralCurrency.safeTransferFrom(payer, address(this), amount.rawValue);\r\n        } else {\r\n            // If the payer is the contract, adjust the cumulativeFeeMultiplier to compensate.\r\n            FixedPoint.Unsigned memory collateralPool = _pfc();\r\n\r\n            // The final fee must be < available collateral or the fee will be larger than 100%.\r\n            // Note: revert reason removed to save bytecode.\r\n            require(collateralPool.isGreaterThan(amount));\r\n\r\n            _adjustCumulativeFeeMultiplier(amount, collateralPool);\r\n        }\r\n\r\n        emit FinalFeesPaid(amount.rawValue);\r\n\r\n        StoreInterface store = _getStore();\r\n        collateralCurrency.safeIncreaseAllowance(address(store), amount.rawValue);\r\n        store.payOracleFeesErc20(address(collateralCurrency), amount);\r\n    }\r\n\r\n    function _gulp() internal {\r\n        FixedPoint.Unsigned memory currentPfc = _pfc();\r\n        FixedPoint.Unsigned memory currentBalance = FixedPoint.Unsigned(collateralCurrency.balanceOf(address(this)));\r\n        if (currentPfc.isLessThan(currentBalance)) {\r\n            cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(currentBalance.div(currentPfc));\r\n        }\r\n    }\r\n\r\n    function _pfc() internal view virtual returns (FixedPoint.Unsigned memory);\r\n\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n\r\n    function _computeFinalFees() internal view returns (FixedPoint.Unsigned memory finalFees) {\r\n        StoreInterface store = _getStore();\r\n        return store.computeFinalFee(address(collateralCurrency));\r\n    }\r\n\r\n    // Returns the user's collateral minus any fees that have been subtracted since it was originally\r\n    // deposited into the contract. Note: if the contract has paid fees since it was deployed, the raw\r\n    // value should be larger than the returned value.\r\n    function _getFeeAdjustedCollateral(FixedPoint.Unsigned memory rawCollateral)\r\n        internal\r\n        view\r\n        returns (FixedPoint.Unsigned memory collateral)\r\n    {\r\n        return rawCollateral.mul(cumulativeFeeMultiplier);\r\n    }\r\n\r\n    // Returns the user's collateral minus any pending fees that have yet to be subtracted.\r\n    function _getPendingRegularFeeAdjustedCollateral(FixedPoint.Unsigned memory rawCollateral)\r\n        internal\r\n        view\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        (, , FixedPoint.Unsigned memory currentTotalOutstandingRegularFees) =\r\n            getOutstandingRegularFees(getCurrentTime());\r\n        if (currentTotalOutstandingRegularFees.isEqual(FixedPoint.fromUnscaledUint(0))) return rawCollateral;\r\n\r\n        // Calculate the total outstanding regular fee as a fraction of the total contract PFC.\r\n        FixedPoint.Unsigned memory effectiveOutstandingFee = currentTotalOutstandingRegularFees.divCeil(_pfc());\r\n\r\n        // Scale as rawCollateral* (1 - effectiveOutstandingFee) to apply the pro-rata amount to the regular fee.\r\n        return rawCollateral.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveOutstandingFee));\r\n    }\r\n\r\n    // Converts a user-readable collateral value into a raw value that accounts for already-assessed fees. If any fees\r\n    // have been taken from this contract in the past, then the raw value will be larger than the user-readable value.\r\n    function _convertToRawCollateral(FixedPoint.Unsigned memory collateral)\r\n        internal\r\n        view\r\n        returns (FixedPoint.Unsigned memory rawCollateral)\r\n    {\r\n        return collateral.div(cumulativeFeeMultiplier);\r\n    }\r\n\r\n    // Decrease rawCollateral by a fee-adjusted collateralToRemove amount. Fee adjustment scales up collateralToRemove\r\n    // by dividing it by cumulativeFeeMultiplier. There is potential for this quotient to be floored, therefore\r\n    // rawCollateral is decreased by less than expected. Because this method is usually called in conjunction with an\r\n    // actual removal of collateral from this contract, return the fee-adjusted amount that the rawCollateral is\r\n    // decreased by so that the caller can minimize error between collateral removed and rawCollateral debited.\r\n    function _removeCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToRemove)\r\n        internal\r\n        returns (FixedPoint.Unsigned memory removedCollateral)\r\n    {\r\n        FixedPoint.Unsigned memory initialBalance = _getFeeAdjustedCollateral(rawCollateral);\r\n        FixedPoint.Unsigned memory adjustedCollateral = _convertToRawCollateral(collateralToRemove);\r\n        rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\r\n        removedCollateral = initialBalance.sub(_getFeeAdjustedCollateral(rawCollateral));\r\n    }\r\n\r\n    // Increase rawCollateral by a fee-adjusted collateralToAdd amount. Fee adjustment scales up collateralToAdd\r\n    // by dividing it by cumulativeFeeMultiplier. There is potential for this quotient to be floored, therefore\r\n    // rawCollateral is increased by less than expected. Because this method is usually called in conjunction with an\r\n    // actual addition of collateral to this contract, return the fee-adjusted amount that the rawCollateral is\r\n    // increased by so that the caller can minimize error between collateral added and rawCollateral credited.\r\n    // NOTE: This return value exists only for the sake of symmetry with _removeCollateral. We don't actually use it\r\n    // because we are OK if more collateral is stored in the contract than is represented by rawTotalPositionCollateral.\r\n    function _addCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToAdd)\r\n        internal\r\n        returns (FixedPoint.Unsigned memory addedCollateral)\r\n    {\r\n        FixedPoint.Unsigned memory initialBalance = _getFeeAdjustedCollateral(rawCollateral);\r\n        FixedPoint.Unsigned memory adjustedCollateral = _convertToRawCollateral(collateralToAdd);\r\n        rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\r\n        addedCollateral = _getFeeAdjustedCollateral(rawCollateral).sub(initialBalance);\r\n    }\r\n\r\n    // Scale the cumulativeFeeMultiplier by the ratio of fees paid to the current available collateral.\r\n    function _adjustCumulativeFeeMultiplier(FixedPoint.Unsigned memory amount, FixedPoint.Unsigned memory currentPfc)\r\n        internal\r\n    {\r\n        FixedPoint.Unsigned memory effectiveFee = amount.divCeil(currentPfc);\r\n        cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee));\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/expiring-multiparty-libraries/CoveredCallFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\nimport \"./FinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Covered Call Financial Product Library.\r\n * @notice Adds custom price transformation logic to modify the behavior of the expiring multi party contract. The\r\n * contract holds say 1 WETH in collateral and pays out a portion of that, at expiry, if ETHUSD is above a set strike. If\r\n * ETHUSD is below that strike, the contract pays out 0. The fraction paid out if above the strike is defined by\r\n * (oraclePrice - strikePrice) / oraclePrice;\r\n * Example: expiry is DEC 31. Strike is $400. Each token is backed by 1 WETH.\r\n * If ETHUSD = $600 at expiry, the call is $200 in the money, and the contract pays out 0.333 WETH (worth $200).\r\n * If ETHUSD = $800 at expiry, the call is $400 in the money, and the contract pays out 0.5 WETH (worth $400).\r\n * If ETHUSD =< $400 at expiry, the call is out of the money, and the contract pays out 0 WETH.\r\n */\r\ncontract CoveredCallFinancialProductLibrary is FinancialProductLibrary, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    mapping(address => FixedPoint.Unsigned) private financialProductStrikes;\r\n\r\n    /**\r\n     * @notice Enables any address to set the strike price for an associated financial product.\r\n     * @param financialProduct address of the financial product.\r\n     * @param strikePrice the strike price for the covered call to be applied to the financial product.\r\n     * @dev Note: a) Any address can set the initial strike price b) A strike price cannot be 0.\r\n     * c) A strike price can only be set once to prevent the deployer from changing the strike after the fact.\r\n     * d) For safety, a strike price should be set before depositing any synthetic tokens in a liquidity pool.\r\n     * e) financialProduct must expose an expirationTimestamp method.\r\n     */\r\n    function setFinancialProductStrike(address financialProduct, FixedPoint.Unsigned memory strikePrice)\r\n        public\r\n        nonReentrant()\r\n    {\r\n        require(strikePrice.isGreaterThan(0), \"Cant set 0 strike\");\r\n        require(financialProductStrikes[financialProduct].isEqual(0), \"Strike already set\");\r\n        require(ExpiringContractInterface(financialProduct).expirationTimestamp() != 0, \"Invalid EMP contract\");\r\n        financialProductStrikes[financialProduct] = strikePrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the strike price associated with a given financial product address.\r\n     * @param financialProduct address of the financial product.\r\n     * @return strikePrice for the associated financial product.\r\n     */\r\n    function getStrikeForFinancialProduct(address financialProduct)\r\n        public\r\n        view\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        return financialProductStrikes[financialProduct];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a transformed price by applying the call option payout structure.\r\n     * @param oraclePrice price from the oracle to be transformed.\r\n     * @param requestTime timestamp the oraclePrice was requested at.\r\n     * @return transformedPrice the input oracle price with the price transformation logic applied to it.\r\n     */\r\n    function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256 requestTime)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        FixedPoint.Unsigned memory strike = financialProductStrikes[msg.sender];\r\n        require(strike.isGreaterThan(0), \"Caller has no strike\");\r\n        // If price request is made before expiry, return 1. Thus we can keep the contract 100% collateralized with\r\n        // each token backed 1:1 by collateral currency.\r\n        if (requestTime < ExpiringContractInterface(msg.sender).expirationTimestamp()) {\r\n            return FixedPoint.fromUnscaledUint(1);\r\n        }\r\n        if (oraclePrice.isLessThanOrEqual(strike)) {\r\n            return FixedPoint.fromUnscaledUint(0);\r\n        } else {\r\n            // Token expires to be worth the fraction of a collateral token that's in the money.\r\n            // eg if ETHUSD is $500 and strike is $400, token is redeemable for 100/500 = 0.2 WETH (worth $100).\r\n            // Note: oraclePrice cannot be 0 here because it would always satisfy the if above because 0 <= x is always\r\n            // true.\r\n            return (oraclePrice.sub(strike)).div(oraclePrice);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a transformed collateral requirement by applying the covered call payout structure.\r\n     * @return transformedCollateralRequirement the input collateral requirement with the transformation logic applied to it.\r\n     */\r\n    function transformCollateralRequirement(FixedPoint.Unsigned memory, FixedPoint.Unsigned memory)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        FixedPoint.Unsigned memory strike = financialProductStrikes[msg.sender];\r\n        require(strike.isGreaterThan(0), \"Caller has no strike\");\r\n\r\n        // Always return 1 because option must be collateralized by 1 token.\r\n        return FixedPoint.fromUnscaledUint(1);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/expiring-multiparty-libraries/FinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\nimport \"../../../../common/implementation/FixedPoint.sol\";\r\n\r\ninterface ExpiringContractInterface {\r\n    function expirationTimestamp() external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title Financial product library contract\r\n * @notice Provides price and collateral requirement transformation interfaces that can be overridden by custom\r\n * Financial product library implementations.\r\n */\r\nabstract contract FinancialProductLibrary {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    /**\r\n     * @notice Transforms a given oracle price using the financial product libraries transformation logic.\r\n     * @param oraclePrice input price returned by the DVM to be transformed.\r\n     * @return transformedOraclePrice input oraclePrice with the transformation function applied.\r\n     */\r\n    function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256)\r\n        public\r\n        view\r\n        virtual\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        return oraclePrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Transforms a given collateral requirement using the financial product libraries transformation logic.\r\n     * @param collateralRequirement input collateral requirement to be transformed.\r\n     * @return transformedCollateralRequirement input collateral requirement with the transformation function applied.\r\n     */\r\n    function transformCollateralRequirement(\r\n        FixedPoint.Unsigned memory,\r\n        FixedPoint.Unsigned memory collateralRequirement\r\n    ) public view virtual returns (FixedPoint.Unsigned memory) {\r\n        return collateralRequirement;\r\n    }\r\n\r\n    /**\r\n     * @notice Transforms a given price identifier using the financial product libraries transformation logic.\r\n     * @param priceIdentifier input price identifier defined for the financial contract.\r\n     * @return transformedPriceIdentifier input price identifier with the transformation function applied.\r\n     */\r\n    function transformPriceIdentifier(bytes32 priceIdentifier, uint256) public view virtual returns (bytes32) {\r\n        return priceIdentifier;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/expiring-multiparty-libraries/KpiOptionsFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\nimport \"./FinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title KPI Options Financial Product Library\r\n * @notice Adds custom tranformation logic to modify the price and collateral requirement behavior of the expiring multi party contract.\r\n * If a price request is made pre-expiry, the price should always be set to 2 and the collateral requirement should be set to 1.\r\n * Post-expiry, the collateral requirement is left as 1 and the price is left unchanged.\r\n */\r\ncontract KpiOptionsFinancialProductLibrary is FinancialProductLibrary, Lockable {\r\n    /**\r\n     * @notice Returns a transformed price for pre-expiry price requests.\r\n     * @param oraclePrice price from the oracle to be transformed.\r\n     * @param requestTime timestamp the oraclePrice was requested at.\r\n     * @return transformedPrice the input oracle price with the price transformation logic applied to it.\r\n     */\r\n    function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256 requestTime)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        // If price request is made before expiry, return 2. Thus we can keep the contract 100% collateralized with\r\n        // each token backed 1:2 by collateral currency. Post-expiry, leave unchanged.\r\n        if (requestTime < ExpiringContractInterface(msg.sender).expirationTimestamp()) {\r\n            return FixedPoint.fromUnscaledUint(2);\r\n        } else {\r\n            return oraclePrice;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a transformed collateral requirement that is set to be equivalent to 2 tokens pre-expiry.\r\n     * @return transformedCollateralRequirement the input collateral requirement with the transformation logic applied to it.\r\n     */\r\n    function transformCollateralRequirement(FixedPoint.Unsigned memory, FixedPoint.Unsigned memory)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        // Always return 1.\r\n        return FixedPoint.fromUnscaledUint(1);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/expiring-multiparty-libraries/PostExpirationIdentifierTransformationFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\nimport \"./FinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Post-Expiration Identifier Transformation Financial Product Library\r\n * @notice Adds custom identifier transformation to enable a financial contract to use two different identifiers, depending\r\n * on when a price request is made. If the request is made at or after expiration then a transformation is made to the identifier\r\n * & if it is before expiration then the original identifier is returned. This library enables self referential\r\n * TWAP identifier to be used on synthetics pre-expiration, in conjunction with a separate identifier at expiration.\r\n */\r\ncontract PostExpirationIdentifierTransformationFinancialProductLibrary is FinancialProductLibrary, Lockable {\r\n    mapping(address => bytes32) financialProductTransformedIdentifiers;\r\n\r\n    /**\r\n     * @notice Enables the deployer of the library to set the transformed identifier for an associated financial product.\r\n     * @param financialProduct address of the financial product.\r\n     * @param transformedIdentifier the identifier for the financial product to be used if the contract is post expiration.\r\n     * @dev Note: a) Any address can set identifier transformations b) The identifier can't be set to blank. c) A\r\n     * transformed price can only be set once to prevent the deployer from changing it after the fact. d) financialProduct\r\n     * must expose an expirationTimestamp method.\r\n     */\r\n    function setFinancialProductTransformedIdentifier(address financialProduct, bytes32 transformedIdentifier)\r\n        public\r\n        nonReentrant()\r\n    {\r\n        require(transformedIdentifier != \"\", \"Cant set to empty transformation\");\r\n        require(financialProductTransformedIdentifiers[financialProduct] == \"\", \"Transformation already set\");\r\n        require(ExpiringContractInterface(financialProduct).expirationTimestamp() != 0, \"Invalid EMP contract\");\r\n        financialProductTransformedIdentifiers[financialProduct] = transformedIdentifier;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the transformed identifier associated with a given financial product address.\r\n     * @param financialProduct address of the financial product.\r\n     * @return transformed identifier for the associated financial product.\r\n     */\r\n    function getTransformedIdentifierForFinancialProduct(address financialProduct)\r\n        public\r\n        view\r\n        nonReentrantView()\r\n        returns (bytes32)\r\n    {\r\n        return financialProductTransformedIdentifiers[financialProduct];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a transformed price identifier if the contract is post-expiration and no transformation if pre.\r\n     * @param identifier input price identifier to be transformed.\r\n     * @param requestTime timestamp the identifier is to be used at.\r\n     * @return transformedPriceIdentifier the input price identifier with the transformation logic applied to it.\r\n     */\r\n    function transformPriceIdentifier(bytes32 identifier, uint256 requestTime)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (bytes32)\r\n    {\r\n        require(financialProductTransformedIdentifiers[msg.sender] != \"\", \"Caller has no transformation\");\r\n        // If the request time is after contract expiration then return the transformed identifier. Else, return the\r\n        // original price identifier.\r\n        if (requestTime < ExpiringContractInterface(msg.sender).expirationTimestamp()) {\r\n            return identifier;\r\n        } else {\r\n            return financialProductTransformedIdentifiers[msg.sender];\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/expiring-multiparty-libraries/PreExpirationIdentifierTransformationFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\nimport \"./FinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Pre-Expiration Identifier Transformation Financial Product Library\r\n * @notice Adds custom identifier transformation to enable a financial contract to use two different identifiers, depending\r\n * on when a price request is made. If the request is made before expiration then a transformation is made to the identifier\r\n * & if it is at or after expiration then the original identifier is returned. This library enables self referential\r\n * TWAP identifier to be used on synthetics pre-expiration, in conjunction with a separate identifier at expiration.\r\n */\r\ncontract PreExpirationIdentifierTransformationFinancialProductLibrary is FinancialProductLibrary, Lockable {\r\n    mapping(address => bytes32) financialProductTransformedIdentifiers;\r\n\r\n    /**\r\n     * @notice Enables the deployer of the library to set the transformed identifier for an associated financial product.\r\n     * @param financialProduct address of the financial product.\r\n     * @param transformedIdentifier the identifier for the financial product to be used if the contract is pre expiration.\r\n     * @dev Note: a) Any address can set identifier transformations b) The identifier can't be set to blank. c) A\r\n     * transformed price can only be set once to prevent the deployer from changing it after the fact. d) financialProduct\r\n     * must expose an expirationTimestamp method.\r\n     */\r\n    function setFinancialProductTransformedIdentifier(address financialProduct, bytes32 transformedIdentifier)\r\n        public\r\n        nonReentrant()\r\n    {\r\n        require(transformedIdentifier != \"\", \"Cant set to empty transformation\");\r\n        require(financialProductTransformedIdentifiers[financialProduct] == \"\", \"Transformation already set\");\r\n        require(ExpiringContractInterface(financialProduct).expirationTimestamp() != 0, \"Invalid EMP contract\");\r\n        financialProductTransformedIdentifiers[financialProduct] = transformedIdentifier;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the transformed identifier associated with a given financial product address.\r\n     * @param financialProduct address of the financial product.\r\n     * @return transformed identifier for the associated financial product.\r\n     */\r\n    function getTransformedIdentifierForFinancialProduct(address financialProduct)\r\n        public\r\n        view\r\n        nonReentrantView()\r\n        returns (bytes32)\r\n    {\r\n        return financialProductTransformedIdentifiers[financialProduct];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a transformed price identifier if the contract is pre-expiration and no transformation if post.\r\n     * @param identifier input price identifier to be transformed.\r\n     * @param requestTime timestamp the identifier is to be used at.\r\n     * @return transformedPriceIdentifier the input price identifier with the transformation logic applied to it.\r\n     */\r\n    function transformPriceIdentifier(bytes32 identifier, uint256 requestTime)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (bytes32)\r\n    {\r\n        require(financialProductTransformedIdentifiers[msg.sender] != \"\", \"Caller has no transformation\");\r\n        // If the request time is before contract expiration then return the transformed identifier. Else, return the\r\n        // original price identifier.\r\n        if (requestTime < ExpiringContractInterface(msg.sender).expirationTimestamp()) {\r\n            return financialProductTransformedIdentifiers[msg.sender];\r\n        } else {\r\n            return identifier;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/expiring-multiparty-libraries/StructuredNoteFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\nimport \"./FinancialProductLibrary.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Structured Note Financial Product Library\r\n * @notice Adds custom price transformation logic to modify the behavior of the expiring multi party contract. The\r\n * contract holds say 1 WETH in collateral and pays out that 1 WETH if, at expiry, ETHUSD is below a set strike. If\r\n * ETHUSD is above that strike, the contract pays out a given dollar amount of ETH.\r\n * Example: expiry is DEC 31. Strike is $400. Each token is backed by 1 WETH\r\n * If ETHUSD < $400 at expiry, token is redeemed for 1 ETH.\r\n * If ETHUSD >= $400 at expiry, token is redeemed for $400 worth of ETH, as determined by the DVM.\r\n */\r\ncontract StructuredNoteFinancialProductLibrary is FinancialProductLibrary, Ownable, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    mapping(address => FixedPoint.Unsigned) financialProductStrikes;\r\n\r\n    /**\r\n     * @notice Enables the deployer of the library to set the strike price for an associated financial product.\r\n     * @param financialProduct address of the financial product.\r\n     * @param strikePrice the strike price for the structured note to be applied to the financial product.\r\n     * @dev Note: a) Only the owner (deployer) of this library can set new strike prices b) A strike price cannot be 0.\r\n     * c) A strike price can only be set once to prevent the deployer from changing the strike after the fact.\r\n     * d)  financialProduct must exposes an expirationTimestamp method.\r\n     */\r\n    function setFinancialProductStrike(address financialProduct, FixedPoint.Unsigned memory strikePrice)\r\n        public\r\n        onlyOwner\r\n        nonReentrant()\r\n    {\r\n        require(strikePrice.isGreaterThan(0), \"Cant set 0 strike\");\r\n        require(financialProductStrikes[financialProduct].isEqual(0), \"Strike already set\");\r\n        require(ExpiringContractInterface(financialProduct).expirationTimestamp() != 0, \"Invalid EMP contract\");\r\n        financialProductStrikes[financialProduct] = strikePrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the strike price associated with a given financial product address.\r\n     * @param financialProduct address of the financial product.\r\n     * @return strikePrice for the associated financial product.\r\n     */\r\n    function getStrikeForFinancialProduct(address financialProduct)\r\n        public\r\n        view\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        return financialProductStrikes[financialProduct];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a transformed price by applying the structured note payout structure.\r\n     * @param oraclePrice price from the oracle to be transformed.\r\n     * @param requestTime timestamp the oraclePrice was requested at.\r\n     * @return transformedPrice the input oracle price with the price transformation logic applied to it.\r\n     */\r\n    function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256 requestTime)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        FixedPoint.Unsigned memory strike = financialProductStrikes[msg.sender];\r\n        require(strike.isGreaterThan(0), \"Caller has no strike\");\r\n        // If price request is made before expiry, return 1. Thus we can keep the contract 100% collateralized with\r\n        // each token backed 1:1 by collateral currency.\r\n        if (requestTime < ExpiringContractInterface(msg.sender).expirationTimestamp()) {\r\n            return FixedPoint.fromUnscaledUint(1);\r\n        }\r\n        if (oraclePrice.isLessThan(strike)) {\r\n            return FixedPoint.fromUnscaledUint(1);\r\n        } else {\r\n            // Token expires to be worth strike $ worth of collateral.\r\n            // eg if ETHUSD is $500 and strike is $400, token is redeemable for 400/500 = 0.8 WETH.\r\n            return strike.div(oraclePrice);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a transformed collateral requirement by applying the structured note payout structure. If the price\r\n     * of the structured note is greater than the strike then the collateral requirement scales down accordingly.\r\n     * @param oraclePrice price from the oracle to transform the collateral requirement.\r\n     * @param collateralRequirement financial products collateral requirement to be scaled according to price and strike.\r\n     * @return transformedCollateralRequirement the input collateral requirement with the transformation logic applied to it.\r\n     */\r\n    function transformCollateralRequirement(\r\n        FixedPoint.Unsigned memory oraclePrice,\r\n        FixedPoint.Unsigned memory collateralRequirement\r\n    ) public view override nonReentrantView() returns (FixedPoint.Unsigned memory) {\r\n        FixedPoint.Unsigned memory strike = financialProductStrikes[msg.sender];\r\n        require(strike.isGreaterThan(0), \"Caller has no strike\");\r\n        // If the price is less than the strike than the original collateral requirement is used.\r\n        if (oraclePrice.isLessThan(strike)) {\r\n            return collateralRequirement;\r\n        } else {\r\n            // If the price is more than the strike then the collateral requirement is scaled by the strike. For example\r\n            // a strike of $400 and a CR of 1.2 would yield:\r\n            // ETHUSD = $350, payout is 1 WETH. CR is multiplied by 1. resulting CR = 1.2\r\n            // ETHUSD = $400, payout is 1 WETH. CR is multiplied by 1. resulting CR = 1.2\r\n            // ETHUSD = $425, payout is 0.941 WETH (worth $400). CR is multiplied by 0.941. resulting CR = 1.1292\r\n            // ETHUSD = $500, payout is 0.8 WETH (worth $400). CR multiplied by 0.8. resulting CR = 0.96\r\n            return collateralRequirement.mul(strike.div(oraclePrice));\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/BinaryOptionLongShortPairFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"./LongShortPairFinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Binary Option Long Short Pair Financial Product Library.\r\n * @notice Adds settlement logic to binary option LSPs. Binary options settle with all collateral allocated to\r\n * either the long or short side, depending on the settlement price. They can be used to make prediction markets or any\r\n * kind of binary bet. Settlement is defined using a strike price which informs which side of the bet was correct. If\r\n * settlement price is greater or equal to the strike then all value is sent to the long side. Otherwise, all value\r\n * is sent to the short side. The settlement price could be a scalar (like the price of ETH) or a binary bet with\r\n * settlement being 0 or 1 depending on the outcome.\r\n */\r\ncontract BinaryOptionLongShortPairFinancialProductLibrary is LongShortPairFinancialProductLibrary, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SafeMath for uint256;\r\n\r\n    struct BinaryLongShortPairParameters {\r\n        bool isSet;\r\n        int256 strikePrice;\r\n    }\r\n\r\n    mapping(address => BinaryLongShortPairParameters) public longShortPairParameters;\r\n\r\n    /**\r\n     * @notice Enables any address to set the strike price for an associated binary option.\r\n     * @param longShortPair address of the LSP.\r\n     * @param strikePrice the strike price for the binary option.\r\n     * @dev Note: a) Any address can set the initial strike price b) A strike can be 0.\r\n     * c) A strike price can only be set once to prevent the deployer from changing the strike after the fact.\r\n     * d) For safety, a strike price should be set before depositing any synthetic tokens in a liquidity pool.\r\n     * e) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\r\n     */\r\n    function setLongShortPairParameters(address longShortPair, int256 strikePrice) public nonReentrant() {\r\n        require(ExpiringContractInterface(longShortPair).expirationTimestamp() != 0, \"Invalid LSP address\");\r\n        require(!longShortPairParameters[longShortPair].isSet, \"Parameters already set\");\r\n\r\n        longShortPairParameters[longShortPair] = BinaryLongShortPairParameters({\r\n            isSet: true,\r\n            strikePrice: strikePrice\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a number between 0 and 1e18 to indicate how much collateral each long and short token are entitled\r\n     * to per collateralPerPair.\r\n     * @param expiryPrice price from the optimistic oracle for the LSP price identifier.\r\n     * @return expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\r\n     */\r\n    function percentageLongCollateralAtExpiry(int256 expiryPrice)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (uint256)\r\n    {\r\n        BinaryLongShortPairParameters memory params = longShortPairParameters[msg.sender];\r\n        require(params.isSet, \"Params not set for calling LSP\");\r\n\r\n        if (expiryPrice >= params.strikePrice) return FixedPoint.fromUnscaledUint(1).rawValue;\r\n        else return FixedPoint.fromUnscaledUint(0).rawValue;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/CappedYieldDollarLongShortPairFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\n\r\nimport \"./LongShortPairFinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Capped Yield Dollar Long Short Pair Financial Product Library\r\n * @notice Adds settlement logic to create Yield Dollar LSPs. A range bond is the combination of a Yield dollar and short\r\n * put option enabling the token sponsor to issue structured products to unlock DeFi treasuries. This library is like\r\n * a Range Bond, but with no embedded call option.\r\n * A Capped Yield Dollar is defined as = Yield Dollar - Put Option. In order for the Capped Yield Dollar to be fully\r\n * collateralized and non-liquidatable, there is a low price for the collateral token below which the Capped Yield Dollar\r\n * will be worth < $1.\r\n * Numerically this is found using:\r\n * N = Notional of bond\r\n * P = price of token\r\n * T = number of tokens\r\n * R1 = low price range\r\n * C = collateral per pair, should be N/R1\r\n * T = min(1,(R1/P)*C)\r\n * If you want a yield dollar denominated as N = $1, you should set C to 1/R1. In that case, T = min(1,1/P).\r\n * - At any price below the low price range (R1) the long side effectively holds a fixed number of collateral equal to\r\n * collateralPerPair from the LSP with the value of expiryPercentLong = 1. This is the max payout in collateral.\r\n * - Any price equal to or above R1 gives a payout equivalent to a yield dollar (bond) of notional N. In this range the\r\n * expiryPercentLong shifts to keep the payout in dollar terms equal to the bond notional.\r\n * With this equation, the contract deployer does not need to specify the bond notional N. The notional can be calculated\r\n * by taking R1*collateralPerPair from the LSP.\r\n */\r\ncontract CappedYieldDollarLongShortPairFinancialProductLibrary is LongShortPairFinancialProductLibrary, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    mapping(address => uint256) public lowPriceRanges;\r\n\r\n    /**\r\n     * @notice Enables any address to set the low price range for an associated financial product.\r\n     * @param longShortPair address of the LSP contract.\r\n     * @param lowPriceRange low price range below which the payout transforms from a yield dollar to a short put option.\r\n     * @dev above the lowPriceRange the contract will payout a fixed amount of\r\n     * lowPriceRange*collateralPerPair (i.e the \"notional\" of the yield dollar).\r\n     * @dev Note: a) Any address can set these parameters b) existing LSP parameters for address not set.\r\n     * c) low price range can only be set once to prevent the deployer from changing the parameters after the fact.\r\n     * d) For safety, a low price range should be set before depositing any synthetic tokens in a liquidity pool.\r\n     * e) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\r\n     */\r\n    function setLongShortPairParameters(address longShortPair, uint256 lowPriceRange) public nonReentrant() {\r\n        require(ExpiringContractInterface(longShortPair).expirationTimestamp() != 0, \"Invalid LSP address\");\r\n        require(lowPriceRanges[longShortPair] == 0, \"Parameters already set\");\r\n\r\n        lowPriceRanges[longShortPair] = lowPriceRange;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a number between 0 and 1e18 to indicate how much collateral each long and short token are\r\n     * entitled to per collateralPerPair.\r\n     * @param expiryPrice price from the optimistic oracle for the LSP price identifier.\r\n     * @return expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\r\n     */\r\n    function percentageLongCollateralAtExpiry(int256 expiryPrice)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (uint256)\r\n    {\r\n        uint256 contractLowPriceRange = lowPriceRanges[msg.sender];\r\n        require(contractLowPriceRange != 0, \"Params not set for calling LSP\");\r\n\r\n        // This function returns a value between 0 and 1e18 to be used in conjunction with the LSP collateralPerPair\r\n        // that allocates collateral between the short and long tokens on expiry. This can be simplified by considering\r\n        // the price in two discrete ranges: 1) below the low price range, 2) above the low price range.\r\n        uint256 positiveExpiryPrice = expiryPrice > 0 ? uint256(expiryPrice) : 0;\r\n\r\n        // For expiry prices below lower bound, return expiryPercentLong = 1 (full position)\r\n        if (positiveExpiryPrice <= contractLowPriceRange) return FixedPoint.fromUnscaledUint(1).rawValue;\r\n        // For expiry prices above lower bound. For example, if the lower bound of Sushi is $4, collateral per pair\r\n        // is 0.25, and the expiry price is $12, the payout will be (4/12)*0.25, or .08333 Sushi. With Sushi at $12,\r\n        // .08333 Sushi is equal to $1.\r\n        return FixedPoint.Unsigned(contractLowPriceRange).div(FixedPoint.Unsigned(positiveExpiryPrice)).rawValue;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/CoveredCallLongShortPairFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"./LongShortPairFinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Covered call Long Short Pair Financial Product Library.\r\n * @notice Adds settlement logic to create covered call LSPs. The contract will payout a scaled amount of collateral\r\n * depending on where the settlement price lands relative to the call's strike price. If the settlement is below the\r\n * strike price then longs expire worthless. If the settlement is above the strike then the payout is the fraction above\r\n * the strike defined by (expiryPrice - strikePrice) / expiryPrice. For example, consider a covered call option\r\n * collateralized in ETH, with a strike a price of 3000.\r\n * - If the price is less than 3000 then the each long is worth 0 and each short is worth collateralPerPair.\r\n * - If the price is more than 3000 then each long is worth the fraction of collateralPerPair that was in the money and\r\n * each short is worth the remaining collateralPerPair.\r\n * - Say settlement price is 3500.  Then expiryPercentLong = (3500 - 3000) / 3500 = 0.143. The value of this 0.143 ETH\r\n * is worth 0.143*3500=500 which is the percentage of the collateralPerPair that was above the strike price.\r\n */\r\ncontract CoveredCallLongShortPairFinancialProductLibrary is LongShortPairFinancialProductLibrary, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public longShortPairStrikePrices;\r\n\r\n    /**\r\n     * @notice Enables any address to set the strike price for an associated LSP.\r\n     * @param longShortPair address of the LSP.\r\n     * @param strikePrice the strike price for the covered call for the associated LSP.\r\n     * @dev Note: a) Any address can set the initial strike price b) A strike price cannot be 0.\r\n     * c) A strike price can only be set once to prevent the deployer from changing the strike after the fact.\r\n     * d) For safety, a strike price should be set before depositing any synthetic tokens in a liquidity pool.\r\n     * e) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\r\n     */\r\n    function setLongShortPairParameters(address longShortPair, uint256 strikePrice) public nonReentrant() {\r\n        require(ExpiringContractInterface(longShortPair).expirationTimestamp() != 0, \"Invalid LSP address\");\r\n        require(longShortPairStrikePrices[longShortPair] == 0, \"Parameters already set\");\r\n\r\n        longShortPairStrikePrices[longShortPair] = strikePrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a number between 0 and 1e18 to indicate how much collateral each long and short token are entitled\r\n     * to per collateralPerPair.\r\n     * @param expiryPrice price from the optimistic oracle for the LSP price identifier.\r\n     * @return expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\r\n     */\r\n    function percentageLongCollateralAtExpiry(int256 expiryPrice)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (uint256)\r\n    {\r\n        uint256 contractStrikePrice = longShortPairStrikePrices[msg.sender];\r\n        require(contractStrikePrice != 0, \"Params not set for calling LSP\");\r\n\r\n        // If the expiry price is less than the strike price then the long options expire worthless (out of the money).\r\n        // Note we do not consider negative expiry prices in this call option implementation.\r\n        if (expiryPrice < 0 || uint256(expiryPrice) < contractStrikePrice)\r\n            return FixedPoint.fromUnscaledUint(0).rawValue;\r\n\r\n        // Else, token expires to be worth the fraction of a collateral token that's in the money. eg if ETH is $3500\r\n        // and strike is $3000, long token is redeemable for (3500-3000)/3500 = 0.143 WETH which is worth $500 and the\r\n        // short token is worth the remaining 0.8. This is strictly < 1, tending to 1 as the expiry tends to infinity.\r\n        return\r\n            (FixedPoint.Unsigned(uint256(expiryPrice)).sub(FixedPoint.Unsigned(contractStrikePrice)))\r\n                .div(FixedPoint.Unsigned(uint256(expiryPrice)))\r\n                .rawValue;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/FlooredLinearLongShortPairFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\r\n\r\nimport \"./LongShortPairFinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Floored Linear Long Short Pair Financial Product Library.\r\n * @notice Adds settlement logic to create floored linear LSPs. The contract will payout a scaled amount of collateral\r\n * depending on where the settlement price lands within a price range between a lowerBound and an upperBound with\r\n * configured minimum floorPercentage payout for all prices below lowerBound. If settlement price is within the price\r\n * range then the expiryPercentLong is defined by (expiryPrice - lowerBound) / (upperBound - lowerBound) *\r\n * (1 - floorPercentage) + floorPercentage. This number represents the amount of collateral from the collateralPerPair\r\n * that will be sent to the long side. If the price is at or higher than the upperBound then expiryPercentLong = 1.\r\n * If the price is at or lower than the lowerBound then expiryPercentLong = floorPercentage. For example, consider a\r\n * floored linear LSP on the price of ETH collateralized in USDC with an upperBound = 4000, lowerBound = 2000 and\r\n * floorPercentage = 20% with a collateralPerPair of 1000 (i.e each pair of long and shorts is worth 1000 USDC). At\r\n * settlement the expiryPercentLong would equal 1 (each long worth 1000 and short worth 0) if ETH price was >= 4000 and\r\n * it would equal 0.2 if <= 2000 (each long is worth minimum 200 and each short is worth maximum 800). If between the\r\n * two (say 3500) then expiryPercentLong = (3500 - 2000) / (4000 - 2000) * (1 - 0.2) + 0.2 = 0.8. Therefore each long\r\n * is worth 800 and each short is worth 200.\r\n */\r\ncontract FlooredLinearLongShortPairFinancialProductLibrary is LongShortPairFinancialProductLibrary, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SignedSafeMath for int256;\r\n\r\n    struct LinearLongShortPairParameters {\r\n        int256 upperBound;\r\n        int256 lowerBound;\r\n        uint256 floorPercentage;\r\n    }\r\n\r\n    mapping(address => LinearLongShortPairParameters) public longShortPairParameters;\r\n\r\n    /**\r\n     * @notice Enables any address to set the parameters for an associated financial product.\r\n     * @param longShortPair address of the LSP contract.\r\n     * @param upperBound the upper price that the linear LSP will operate within.\r\n     * @param lowerBound the lower price that the linear LSP will operate within.\r\n     * @param floorPercentage the lowest possible payout percentage from collateralPerPair to each long token expressed\r\n     * with 1e18 decimals. E.g., a 20% floor percentage should be expressed as 200000000000000000.\r\n     * @dev Note: a) Any address can set these parameters b) existing LSP parameters for address not set.\r\n     * c) upperBound > lowerBound.\r\n     * d) floorPercentage <= 1e18 (no need to check >= 0 as floorPercentage is unsigned).\r\n     * e) parameters can only be set once to prevent the deployer from changing the parameters after the fact.\r\n     * f) For safety, parameters should be set before depositing any synthetic tokens in a liquidity pool.\r\n     * g) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\r\n     */\r\n    function setLongShortPairParameters(\r\n        address longShortPair,\r\n        int256 upperBound,\r\n        int256 lowerBound,\r\n        uint256 floorPercentage\r\n    ) public nonReentrant() {\r\n        require(ExpiringContractInterface(longShortPair).expirationTimestamp() != 0, \"Invalid LSP address\");\r\n        require(upperBound > lowerBound, \"Invalid bounds\");\r\n        require(floorPercentage <= 1e18, \"Invalid floor percentage\");\r\n\r\n        LinearLongShortPairParameters memory params = longShortPairParameters[longShortPair];\r\n        require(params.upperBound == 0 && params.lowerBound == 0, \"Parameters already set\");\r\n\r\n        longShortPairParameters[longShortPair] = LinearLongShortPairParameters({\r\n            upperBound: upperBound,\r\n            lowerBound: lowerBound,\r\n            floorPercentage: floorPercentage\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a number between floorPercentage and 1e18 to indicate how much collateral each long and short\r\n     * token is entitled to per collateralPerPair.\r\n     * @param expiryPrice price from the optimistic oracle for the LSP price identifier.\r\n     * @return expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\r\n     */\r\n    function percentageLongCollateralAtExpiry(int256 expiryPrice)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (uint256)\r\n    {\r\n        LinearLongShortPairParameters memory params = longShortPairParameters[msg.sender];\r\n        require(params.upperBound != 0 || params.lowerBound != 0, \"Params not set for calling LSP\");\r\n\r\n        if (expiryPrice >= params.upperBound) return 1e18;\r\n\r\n        if (expiryPrice <= params.lowerBound) return params.floorPercentage;\r\n\r\n        // if not exceeding bounds, expiryPercentLong = (expiryPrice - lowerBound) / (upperBound - lowerBound) *\r\n        // (1 - floorPercentage) + floorPercentage\r\n        return\r\n            FixedPoint\r\n                .Unsigned(uint256(expiryPrice - params.lowerBound))\r\n                .div(FixedPoint.Unsigned(uint256(params.upperBound - params.lowerBound)))\r\n                .mul(FixedPoint.Unsigned(1e18 - params.floorPercentage))\r\n                .add(FixedPoint.Unsigned(params.floorPercentage))\r\n                .rawValue;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/LinearLongShortPairFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\r\n\r\nimport \"./LongShortPairFinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Linear Long Short Pair Financial Product Library.\r\n * @notice Adds settlement logic to create linear LSPs. The contract will payout a scaled amount of collateral\r\n * depending on where the settlement price lands within a price range between an upperBound and a lowerBound. If\r\n * settlement price is within the price range then the expiryPercentLong is defined by\r\n * (expiryPrice - lowerBound) / (upperBound - lowerBound). This number represent the amount of collateral from the\r\n * collateralPerPair that will be sent to the long and short side. If the price is higher than the upperBound then\r\n * expiryPercentLong = 1. if the price is lower than the lower bound then expiryPercentLong = 0. For example, consider\r\n * a linear LSP on the price of ETH collateralized in USDC with an upperBound = 4000 and lowerBound = 2000 with a\r\n * collateralPerPair of 1000 (i.e each pair of long and shorts is worth 1000 USDC). At settlement the expiryPercentLong\r\n * would equal 1 (each long worth 1000 and short worth 0) if ETH price was > 4000 and it would equal 0 if < 2000\r\n * (each long is worthless and each short is worth 1000). If between the two (say 3500) then expiryPercentLong\r\n * = (3500 - 2000) / (4000 - 2000) = 0.75. Therefore each long is worth 750 and each short is worth 250.\r\n */\r\ncontract LinearLongShortPairFinancialProductLibrary is LongShortPairFinancialProductLibrary, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SignedSafeMath for int256;\r\n\r\n    struct LinearLongShortPairParameters {\r\n        int256 upperBound;\r\n        int256 lowerBound;\r\n    }\r\n\r\n    mapping(address => LinearLongShortPairParameters) public longShortPairParameters;\r\n\r\n    /**\r\n     * @notice Enables any address to set the parameters for an associated financial product.\r\n     * @param longShortPair address of the LSP contract.\r\n     * @param upperBound the upper price that the linear LSP will operate within.\r\n     * @param lowerBound the lower price that the linear LSP will operate within.\r\n     * @dev Note: a) Any address can set these parameters b) existing LSP parameters for address not set.\r\n     * c) upperBound > lowerBound.\r\n     * d) parameters can only be set once to prevent the deployer from changing the parameters after the fact.\r\n     * e) For safety, parameters should be set before depositing any synthetic tokens in a liquidity pool.\r\n     * f) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\r\n     */\r\n    function setLongShortPairParameters(\r\n        address longShortPair,\r\n        int256 upperBound,\r\n        int256 lowerBound\r\n    ) public nonReentrant() {\r\n        require(ExpiringContractInterface(longShortPair).expirationTimestamp() != 0, \"Invalid LSP address\");\r\n        require(upperBound > lowerBound, \"Invalid bounds\");\r\n\r\n        LinearLongShortPairParameters memory params = longShortPairParameters[longShortPair];\r\n        require(params.upperBound == 0 && params.lowerBound == 0, \"Parameters already set\");\r\n\r\n        longShortPairParameters[longShortPair] = LinearLongShortPairParameters({\r\n            upperBound: upperBound,\r\n            lowerBound: lowerBound\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a number between 0 and 1e18 to indicate how much collateral each long and short token is entitled\r\n     * to per collateralPerPair.\r\n     * @param expiryPrice price from the optimistic oracle for the LSP price identifier.\r\n     * @return expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\r\n     */\r\n    function percentageLongCollateralAtExpiry(int256 expiryPrice)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (uint256)\r\n    {\r\n        LinearLongShortPairParameters memory params = longShortPairParameters[msg.sender];\r\n        require(params.upperBound != 0 || params.lowerBound != 0, \"Params not set for calling LSP\");\r\n\r\n        if (expiryPrice >= params.upperBound) return FixedPoint.fromUnscaledUint(1).rawValue;\r\n\r\n        if (expiryPrice <= params.lowerBound) return FixedPoint.fromUnscaledUint(0).rawValue;\r\n\r\n        // if not exceeding bounds, expiryPercentLong = (expiryPrice - lowerBound) / (upperBound - lowerBound)\r\n        return\r\n            FixedPoint\r\n                .Unsigned(uint256(expiryPrice - params.lowerBound))\r\n                .div(FixedPoint.Unsigned(uint256(params.upperBound - params.lowerBound)))\r\n                .rawValue;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/LongShortPairFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\nimport \"../../../../common/implementation/FixedPoint.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\ninterface ExpiringContractInterface {\r\n    function expirationTimestamp() external view returns (uint256);\r\n}\r\n\r\nabstract contract LongShortPairFinancialProductLibrary {\r\n    function percentageLongCollateralAtExpiry(int256 expiryPrice) public view virtual returns (uint256);\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/RangeBondLongShortPairFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\n\r\nimport \"./LongShortPairFinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Range Bond Long Short Pair Financial Product Library\r\n * @notice Adds settlement logic to create range bond LSPs. A range bond is the combination of a Yield dollar, short put\r\n * option and long call option enabling the token sponsor to issue structured products to unlock DeFi treasuries.\r\n * A range bond is defined as = Yield Dollar - Put Option + Call option. Numerically this is found using:\r\n * N = Notional of bond\r\n * P = price of token\r\n * T = number of tokens\r\n * R1 = low price range\r\n * R2 = high price range\r\n * T = min(N/P,N/R1) + max((N/R2*(P-R2))/P,0)\r\n * - At any price below the low price range (R1) the long side effectively holds a fixed number of collateral equal to\r\n * collateralPerPair from the LSP with the value of expiryPercentLong = 1. This is the max payout in collateral.\r\n * - Any price between R1 and R2 gives a payout equivalent to a yield dollar (bond) of notional N. In this range the\r\n * expiryPercentLong shifts to keep the payout in dollar terms equal to the bond notional.\r\n * - At any price above R2 the long holders are entitled to a fixed, minimum number of collateral equal to N/R2 with a\r\n * expiryPercentLong=(N/R2)/collateralPerPair.\r\n * The expression for the number of tokens paid out to the long side (T above) can be algebraically simplified,\r\n * transformed to remove the notional and reframed to express the expiryPercentLong as [min(max(1/R2,1/P),1/R1)]/(1/R1)\r\n * With this equation, the contract deployer does not need to specify the bond notional N. The notional can be calculated\r\n * by taking R1*collateralPerPair from the LSP.\r\n */\r\ncontract RangeBondLongShortPairFinancialProductLibrary is LongShortPairFinancialProductLibrary, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SignedSafeMath for int256;\r\n\r\n    struct RangeBondLongShortPairParameters {\r\n        uint256 highPriceRange;\r\n        uint256 lowPriceRange;\r\n    }\r\n\r\n    mapping(address => RangeBondLongShortPairParameters) public longShortPairParameters;\r\n\r\n    /**\r\n     * @notice Enables any address to set the parameters price for an associated financial product.\r\n     * @param longShortPair address of the LSP contract.\r\n     * @param highPriceRange high price range after which the payout transforms from a yield dollar to a call option.\r\n     * @param lowPriceRange low price range below which the payout transforms from a yield dollar to a short put option.\r\n     * @dev between highPriceRange and lowPriceRange the contract will payout a fixed amount of\r\n     * lowPriceRange*collateralPerPair (i.e the \"notional\" of the yield dollar).\r\n     * @dev Note: a) Any address can set these parameters b) existing LSP parameters for address not set.\r\n     * c) highPriceRange > lowPriceRange.\r\n     * d) parameters price can only be set once to prevent the deployer from changing the parameters after the fact.\r\n     * e) For safety, a parameters should be set before depositing any synthetic tokens in a liquidity pool.\r\n     * f) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\r\n     */\r\n    function setLongShortPairParameters(\r\n        address longShortPair,\r\n        uint256 highPriceRange,\r\n        uint256 lowPriceRange\r\n    ) public nonReentrant() {\r\n        require(ExpiringContractInterface(longShortPair).expirationTimestamp() != 0, \"Invalid LSP address\");\r\n\r\n        require(highPriceRange > lowPriceRange, \"Invalid bounds\");\r\n\r\n        RangeBondLongShortPairParameters memory params = longShortPairParameters[longShortPair];\r\n        require(params.highPriceRange == 0 && params.lowPriceRange == 0, \"Parameters already set\");\r\n\r\n        longShortPairParameters[longShortPair] = RangeBondLongShortPairParameters({\r\n            highPriceRange: highPriceRange,\r\n            lowPriceRange: lowPriceRange\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a number between 0 and 1e18 to indicate how much collateral each long and short token are\r\n     * entitled to per collateralPerPair.\r\n     * @param expiryPrice price from the optimistic oracle for the LSP price identifier.\r\n     * @return expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\r\n     */\r\n    function percentageLongCollateralAtExpiry(int256 expiryPrice)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (uint256)\r\n    {\r\n        RangeBondLongShortPairParameters memory params = longShortPairParameters[msg.sender];\r\n        require(params.highPriceRange != 0 || params.lowPriceRange != 0, \"Params not set for calling LSP\");\r\n\r\n        // This function returns a value between 0 and 1e18 to be used in conjunction with the LSP collateralPerPair\r\n        // that allocates collateral between the short and long tokens on expiry. This can be simplified by considering\r\n        // the price in three discrete ranges: 1) below the low price range, 2) between low and high range and 3) above\r\n        // the high price range.\r\n        uint256 positiveExpiryPrice = expiryPrice > 0 ? uint256(expiryPrice) : 0;\r\n\r\n        // 1) The long position is entitled to the full position in this range. The short token is worth 0.\r\n        if (positiveExpiryPrice <= params.lowPriceRange) return FixedPoint.fromUnscaledUint(1).rawValue;\r\n        // 2) Within the range, the long position is entitled to the bond notional value which is equal to\r\n        // (collateral tokens * lowPriceRange).\r\n        if (positiveExpiryPrice <= params.highPriceRange)\r\n            return FixedPoint.Unsigned(params.lowPriceRange).div(FixedPoint.Unsigned(positiveExpiryPrice)).rawValue;\r\n        // 3) Above the range, the long position is entitled to a fixed number of tokens.\r\n        return FixedPoint.Unsigned(params.lowPriceRange).div(FixedPoint.Unsigned(params.highPriceRange)).rawValue;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/SimpleSuccessTokenLongShortPairFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./LongShortPairFinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Simple Success Token Long Short Pair Financial Product Library.\r\n * @notice Adds settlement logic to create success token LSPs. A success token pays out 50% of collateral as a\r\n * floor, with the remaining 50% functioning like an embedded covered call.\r\n * If the settlement is below the strike price then longs are worth 50% of collateral.\r\n * If the settlement is above the strike then the payout is equal to:\r\n * 0.5 + (0.5 * (expiryPrice - strikePrice) / expiryPrice)\r\n * For example, consider a covered call option collateralized in SUSHI, with a strike a price of $20,\r\n * and collateralPerPair of 2.\r\n * - If the price is less than $20 then the each long is worth 0.5 collateralPerPair and each short is worth 0.5\r\n * collateralPerPair. i.e., each long is worth 1 SUSHI (calls expire worthless).\r\n * - If the price is more than $20 then each long is worth 0.5 collateralPerPair plus 0.5 times the fraction of\r\n * collateralPerPair that was in the money, and each short is worth the remaining collateralPerPair.\r\n * - Say settlement price is $30.  Then expiryPercentLong = 0.5 + (0.5 * (30 - 20) / 30) = 0.6667.\r\n * If the collateralPerPair is 2, that means the long payout is 0.6667*2 = 1.3333 $SUSHI, which at a settlement\r\n * price of $30 is worth $40. This is equivalent to the value of 1 $SUSHI plus the value of the $20 strike\r\n * embedded call.\r\n */\r\ncontract SimpleSuccessTokenLongShortPairFinancialProductLibrary is LongShortPairFinancialProductLibrary, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    mapping(address => uint256) public longShortPairStrikePrices;\r\n    uint256 basePercentage = 500000000000000000; // 0.5 with 18 decimals\r\n    uint256 variablePercentage = uint256(1000000000000000000) - basePercentage;\r\n\r\n    /**\r\n     * @notice Enables any address to set the strike price for an associated LSP.\r\n     * @param longShortPair address of the LSP.\r\n     * @param strikePrice the strike price for the covered call for the associated LSP.\r\n     * @dev Note: a) Any address can set the initial strike price b) A strike price cannot be 0.\r\n     * c) A strike price can only be set once to prevent the deployer from changing the strike after the fact.\r\n     * d) For safety, a strike price should be set before depositing any synthetic tokens in a liquidity pool.\r\n     * e) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\r\n     */\r\n    function setLongShortPairParameters(address longShortPair, uint256 strikePrice) public nonReentrant() {\r\n        require(ExpiringContractInterface(longShortPair).expirationTimestamp() != 0, \"Invalid LSP address\");\r\n        require(longShortPairStrikePrices[longShortPair] == 0, \"Parameters already set\");\r\n\r\n        longShortPairStrikePrices[longShortPair] = strikePrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a number between 0 and 1e18 to indicate how much collateral each long and short token are entitled\r\n     * to per collateralPerPair.\r\n     * @param expiryPrice price from the optimistic oracle for the LSP price identifier.\r\n     * @return expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\r\n     */\r\n    function percentageLongCollateralAtExpiry(int256 expiryPrice)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (uint256)\r\n    {\r\n        uint256 contractStrikePrice = longShortPairStrikePrices[msg.sender];\r\n        require(contractStrikePrice != 0, \"Params not set for calling LSP\");\r\n\r\n        // If the expiry price is less than the strike price then the long options expire worthless (out of the money).\r\n        // In this case, return of value of 50% (half of collateral goes to long)\r\n        // Note we do not consider negative expiry prices in this call option implementation.\r\n        uint256 positiveExpiryPrice = expiryPrice > 0 ? uint256(expiryPrice) : 0;\r\n        if (positiveExpiryPrice == 0 || uint256(positiveExpiryPrice) <= contractStrikePrice) return basePercentage;\r\n\r\n        // Else, token expires to be worth the 0.5 of the collateral plus 0.5 * the fraction of a collateral token\r\n        // that's in the money.\r\n        // eg if SUSHI is $30 and strike is $20, long token is redeemable for 0.5 + 0.5*(30-20)/30 = 0.6667% which if the\r\n        // collateralPerPair is 2, is worth 1.3333 $SUSHI, which is worth $40 if 1 $SUSHI is worth $30.\r\n        // This return value is strictly < 1, tending to 1 as the expiryPrice tends to infinity.\r\n        return\r\n            (\r\n                FixedPoint.Unsigned(basePercentage).add(\r\n                    FixedPoint\r\n                        .Unsigned(variablePercentage)\r\n                        .mul(\r\n                        FixedPoint.Unsigned(uint256(positiveExpiryPrice)).sub(FixedPoint.Unsigned(contractStrikePrice))\r\n                    )\r\n                        .div(FixedPoint.Unsigned(uint256(positiveExpiryPrice)))\r\n                )\r\n            )\r\n                .rawValue;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/SuccessTokenLongShortPairFinancialProductLibrary.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./LongShortPairFinancialProductLibrary.sol\";\r\nimport \"../../../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Success Token Long Short Pair Financial Product Library.\r\n * @notice Adds settlement logic to create success token LSPs. A success token pays out a fixed amount of\r\n * collateral as a floor, with the remaining amount functioning like an embedded option. The embedded\r\n * option in this case uses payout logic that resembles a covered call. I.e., the token expires to be worth\r\n * basePercentage + (1 - basePercentage) * (expiryPrice - strikePrice).\r\n */\r\ncontract SuccessTokenLongShortPairFinancialProductLibrary is LongShortPairFinancialProductLibrary, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    struct SuccessTokenLongShortPairParameters {\r\n        uint256 strikePrice;\r\n        uint256 basePercentage;\r\n    }\r\n\r\n    mapping(address => SuccessTokenLongShortPairParameters) public longShortPairParameters;\r\n\r\n    /**\r\n     * @notice Enables any address to set the strike price for an associated LSP.\r\n     * @param longShortPair address of the LSP.\r\n     * @param strikePrice the strike price for the covered call for the associated LSP.\r\n     * @param basePercentage the base percentage of collateral per pair paid out to long tokens, expressed\r\n     * with 1e18 decimals. E.g., a 50% base percentage should be expressed 500000000000000000, or 0.5 with\r\n     * 1e18 decimals. The base percentage cannot be set to 0.\r\n     * @dev Note: a) Any address can set the initial strike price b) A strike price cannot be 0.\r\n     * c) A strike price can only be set once to prevent the deployer from changing the strike after the fact.\r\n     * d) For safety, a strike price should be set before depositing any synthetic tokens in a liquidity pool.\r\n     * e) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\r\n     */\r\n    function setLongShortPairParameters(\r\n        address longShortPair,\r\n        uint256 strikePrice,\r\n        uint256 basePercentage\r\n    ) public nonReentrant() {\r\n        require(ExpiringContractInterface(longShortPair).expirationTimestamp() != 0, \"Invalid LSP address\");\r\n        SuccessTokenLongShortPairParameters memory params = longShortPairParameters[longShortPair];\r\n        require(params.strikePrice == 0 && params.basePercentage == 0, \"Parameters already set\");\r\n        require(strikePrice != 0 && basePercentage != 0, \"Base percentage and strike price cannot be set to 0\");\r\n\r\n        longShortPairParameters[longShortPair] = SuccessTokenLongShortPairParameters({\r\n            strikePrice: strikePrice,\r\n            basePercentage: basePercentage\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a number between 0 and 1e18 to indicate how much collateral each long and short token are entitled\r\n     * to per collateralPerPair.\r\n     * @param expiryPrice price from the optimistic oracle for the LSP price identifier.\r\n     * @return expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\r\n     */\r\n    function percentageLongCollateralAtExpiry(int256 expiryPrice)\r\n        public\r\n        view\r\n        override\r\n        nonReentrantView()\r\n        returns (uint256)\r\n    {\r\n        SuccessTokenLongShortPairParameters memory params = longShortPairParameters[msg.sender];\r\n        require(params.strikePrice != 0 || params.basePercentage != 0, \"Params not set for calling LSP\");\r\n\r\n        // If the expiry price is less than the strike price then the long options expire worthless (out of the money).\r\n        // In this case, return of value of the base percentage to the long tokenholders.\r\n        // Note we do not consider negative expiry prices in this implementation.\r\n        uint256 positiveExpiryPrice = expiryPrice > 0 ? uint256(expiryPrice) : 0;\r\n        if (positiveExpiryPrice == 0 || positiveExpiryPrice <= params.strikePrice) return params.basePercentage;\r\n\r\n        // Else, token expires to be worth basePercentage + (1 - basePercentage) * (expiryPrice - strikePrice).\r\n        // E.g., if base percentage is 50%, $TOKEN is $30, and strike is $20, long token is redeemable for\r\n        // 0.5 + 0.5*(30-20)/30 = 0.6667%, which if the collateralPerPair is 2, is worth 1.3333 $TOKEN, which is\r\n        // worth $40 if 1 $TOKEN is worth $30. This return value is strictly < 1. The return value tends to 1 as\r\n        // the expiryPrice tends to infinity. Due to rounding down and precision errors, this may return a very\r\n        // slightly smaller value than expected.\r\n        return\r\n            (\r\n                FixedPoint.Unsigned(params.basePercentage).add(\r\n                    FixedPoint\r\n                        .Unsigned(1e18 - params.basePercentage)\r\n                        .mul(FixedPoint.Unsigned(positiveExpiryPrice).sub(FixedPoint.Unsigned(params.strikePrice)))\r\n                        .div(FixedPoint.Unsigned(positiveExpiryPrice))\r\n                )\r\n            )\r\n                .rawValue;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/FundingRateApplier.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/implementation/AncillaryData.sol\";\r\n\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../../optimistic-oracle-v2/interfaces/OptimisticOracleInterface.sol\";\r\nimport \"../perpetual-multiparty/ConfigStoreInterface.sol\";\r\n\r\nimport \"./EmergencyShutdownable.sol\";\r\nimport \"./FeePayer.sol\";\r\n\r\n/**\r\n * @title FundingRateApplier contract.\r\n * @notice Provides funding rate payment functionality for the Perpetual contract.\r\n */\r\n\r\nabstract contract FundingRateApplier is EmergencyShutdownable, FeePayer {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using FixedPoint for FixedPoint.Signed;\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    /****************************************\r\n     * FUNDING RATE APPLIER DATA STRUCTURES *\r\n     ****************************************/\r\n\r\n    struct FundingRate {\r\n        // Current funding rate value.\r\n        FixedPoint.Signed rate;\r\n        // Identifier to retrieve the funding rate.\r\n        bytes32 identifier;\r\n        // Tracks the cumulative funding payments that have been paid to the sponsors.\r\n        // The multiplier starts at 1, and is updated by computing cumulativeFundingRateMultiplier * (1 + effectivePayment).\r\n        // Put another way, the cumulativeFeeMultiplier is (1 + effectivePayment1) * (1 + effectivePayment2) ...\r\n        // For example:\r\n        // The cumulativeFundingRateMultiplier should start at 1.\r\n        // If a 1% funding payment is paid to sponsors, the multiplier should update to 1.01.\r\n        // If another 1% fee is charged, the multiplier should be 1.01^2 (1.0201).\r\n        FixedPoint.Unsigned cumulativeMultiplier;\r\n        // Most recent time that the funding rate was updated.\r\n        uint256 updateTime;\r\n        // Most recent time that the funding rate was applied and changed the cumulative multiplier.\r\n        uint256 applicationTime;\r\n        // The time for the active (if it exists) funding rate proposal. 0 otherwise.\r\n        uint256 proposalTime;\r\n    }\r\n\r\n    FundingRate public fundingRate;\r\n\r\n    // Remote config store managed an owner.\r\n    ConfigStoreInterface public configStore;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event FundingRateUpdated(int256 newFundingRate, uint256 indexed updateTime, uint256 reward);\r\n\r\n    /****************************************\r\n     *              MODIFIERS               *\r\n     ****************************************/\r\n\r\n    // This is overridden to both pay fees (which is done by applyFundingRate()) and apply the funding rate.\r\n    modifier fees override {\r\n        // Note: the funding rate is applied on every fee-accruing transaction, where the total change is simply the\r\n        // rate applied linearly since the last update. This implies that the compounding rate depends on the frequency\r\n        // of update transactions that have this modifier, and it never reaches the ideal of continuous compounding.\r\n        // This approximate-compounding pattern is common in the Ethereum ecosystem because of the complexity of\r\n        // compounding data on-chain.\r\n        applyFundingRate();\r\n        _;\r\n    }\r\n\r\n    // Note: this modifier is intended to be used if the caller intends to _only_ pay regular fees.\r\n    modifier paysRegularFees {\r\n        payRegularFees();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructs the FundingRateApplier contract. Called by child contracts.\r\n     * @param _fundingRateIdentifier identifier that tracks the funding rate of this contract.\r\n     * @param _collateralAddress address of the collateral token.\r\n     * @param _finderAddress Finder used to discover financial-product-related contracts.\r\n     * @param _configStoreAddress address of the remote configuration store managed by an external owner.\r\n     * @param _tokenScaling initial scaling to apply to the token value (i.e. scales the tracking index).\r\n     * @param _timerAddress address of the timer contract in test envs, otherwise 0x0.\r\n     */\r\n    constructor(\r\n        bytes32 _fundingRateIdentifier,\r\n        address _collateralAddress,\r\n        address _finderAddress,\r\n        address _configStoreAddress,\r\n        FixedPoint.Unsigned memory _tokenScaling,\r\n        address _timerAddress\r\n    ) FeePayer(_collateralAddress, _finderAddress, _timerAddress) EmergencyShutdownable() {\r\n        uint256 currentTime = getCurrentTime();\r\n        fundingRate.updateTime = currentTime;\r\n        fundingRate.applicationTime = currentTime;\r\n\r\n        // Seed the cumulative multiplier with the token scaling, from which it will be scaled as funding rates are\r\n        // applied over time.\r\n        fundingRate.cumulativeMultiplier = _tokenScaling;\r\n\r\n        fundingRate.identifier = _fundingRateIdentifier;\r\n        configStore = ConfigStoreInterface(_configStoreAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice This method takes 3 distinct actions:\r\n     * 1. Pays out regular fees.\r\n     * 2. If possible, resolves the outstanding funding rate proposal, pulling the result in and paying out the rewards.\r\n     * 3. Applies the prevailing funding rate over the most recent period.\r\n     */\r\n    function applyFundingRate() public paysRegularFees() nonReentrant() {\r\n        _applyEffectiveFundingRate();\r\n    }\r\n\r\n    /**\r\n     * @notice Proposes a new funding rate. Proposer receives a reward if correct.\r\n     * @param rate funding rate being proposed.\r\n     * @param timestamp time at which the funding rate was computed.\r\n     */\r\n    function proposeFundingRate(FixedPoint.Signed memory rate, uint256 timestamp)\r\n        external\r\n        fees()\r\n        nonReentrant()\r\n        returns (FixedPoint.Unsigned memory totalBond)\r\n    {\r\n        require(fundingRate.proposalTime == 0);\r\n        _validateFundingRate(rate);\r\n\r\n        // Timestamp must be after the last funding rate update time, within the last 30 minutes.\r\n        uint256 currentTime = getCurrentTime();\r\n        uint256 updateTime = fundingRate.updateTime;\r\n        require(timestamp > updateTime && timestamp >= currentTime.sub(_getConfig().proposalTimePastLimit));\r\n\r\n        // Set the proposal time in order to allow this contract to track this request.\r\n        fundingRate.proposalTime = timestamp;\r\n\r\n        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\r\n\r\n        // Set up optimistic oracle.\r\n        bytes32 identifier = fundingRate.identifier;\r\n        bytes memory ancillaryData = _getAncillaryData();\r\n        // Note: requestPrice will revert if `timestamp` is less than the current block timestamp.\r\n        optimisticOracle.requestPrice(identifier, timestamp, ancillaryData, collateralCurrency, 0);\r\n        totalBond = FixedPoint.Unsigned(\r\n            optimisticOracle.setBond(\r\n                identifier,\r\n                timestamp,\r\n                ancillaryData,\r\n                _pfc().mul(_getConfig().proposerBondPercentage).rawValue\r\n            )\r\n        );\r\n\r\n        // Pull bond from caller and send to optimistic oracle.\r\n        if (totalBond.isGreaterThan(0)) {\r\n            collateralCurrency.safeTransferFrom(msg.sender, address(this), totalBond.rawValue);\r\n            collateralCurrency.safeIncreaseAllowance(address(optimisticOracle), totalBond.rawValue);\r\n        }\r\n\r\n        optimisticOracle.proposePriceFor(\r\n            msg.sender,\r\n            address(this),\r\n            identifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            rate.rawValue\r\n        );\r\n    }\r\n\r\n    // Returns a token amount scaled by the current funding rate multiplier.\r\n    // Note: if the contract has paid fees since it was deployed, the raw value should be larger than the returned value.\r\n    function _getFundingRateAppliedTokenDebt(FixedPoint.Unsigned memory rawTokenDebt)\r\n        internal\r\n        view\r\n        returns (FixedPoint.Unsigned memory tokenDebt)\r\n    {\r\n        return rawTokenDebt.mul(fundingRate.cumulativeMultiplier);\r\n    }\r\n\r\n    function _getOptimisticOracle() internal view returns (OptimisticOracleInterface) {\r\n        return OptimisticOracleInterface(finder.getImplementationAddress(OracleInterfaces.OptimisticOracle));\r\n    }\r\n\r\n    function _getConfig() internal returns (ConfigStoreInterface.ConfigSettings memory) {\r\n        return configStore.updateAndGetCurrentConfig();\r\n    }\r\n\r\n    function _updateFundingRate() internal {\r\n        uint256 proposalTime = fundingRate.proposalTime;\r\n        // If there is no pending proposal then do nothing. Otherwise check to see if we can update the funding rate.\r\n        if (proposalTime != 0) {\r\n            // Attempt to update the funding rate.\r\n            OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\r\n            bytes32 identifier = fundingRate.identifier;\r\n            bytes memory ancillaryData = _getAncillaryData();\r\n\r\n            // Try to get the price from the optimistic oracle. This call will revert if the request has not resolved\r\n            // yet. If the request has not resolved yet, then we need to do additional checks to see if we should\r\n            // \"forget\" the pending proposal and allow new proposals to update the funding rate.\r\n            try optimisticOracle.settleAndGetPrice(identifier, proposalTime, ancillaryData) returns (int256 price) {\r\n                // If successful, determine if the funding rate state needs to be updated.\r\n                // If the request is more recent than the last update then we should update it.\r\n                uint256 lastUpdateTime = fundingRate.updateTime;\r\n                if (proposalTime >= lastUpdateTime) {\r\n                    // Update funding rates\r\n                    fundingRate.rate = FixedPoint.Signed(price);\r\n                    fundingRate.updateTime = proposalTime;\r\n\r\n                    // If there was no dispute, send a reward.\r\n                    FixedPoint.Unsigned memory reward = FixedPoint.fromUnscaledUint(0);\r\n                    OptimisticOracleInterface.Request memory request =\r\n                        optimisticOracle.getRequest(address(this), identifier, proposalTime, ancillaryData);\r\n                    if (request.disputer == address(0)) {\r\n                        reward = _pfc().mul(_getConfig().rewardRatePerSecond).mul(proposalTime.sub(lastUpdateTime));\r\n                        if (reward.isGreaterThan(0)) {\r\n                            _adjustCumulativeFeeMultiplier(reward, _pfc());\r\n                            collateralCurrency.safeTransfer(request.proposer, reward.rawValue);\r\n                        }\r\n                    }\r\n\r\n                    // This event will only be emitted after the fundingRate struct's \"updateTime\" has been set\r\n                    // to the latest proposal's proposalTime, indicating that the proposal has been published.\r\n                    // So, it suffices to just emit fundingRate.updateTime here.\r\n                    emit FundingRateUpdated(fundingRate.rate.rawValue, fundingRate.updateTime, reward.rawValue);\r\n                }\r\n\r\n                // Set proposal time to 0 since this proposal has now been resolved.\r\n                fundingRate.proposalTime = 0;\r\n            } catch {\r\n                // Stop tracking and allow other proposals to come in if:\r\n                // - The requester address is empty, indicating that the Oracle does not know about this funding rate\r\n                //   request. This is possible if the Oracle is replaced while the price request is still pending.\r\n                // - The request has been disputed.\r\n                OptimisticOracleInterface.Request memory request =\r\n                    optimisticOracle.getRequest(address(this), identifier, proposalTime, ancillaryData);\r\n                if (request.disputer != address(0) || request.proposer == address(0)) {\r\n                    fundingRate.proposalTime = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Constraining the range of funding rates limits the PfC for any dishonest proposer and enhances the\r\n    // perpetual's security. For example, let's examine the case where the max and min funding rates\r\n    // are equivalent to +/- 500%/year. This 1000% funding rate range allows a 8.6% profit from corruption for a\r\n    // proposer who can deter honest proposers for 74 hours:\r\n    // 1000%/year / 360 days / 24 hours * 74 hours max attack time = ~ 8.6%.\r\n    // How would attack work? Imagine that the market is very volatile currently and that the \"true\" funding\r\n    // rate for the next 74 hours is -500%, but a dishonest proposer successfully proposes a rate of +500%\r\n    // (after a two hour liveness) and disputes honest proposers for the next 72 hours. This results in a funding\r\n    // rate error of 1000% for 74 hours, until the DVM can set the funding rate back to its correct value.\r\n    function _validateFundingRate(FixedPoint.Signed memory rate) internal {\r\n        require(\r\n            rate.isLessThanOrEqual(_getConfig().maxFundingRate) &&\r\n                rate.isGreaterThanOrEqual(_getConfig().minFundingRate)\r\n        );\r\n    }\r\n\r\n    // Fetches a funding rate from the Store, determines the period over which to compute an effective fee,\r\n    // and multiplies the current multiplier by the effective fee.\r\n    // A funding rate < 1 will reduce the multiplier, and a funding rate of > 1 will increase the multiplier.\r\n    // Note: 1 is set as the neutral rate because there are no negative numbers in FixedPoint, so we decide to treat\r\n    // values < 1 as \"negative\".\r\n    function _applyEffectiveFundingRate() internal {\r\n        // If contract is emergency shutdown, then the funding rate multiplier should no longer change.\r\n        if (emergencyShutdownTimestamp != 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 currentTime = getCurrentTime();\r\n        uint256 paymentPeriod = currentTime.sub(fundingRate.applicationTime);\r\n\r\n        _updateFundingRate(); // Update the funding rate if there is a resolved proposal.\r\n        fundingRate.cumulativeMultiplier = _calculateEffectiveFundingRate(\r\n            paymentPeriod,\r\n            fundingRate.rate,\r\n            fundingRate.cumulativeMultiplier\r\n        );\r\n\r\n        fundingRate.applicationTime = currentTime;\r\n    }\r\n\r\n    function _calculateEffectiveFundingRate(\r\n        uint256 paymentPeriodSeconds,\r\n        FixedPoint.Signed memory fundingRatePerSecond,\r\n        FixedPoint.Unsigned memory currentCumulativeFundingRateMultiplier\r\n    ) internal pure returns (FixedPoint.Unsigned memory newCumulativeFundingRateMultiplier) {\r\n        // Note: this method uses named return variables to save a little bytecode.\r\n\r\n        // The overall formula that this function is performing:\r\n        //   newCumulativeFundingRateMultiplier =\r\n        //   (1 + (fundingRatePerSecond * paymentPeriodSeconds)) * currentCumulativeFundingRateMultiplier.\r\n        FixedPoint.Signed memory ONE = FixedPoint.fromUnscaledInt(1);\r\n\r\n        // Multiply the per-second rate over the number of seconds that have elapsed to get the period rate.\r\n        FixedPoint.Signed memory periodRate = fundingRatePerSecond.mul(SafeCast.toInt256(paymentPeriodSeconds));\r\n\r\n        // Add one to create the multiplier to scale the existing fee multiplier.\r\n        FixedPoint.Signed memory signedPeriodMultiplier = ONE.add(periodRate);\r\n\r\n        // Max with 0 to ensure the multiplier isn't negative, then cast to an Unsigned.\r\n        FixedPoint.Unsigned memory unsignedPeriodMultiplier =\r\n            FixedPoint.fromSigned(FixedPoint.max(signedPeriodMultiplier, FixedPoint.fromUnscaledInt(0)));\r\n\r\n        // Multiply the existing cumulative funding rate multiplier by the computed period multiplier to get the new\r\n        // cumulative funding rate multiplier.\r\n        newCumulativeFundingRateMultiplier = currentCumulativeFundingRateMultiplier.mul(unsignedPeriodMultiplier);\r\n    }\r\n\r\n    /**\r\n     * @dev We do not need to check that the ancillary data length is less than the hardcoded max length in the\r\n     * OptimisticOracle because the length of the ancillary data is fixed in this function.\r\n     */\r\n    function _getAncillaryData() internal view returns (bytes memory) {\r\n        // When ancillary data is passed to the optimistic oracle, it should be tagged with the token address\r\n        // whose funding rate it's trying to get so that financial contracts can re-use the same identifier for\r\n        // multiple funding rate products.\r\n        return AncillaryData.appendKeyValueAddress(\"\", \"tokenAddress\", _getTokenAddress());\r\n    }\r\n\r\n    function _getTokenAddress() internal view virtual returns (address);\r\n}\r\n"
    },
    "contracts/financial-templates/common/SyntheticToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\nimport \"../../common/implementation/ExpandedERC20.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Burnable and mintable ERC20.\r\n * @dev The contract deployer will initially be the only minter, burner and owner capable of adding new roles.\r\n */\r\n\r\ncontract SyntheticToken is ExpandedERC20, Lockable {\r\n    /**\r\n     * @notice Constructs the SyntheticToken.\r\n     * @param tokenName The name which describes the new token.\r\n     * @param tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.\r\n     * @param tokenDecimals The number of decimals to define token precision.\r\n     */\r\n    constructor(\r\n        string memory tokenName,\r\n        string memory tokenSymbol,\r\n        uint8 tokenDecimals\r\n    ) ExpandedERC20(tokenName, tokenSymbol, tokenDecimals) nonReentrant() {}\r\n\r\n    /**\r\n     * @notice Add Minter role to account.\r\n     * @dev The caller must have the Owner role.\r\n     * @param account The address to which the Minter role is added.\r\n     */\r\n    function addMinter(address account) external override nonReentrant() {\r\n        addMember(uint256(Roles.Minter), account);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove Minter role from account.\r\n     * @dev The caller must have the Owner role.\r\n     * @param account The address from which the Minter role is removed.\r\n     */\r\n    function removeMinter(address account) external nonReentrant() {\r\n        removeMember(uint256(Roles.Minter), account);\r\n    }\r\n\r\n    /**\r\n     * @notice Add Burner role to account.\r\n     * @dev The caller must have the Owner role.\r\n     * @param account The address to which the Burner role is added.\r\n     */\r\n    function addBurner(address account) external override nonReentrant() {\r\n        addMember(uint256(Roles.Burner), account);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes Burner role from account.\r\n     * @dev The caller must have the Owner role.\r\n     * @param account The address from which the Burner role is removed.\r\n     */\r\n    function removeBurner(address account) external nonReentrant() {\r\n        removeMember(uint256(Roles.Burner), account);\r\n    }\r\n\r\n    /**\r\n     * @notice Reset Owner role to account.\r\n     * @dev The caller must have the Owner role.\r\n     * @param account The new holder of the Owner role.\r\n     */\r\n    function resetOwner(address account) external override nonReentrant() {\r\n        resetMember(uint256(Roles.Owner), account);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a given account holds the Minter role.\r\n     * @param account The address which is checked for the Minter role.\r\n     * @return bool True if the provided account is a Minter.\r\n     */\r\n    function isMinter(address account) public view nonReentrantView() returns (bool) {\r\n        return holdsRole(uint256(Roles.Minter), account);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a given account holds the Burner role.\r\n     * @param account The address which is checked for the Burner role.\r\n     * @return bool True if the provided account is a Burner.\r\n     */\r\n    function isBurner(address account) public view nonReentrantView() returns (bool) {\r\n        return holdsRole(uint256(Roles.Burner), account);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./SyntheticToken.sol\";\r\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Factory for creating new mintable and burnable tokens.\r\n */\r\n\r\ncontract TokenFactory is Lockable {\r\n    /**\r\n     * @notice Create a new token and return it to the caller.\r\n     * @dev The caller will become the only minter and burner and the new owner capable of assigning the roles.\r\n     * @param tokenName used to describe the new token.\r\n     * @param tokenSymbol short ticker abbreviation of the name. Ideally < 5 chars.\r\n     * @param tokenDecimals used to define the precision used in the token's numerical representation.\r\n     * @return newToken an instance of the newly created token interface.\r\n     */\r\n    function createToken(\r\n        string calldata tokenName,\r\n        string calldata tokenSymbol,\r\n        uint8 tokenDecimals\r\n    ) external nonReentrant() returns (ExpandedIERC20 newToken) {\r\n        SyntheticToken mintableToken = new SyntheticToken(tokenName, tokenSymbol, tokenDecimals);\r\n        mintableToken.resetOwner(msg.sender);\r\n        newToken = ExpandedIERC20(address(mintableToken));\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/common/WETH9.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n// Copied from the verified code from Etherscan:\r\n// https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code\r\n// And then updated for Solidity version 0.6. Specific changes:\r\n// * Change `function() public` into `receive() external` and `fallback() external`\r\n// * Change `this.balance` to `address(this).balance`\r\n// * Ran prettier\r\ncontract WETH9 {\r\n    string public name = \"Wrapped Ether\";\r\n    string public symbol = \"WETH\";\r\n    uint8 public decimals = 18;\r\n\r\n    event Approval(address indexed src, address indexed guy, uint256 wad);\r\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\r\n    event Deposit(address indexed dst, uint256 wad);\r\n    event Withdrawal(address indexed src, uint256 wad);\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    receive() external payable {\r\n        deposit();\r\n    }\r\n\r\n    fallback() external payable {\r\n        deposit();\r\n    }\r\n\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdraw(uint256 wad) public {\r\n        require(balanceOf[msg.sender] >= wad);\r\n        balanceOf[msg.sender] -= wad;\r\n        payable(msg.sender).transfer(wad);\r\n        emit Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function approve(address guy, uint256 wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        emit Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint256 wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 wad\r\n    ) public returns (bool) {\r\n        require(balanceOf[src] >= wad);\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\r\n            require(allowance[src][msg.sender] >= wad);\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/expiring-multiparty/ExpiringMultiParty.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Liquidatable.sol\";\r\n\r\n/**\r\n * @title Expiring Multi Party.\r\n * @notice Convenient wrapper for Liquidatable.\r\n */\r\ncontract ExpiringMultiParty is Liquidatable {\r\n    /**\r\n     * @notice Constructs the ExpiringMultiParty contract.\r\n     * @param params struct to define input parameters for construction of Liquidatable. Some params\r\n     * are fed directly into the PricelessPositionManager's constructor within the inheritance tree.\r\n     */\r\n    constructor(ConstructorParams memory params)\r\n        Liquidatable(params)\r\n    // Note: since there is no logic here, there is no need to add a re-entrancy guard.\r\n    {\r\n\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/expiring-multiparty/ExpiringMultiPartyCreator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\r\nimport \"../../common/interfaces/IERC20Standard.sol\";\r\nimport \"../../data-verification-mechanism/implementation/ContractCreator.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/implementation/AddressWhitelist.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../common/TokenFactory.sol\";\r\nimport \"../common/SyntheticToken.sol\";\r\nimport \"./ExpiringMultiPartyLib.sol\";\r\n\r\n/**\r\n * @title Expiring Multi Party Contract creator.\r\n * @notice Factory contract to create and register new instances of expiring multiparty contracts.\r\n * Responsible for constraining the parameters used to construct a new EMP. This creator contains a number of constraints\r\n * that are applied to newly created expiring multi party contract. These constraints can evolve over time and are\r\n * initially constrained to conservative values in this first iteration. Technically there is nothing in the\r\n * ExpiringMultiParty contract requiring these constraints. However, because `createExpiringMultiParty()` is intended\r\n * to be the only way to create valid financial contracts that are registered with the DVM (via _registerContract),\r\n  we can enforce deployment configurations here.\r\n */\r\ncontract ExpiringMultiPartyCreator is ContractCreator, Testable, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    /****************************************\r\n     *     EMP CREATOR DATA STRUCTURES      *\r\n     ****************************************/\r\n\r\n    struct Params {\r\n        uint256 expirationTimestamp;\r\n        address collateralAddress;\r\n        bytes32 priceFeedIdentifier;\r\n        string syntheticName;\r\n        string syntheticSymbol;\r\n        FixedPoint.Unsigned collateralRequirement;\r\n        FixedPoint.Unsigned disputeBondPercentage;\r\n        FixedPoint.Unsigned sponsorDisputeRewardPercentage;\r\n        FixedPoint.Unsigned disputerDisputeRewardPercentage;\r\n        FixedPoint.Unsigned minSponsorTokens;\r\n        uint256 withdrawalLiveness;\r\n        uint256 liquidationLiveness;\r\n        address financialProductLibraryAddress;\r\n    }\r\n    // Address of TokenFactory used to create a new synthetic token.\r\n    address public tokenFactoryAddress;\r\n\r\n    event CreatedExpiringMultiParty(address indexed expiringMultiPartyAddress, address indexed deployerAddress);\r\n\r\n    /**\r\n     * @notice Constructs the ExpiringMultiPartyCreator contract.\r\n     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\r\n     * @param _tokenFactoryAddress ERC20 token factory used to deploy synthetic token instances.\r\n     * @param _timerAddress Contract that stores the current time in a testing environment.\r\n     */\r\n    constructor(\r\n        address _finderAddress,\r\n        address _tokenFactoryAddress,\r\n        address _timerAddress\r\n    ) ContractCreator(_finderAddress) Testable(_timerAddress) nonReentrant() {\r\n        tokenFactoryAddress = _tokenFactoryAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Creates an instance of expiring multi party and registers it within the registry.\r\n     * @param params is a `ConstructorParams` object from ExpiringMultiParty.\r\n     * @return address of the deployed ExpiringMultiParty contract.\r\n     */\r\n    function createExpiringMultiParty(Params memory params) public nonReentrant() returns (address) {\r\n        // Create a new synthetic token using the params.\r\n        require(bytes(params.syntheticName).length != 0, \"Missing synthetic name\");\r\n        require(bytes(params.syntheticSymbol).length != 0, \"Missing synthetic symbol\");\r\n        TokenFactory tf = TokenFactory(tokenFactoryAddress);\r\n\r\n        // If the collateral token does not have a `decimals()` method, then a default precision of 18 will be\r\n        // applied to the newly created synthetic token.\r\n        uint8 syntheticDecimals = _getSyntheticDecimals(params.collateralAddress);\r\n        ExpandedIERC20 tokenCurrency = tf.createToken(params.syntheticName, params.syntheticSymbol, syntheticDecimals);\r\n        address derivative = ExpiringMultiPartyLib.deploy(_convertParams(params, tokenCurrency));\r\n\r\n        // Give permissions to new derivative contract and then hand over ownership.\r\n        tokenCurrency.addMinter(derivative);\r\n        tokenCurrency.addBurner(derivative);\r\n        tokenCurrency.resetOwner(derivative);\r\n\r\n        _registerContract(new address[](0), derivative);\r\n\r\n        emit CreatedExpiringMultiParty(derivative, msg.sender);\r\n\r\n        return derivative;\r\n    }\r\n\r\n    /****************************************\r\n     *          PRIVATE FUNCTIONS           *\r\n     ****************************************/\r\n\r\n    // Converts createExpiringMultiParty params to ExpiringMultiParty constructor params.\r\n    function _convertParams(Params memory params, ExpandedIERC20 newTokenCurrency)\r\n        private\r\n        view\r\n        returns (ExpiringMultiParty.ConstructorParams memory constructorParams)\r\n    {\r\n        // Known from creator deployment.\r\n        constructorParams.finderAddress = finderAddress;\r\n        constructorParams.timerAddress = timerAddress;\r\n\r\n        // Enforce configuration constraints.\r\n        require(params.withdrawalLiveness != 0, \"Withdrawal liveness cannot be 0\");\r\n        require(params.liquidationLiveness != 0, \"Liquidation liveness cannot be 0\");\r\n        require(params.expirationTimestamp > block.timestamp, \"Invalid expiration time\");\r\n        _requireWhitelistedCollateral(params.collateralAddress);\r\n\r\n        // We don't want EMP deployers to be able to intentionally or unintentionally set\r\n        // liveness periods that could induce arithmetic overflow, but we also don't want\r\n        // to be opinionated about what livenesses are \"correct\", so we will somewhat\r\n        // arbitrarily set the liveness upper bound to 100 years (5200 weeks). In practice, liveness\r\n        // periods even greater than a few days would make the EMP unusable for most users.\r\n        require(params.withdrawalLiveness < 5200 weeks, \"Withdrawal liveness too large\");\r\n        require(params.liquidationLiveness < 5200 weeks, \"Liquidation liveness too large\");\r\n\r\n        // Input from function call.\r\n        constructorParams.tokenAddress = address(newTokenCurrency);\r\n        constructorParams.expirationTimestamp = params.expirationTimestamp;\r\n        constructorParams.collateralAddress = params.collateralAddress;\r\n        constructorParams.priceFeedIdentifier = params.priceFeedIdentifier;\r\n        constructorParams.collateralRequirement = params.collateralRequirement;\r\n        constructorParams.disputeBondPercentage = params.disputeBondPercentage;\r\n        constructorParams.sponsorDisputeRewardPercentage = params.sponsorDisputeRewardPercentage;\r\n        constructorParams.disputerDisputeRewardPercentage = params.disputerDisputeRewardPercentage;\r\n        constructorParams.minSponsorTokens = params.minSponsorTokens;\r\n        constructorParams.withdrawalLiveness = params.withdrawalLiveness;\r\n        constructorParams.liquidationLiveness = params.liquidationLiveness;\r\n        constructorParams.financialProductLibraryAddress = params.financialProductLibraryAddress;\r\n    }\r\n\r\n    // IERC20Standard.decimals() will revert if the collateral contract has not implemented the decimals() method,\r\n    // which is possible since the method is only an OPTIONAL method in the ERC20 standard:\r\n    // https://eips.ethereum.org/EIPS/eip-20#methods.\r\n    function _getSyntheticDecimals(address _collateralAddress) public view returns (uint8 decimals) {\r\n        try IERC20Standard(_collateralAddress).decimals() returns (uint8 _decimals) {\r\n            return _decimals;\r\n        } catch {\r\n            return 18;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/expiring-multiparty/ExpiringMultiPartyLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./ExpiringMultiParty.sol\";\r\n\r\n/**\r\n * @title Provides convenient Expiring Multi Party contract utilities.\r\n * @dev Using this library to deploy EMP's allows calling contracts to avoid importing the full EMP bytecode.\r\n */\r\nlibrary ExpiringMultiPartyLib {\r\n    /**\r\n     * @notice Returns address of new EMP deployed with given `params` configuration.\r\n     * @dev Caller will need to register new EMP with the Registry to begin requesting prices. Caller is also\r\n     * responsible for enforcing constraints on `params`.\r\n     * @param params is a `ConstructorParams` object from ExpiringMultiParty.\r\n     * @return address of the deployed ExpiringMultiParty contract\r\n     */\r\n    function deploy(ExpiringMultiParty.ConstructorParams memory params) public returns (address) {\r\n        ExpiringMultiParty derivative = new ExpiringMultiParty(params);\r\n        return address(derivative);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/expiring-multiparty/Liquidatable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\nimport \"./PricelessPositionManager.sol\";\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n/**\r\n * @title Liquidatable\r\n * @notice Adds logic to a position-managing contract that enables callers to liquidate an undercollateralized position.\r\n * @dev The liquidation has a liveness period before expiring successfully, during which someone can \"dispute\" the\r\n * liquidation, which sends a price request to the relevant Oracle to settle the final collateralization ratio based on\r\n * a DVM price. The contract enforces dispute rewards in order to incentivize disputers to correctly dispute false\r\n * liquidations and compensate position sponsors who had their position incorrectly liquidated. Importantly, a\r\n * prospective disputer must deposit a dispute bond that they can lose in the case of an unsuccessful dispute.\r\n * NOTE: this contract does _not_ work with ERC777 collateral currencies or any others that call into the receiver on\r\n * transfer(). Using an ERC777 token would allow a user to maliciously grief other participants (while also losing\r\n * money themselves).\r\n */\r\ncontract Liquidatable is PricelessPositionManager {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using SafeERC20 for ExpandedIERC20;\r\n    using Address for address;\r\n\r\n    /****************************************\r\n     *     LIQUIDATION DATA STRUCTURES      *\r\n     ****************************************/\r\n\r\n    // Because of the check in withdrawable(), the order of these enum values should not change.\r\n    enum Status { Uninitialized, NotDisputed, Disputed, DisputeSucceeded, DisputeFailed }\r\n\r\n    struct LiquidationData {\r\n        // Following variables set upon creation of liquidation:\r\n        address sponsor; // Address of the liquidated position's sponsor\r\n        address liquidator; // Address who created this liquidation\r\n        Status state; // Liquidated (and expired or not), Pending a Dispute, or Dispute has resolved\r\n        uint256 liquidationTime; // Time when liquidation is initiated, needed to get price from Oracle\r\n        // Following variables determined by the position that is being liquidated:\r\n        FixedPoint.Unsigned tokensOutstanding; // Synthetic tokens required to be burned by liquidator to initiate dispute\r\n        FixedPoint.Unsigned lockedCollateral; // Collateral locked by contract and released upon expiry or post-dispute\r\n        // Amount of collateral being liquidated, which could be different from\r\n        // lockedCollateral if there were pending withdrawals at the time of liquidation\r\n        FixedPoint.Unsigned liquidatedCollateral;\r\n        // Unit value (starts at 1) that is used to track the fees per unit of collateral over the course of the liquidation.\r\n        FixedPoint.Unsigned rawUnitCollateral;\r\n        // Following variable set upon initiation of a dispute:\r\n        address disputer; // Person who is disputing a liquidation\r\n        // Following variable set upon a resolution of a dispute:\r\n        FixedPoint.Unsigned settlementPrice; // Final price as determined by an Oracle following a dispute\r\n        FixedPoint.Unsigned finalFee;\r\n    }\r\n\r\n    // Define the contract's constructor parameters as a struct to enable more variables to be specified.\r\n    // This is required to enable more params, over and above Solidity's limits.\r\n    struct ConstructorParams {\r\n        // Params for PricelessPositionManager only.\r\n        uint256 expirationTimestamp;\r\n        uint256 withdrawalLiveness;\r\n        address collateralAddress;\r\n        address tokenAddress;\r\n        address finderAddress;\r\n        address timerAddress;\r\n        address financialProductLibraryAddress;\r\n        bytes32 priceFeedIdentifier;\r\n        FixedPoint.Unsigned minSponsorTokens;\r\n        // Params specifically for Liquidatable.\r\n        uint256 liquidationLiveness;\r\n        FixedPoint.Unsigned collateralRequirement;\r\n        FixedPoint.Unsigned disputeBondPercentage;\r\n        FixedPoint.Unsigned sponsorDisputeRewardPercentage;\r\n        FixedPoint.Unsigned disputerDisputeRewardPercentage;\r\n    }\r\n\r\n    // This struct is used in the `withdrawLiquidation` method that disperses liquidation and dispute rewards.\r\n    // `payToX` stores the total collateral to withdraw from the contract to pay X. This value might differ\r\n    // from `paidToX` due to precision loss between accounting for the `rawCollateral` versus the\r\n    // fee-adjusted collateral. These variables are stored within a struct to avoid the stack too deep error.\r\n    struct RewardsData {\r\n        FixedPoint.Unsigned payToSponsor;\r\n        FixedPoint.Unsigned payToLiquidator;\r\n        FixedPoint.Unsigned payToDisputer;\r\n        FixedPoint.Unsigned paidToSponsor;\r\n        FixedPoint.Unsigned paidToLiquidator;\r\n        FixedPoint.Unsigned paidToDisputer;\r\n    }\r\n\r\n    // Liquidations are unique by ID per sponsor\r\n    mapping(address => LiquidationData[]) public liquidations;\r\n\r\n    // Total collateral in liquidation.\r\n    FixedPoint.Unsigned public rawLiquidationCollateral;\r\n\r\n    // Immutable contract parameters:\r\n    // Amount of time for pending liquidation before expiry.\r\n    // !!Note: The lower the liquidation liveness value, the more risk incurred by sponsors.\r\n    //       Extremely low liveness values increase the chance that opportunistic invalid liquidations\r\n    //       expire without dispute, thereby decreasing the usability for sponsors and increasing the risk\r\n    //       for the contract as a whole. An insolvent contract is extremely risky for any sponsor or synthetic\r\n    //       token holder for the contract.\r\n    uint256 public liquidationLiveness;\r\n    // Required collateral:TRV ratio for a position to be considered sufficiently collateralized.\r\n    FixedPoint.Unsigned public collateralRequirement;\r\n    // Percent of a Liquidation/Position's lockedCollateral to be deposited by a potential disputer\r\n    // Represented as a multiplier, for example 1.5e18 = \"150%\" and 0.05e18 = \"5%\"\r\n    FixedPoint.Unsigned public disputeBondPercentage;\r\n    // Percent of oraclePrice paid to sponsor in the Disputed state (i.e. following a successful dispute)\r\n    // Represented as a multiplier, see above.\r\n    FixedPoint.Unsigned public sponsorDisputeRewardPercentage;\r\n    // Percent of oraclePrice paid to disputer in the Disputed state (i.e. following a successful dispute)\r\n    // Represented as a multiplier, see above.\r\n    FixedPoint.Unsigned public disputerDisputeRewardPercentage;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event LiquidationCreated(\r\n        address indexed sponsor,\r\n        address indexed liquidator,\r\n        uint256 indexed liquidationId,\r\n        uint256 tokensOutstanding,\r\n        uint256 lockedCollateral,\r\n        uint256 liquidatedCollateral,\r\n        uint256 liquidationTime\r\n    );\r\n    event LiquidationDisputed(\r\n        address indexed sponsor,\r\n        address indexed liquidator,\r\n        address indexed disputer,\r\n        uint256 liquidationId,\r\n        uint256 disputeBondAmount\r\n    );\r\n    event DisputeSettled(\r\n        address indexed caller,\r\n        address indexed sponsor,\r\n        address indexed liquidator,\r\n        address disputer,\r\n        uint256 liquidationId,\r\n        bool disputeSucceeded\r\n    );\r\n    event LiquidationWithdrawn(\r\n        address indexed caller,\r\n        uint256 paidToLiquidator,\r\n        uint256 paidToDisputer,\r\n        uint256 paidToSponsor,\r\n        Status indexed liquidationStatus,\r\n        uint256 settlementPrice\r\n    );\r\n\r\n    /****************************************\r\n     *              MODIFIERS               *\r\n     ****************************************/\r\n\r\n    modifier disputable(uint256 liquidationId, address sponsor) {\r\n        _disputable(liquidationId, sponsor);\r\n        _;\r\n    }\r\n\r\n    modifier withdrawable(uint256 liquidationId, address sponsor) {\r\n        _withdrawable(liquidationId, sponsor);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructs the liquidatable contract.\r\n     * @param params struct to define input parameters for construction of Liquidatable. Some params\r\n     * are fed directly into the PricelessPositionManager's constructor within the inheritance tree.\r\n     */\r\n    constructor(ConstructorParams memory params)\r\n        PricelessPositionManager(\r\n            params.expirationTimestamp,\r\n            params.withdrawalLiveness,\r\n            params.collateralAddress,\r\n            params.tokenAddress,\r\n            params.finderAddress,\r\n            params.priceFeedIdentifier,\r\n            params.minSponsorTokens,\r\n            params.timerAddress,\r\n            params.financialProductLibraryAddress\r\n        )\r\n        nonReentrant()\r\n    {\r\n        require(params.collateralRequirement.isGreaterThan(1));\r\n        require(params.sponsorDisputeRewardPercentage.add(params.disputerDisputeRewardPercentage).isLessThan(1));\r\n\r\n        // Set liquidatable specific variables.\r\n        liquidationLiveness = params.liquidationLiveness;\r\n        collateralRequirement = params.collateralRequirement;\r\n        disputeBondPercentage = params.disputeBondPercentage;\r\n        sponsorDisputeRewardPercentage = params.sponsorDisputeRewardPercentage;\r\n        disputerDisputeRewardPercentage = params.disputerDisputeRewardPercentage;\r\n    }\r\n\r\n    /****************************************\r\n     *        LIQUIDATION FUNCTIONS         *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Liquidates the sponsor's position if the caller has enough\r\n     * synthetic tokens to retire the position's outstanding tokens. Liquidations above\r\n     * a minimum size also reset an ongoing \"slow withdrawal\"'s liveness.\r\n     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor. This contract must be\r\n     * approved to spend at least `tokensLiquidated` of `tokenCurrency` and at least `finalFeeBond` of `collateralCurrency`.\r\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\r\n     * @param sponsor address of the sponsor to liquidate.\r\n     * @param minCollateralPerToken abort the liquidation if the position's collateral per token is below this value.\r\n     * @param maxCollateralPerToken abort the liquidation if the position's collateral per token exceeds this value.\r\n     * @param maxTokensToLiquidate max number of tokens to liquidate.\r\n     * @param deadline abort the liquidation if the transaction is mined after this timestamp.\r\n     * @return liquidationId ID of the newly created liquidation.\r\n     * @return tokensLiquidated amount of synthetic tokens removed and liquidated from the `sponsor`'s position.\r\n     * @return finalFeeBond amount of collateral to be posted by liquidator and returned if not disputed successfully.\r\n     */\r\n    function createLiquidation(\r\n        address sponsor,\r\n        FixedPoint.Unsigned calldata minCollateralPerToken,\r\n        FixedPoint.Unsigned calldata maxCollateralPerToken,\r\n        FixedPoint.Unsigned calldata maxTokensToLiquidate,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        fees()\r\n        onlyPreExpiration()\r\n        nonReentrant()\r\n        returns (\r\n            uint256 liquidationId,\r\n            FixedPoint.Unsigned memory tokensLiquidated,\r\n            FixedPoint.Unsigned memory finalFeeBond\r\n        )\r\n    {\r\n        // Check that this transaction was mined pre-deadline.\r\n        require(getCurrentTime() <= deadline, \"Mined after deadline\");\r\n\r\n        // Retrieve Position data for sponsor\r\n        PositionData storage positionToLiquidate = _getPositionData(sponsor);\r\n\r\n        tokensLiquidated = FixedPoint.min(maxTokensToLiquidate, positionToLiquidate.tokensOutstanding);\r\n        require(tokensLiquidated.isGreaterThan(0));\r\n\r\n        // Starting values for the Position being liquidated. If withdrawal request amount is > position's collateral,\r\n        // then set this to 0, otherwise set it to (startCollateral - withdrawal request amount).\r\n        FixedPoint.Unsigned memory startCollateral = _getFeeAdjustedCollateral(positionToLiquidate.rawCollateral);\r\n        FixedPoint.Unsigned memory startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);\r\n        if (positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(startCollateral)) {\r\n            startCollateralNetOfWithdrawal = startCollateral.sub(positionToLiquidate.withdrawalRequestAmount);\r\n        }\r\n\r\n        // Scoping to get rid of a stack too deep error.\r\n        {\r\n            FixedPoint.Unsigned memory startTokens = positionToLiquidate.tokensOutstanding;\r\n\r\n            // The Position's collateralization ratio must be between [minCollateralPerToken, maxCollateralPerToken].\r\n            // maxCollateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\r\n            require(\r\n                maxCollateralPerToken.mul(startTokens).isGreaterThanOrEqual(startCollateralNetOfWithdrawal),\r\n                \"CR is more than max liq. price\"\r\n            );\r\n            // minCollateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\r\n            require(\r\n                minCollateralPerToken.mul(startTokens).isLessThanOrEqual(startCollateralNetOfWithdrawal),\r\n                \"CR is less than min liq. price\"\r\n            );\r\n        }\r\n\r\n        // Compute final fee at time of liquidation.\r\n        finalFeeBond = _computeFinalFees();\r\n\r\n        // These will be populated within the scope below.\r\n        FixedPoint.Unsigned memory lockedCollateral;\r\n        FixedPoint.Unsigned memory liquidatedCollateral;\r\n\r\n        // Scoping to get rid of a stack too deep error.\r\n        {\r\n            FixedPoint.Unsigned memory ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding);\r\n\r\n            // The actual amount of collateral that gets moved to the liquidation.\r\n            lockedCollateral = startCollateral.mul(ratio);\r\n\r\n            // For purposes of disputes, it's actually this liquidatedCollateral value that's used. This value is net of\r\n            // withdrawal requests.\r\n            liquidatedCollateral = startCollateralNetOfWithdrawal.mul(ratio);\r\n\r\n            // Part of the withdrawal request is also removed. Ideally:\r\n            // liquidatedCollateral + withdrawalAmountToRemove = lockedCollateral.\r\n            FixedPoint.Unsigned memory withdrawalAmountToRemove =\r\n                positionToLiquidate.withdrawalRequestAmount.mul(ratio);\r\n            _reduceSponsorPosition(sponsor, tokensLiquidated, lockedCollateral, withdrawalAmountToRemove);\r\n        }\r\n\r\n        // Add to the global liquidation collateral count.\r\n        _addCollateral(rawLiquidationCollateral, lockedCollateral.add(finalFeeBond));\r\n\r\n        // Construct liquidation object.\r\n        // Note: All dispute-related values are zeroed out until a dispute occurs. liquidationId is the index of the new\r\n        // LiquidationData that is pushed into the array, which is equal to the current length of the array pre-push.\r\n        liquidationId = liquidations[sponsor].length;\r\n        liquidations[sponsor].push(\r\n            LiquidationData({\r\n                sponsor: sponsor,\r\n                liquidator: msg.sender,\r\n                state: Status.NotDisputed,\r\n                liquidationTime: getCurrentTime(),\r\n                tokensOutstanding: tokensLiquidated,\r\n                lockedCollateral: lockedCollateral,\r\n                liquidatedCollateral: liquidatedCollateral,\r\n                rawUnitCollateral: _convertToRawCollateral(FixedPoint.fromUnscaledUint(1)),\r\n                disputer: address(0),\r\n                settlementPrice: FixedPoint.fromUnscaledUint(0),\r\n                finalFee: finalFeeBond\r\n            })\r\n        );\r\n\r\n        // If this liquidation is a subsequent liquidation on the position, and the liquidation size is larger than\r\n        // some \"griefing threshold\", then re-set the liveness. This enables a liquidation against a withdraw request to be\r\n        // \"dragged out\" if the position is very large and liquidators need time to gather funds. The griefing threshold\r\n        // is enforced so that liquidations for trivially small # of tokens cannot drag out an honest sponsor's slow withdrawal.\r\n\r\n        // We arbitrarily set the \"griefing threshold\" to `minSponsorTokens` because it is the only parameter\r\n        // denominated in token currency units and we can avoid adding another parameter.\r\n        FixedPoint.Unsigned memory griefingThreshold = minSponsorTokens;\r\n        if (\r\n            positionToLiquidate.withdrawalRequestPassTimestamp > 0 && // The position is undergoing a slow withdrawal.\r\n            positionToLiquidate.withdrawalRequestPassTimestamp > getCurrentTime() && // The slow withdrawal has not yet expired.\r\n            tokensLiquidated.isGreaterThanOrEqual(griefingThreshold) // The liquidated token count is above a \"griefing threshold\".\r\n        ) {\r\n            positionToLiquidate.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);\r\n        }\r\n\r\n        emit LiquidationCreated(\r\n            sponsor,\r\n            msg.sender,\r\n            liquidationId,\r\n            tokensLiquidated.rawValue,\r\n            lockedCollateral.rawValue,\r\n            liquidatedCollateral.rawValue,\r\n            getCurrentTime()\r\n        );\r\n\r\n        // Destroy tokens\r\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensLiquidated.rawValue);\r\n        tokenCurrency.burn(tokensLiquidated.rawValue);\r\n\r\n        // Pull final fee from liquidator.\r\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), finalFeeBond.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond\r\n     * and pay a fixed final fee charged on each price request.\r\n     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.\r\n     * This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute\r\n     * bond amount is calculated from `disputeBondPercentage` times the collateral in the liquidation.\r\n     * @param liquidationId of the disputed liquidation.\r\n     * @param sponsor the address of the sponsor whose liquidation is being disputed.\r\n     * @return totalPaid amount of collateral charged to disputer (i.e. final fee bond + dispute bond).\r\n     */\r\n    function dispute(uint256 liquidationId, address sponsor)\r\n        external\r\n        disputable(liquidationId, sponsor)\r\n        fees()\r\n        nonReentrant()\r\n        returns (FixedPoint.Unsigned memory totalPaid)\r\n    {\r\n        LiquidationData storage disputedLiquidation = _getLiquidationData(sponsor, liquidationId);\r\n\r\n        // Multiply by the unit collateral so the dispute bond is a percentage of the locked collateral after fees.\r\n        FixedPoint.Unsigned memory disputeBondAmount =\r\n            disputedLiquidation.lockedCollateral.mul(disputeBondPercentage).mul(\r\n                _getFeeAdjustedCollateral(disputedLiquidation.rawUnitCollateral)\r\n            );\r\n        _addCollateral(rawLiquidationCollateral, disputeBondAmount);\r\n\r\n        // Request a price from DVM. Liquidation is pending dispute until DVM returns a price.\r\n        disputedLiquidation.state = Status.Disputed;\r\n        disputedLiquidation.disputer = msg.sender;\r\n\r\n        // Enqueue a request with the DVM.\r\n        _requestOraclePriceLiquidation(disputedLiquidation.liquidationTime);\r\n\r\n        emit LiquidationDisputed(\r\n            sponsor,\r\n            disputedLiquidation.liquidator,\r\n            msg.sender,\r\n            liquidationId,\r\n            disputeBondAmount.rawValue\r\n        );\r\n        totalPaid = disputeBondAmount.add(disputedLiquidation.finalFee);\r\n\r\n        // Pay the final fee for requesting price from the DVM.\r\n        _payFinalFees(msg.sender, disputedLiquidation.finalFee);\r\n\r\n        // Transfer the dispute bond amount from the caller to this contract.\r\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), disputeBondAmount.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice After a dispute has settled or after a non-disputed liquidation has expired,\r\n     * anyone can call this method to disperse payments to the sponsor, liquidator, and disdputer.\r\n     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment.\r\n     * If the dispute FAILED: only the liquidator can receive payment.\r\n     * This method will revert if rewards have already been dispersed.\r\n     * @param liquidationId uniquely identifies the sponsor's liquidation.\r\n     * @param sponsor address of the sponsor associated with the liquidation.\r\n     * @return data about rewards paid out.\r\n     */\r\n    function withdrawLiquidation(uint256 liquidationId, address sponsor)\r\n        public\r\n        withdrawable(liquidationId, sponsor)\r\n        fees()\r\n        nonReentrant()\r\n        returns (RewardsData memory)\r\n    {\r\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\r\n\r\n        // Settles the liquidation if necessary. This call will revert if the price has not resolved yet.\r\n        _settle(liquidationId, sponsor);\r\n\r\n        // Calculate rewards as a function of the TRV.\r\n        // Note: all payouts are scaled by the unit collateral value so all payouts are charged the fees pro rata.\r\n        FixedPoint.Unsigned memory feeAttenuation = _getFeeAdjustedCollateral(liquidation.rawUnitCollateral);\r\n        FixedPoint.Unsigned memory settlementPrice = liquidation.settlementPrice;\r\n        FixedPoint.Unsigned memory tokenRedemptionValue =\r\n            liquidation.tokensOutstanding.mul(settlementPrice).mul(feeAttenuation);\r\n        FixedPoint.Unsigned memory collateral = liquidation.lockedCollateral.mul(feeAttenuation);\r\n        FixedPoint.Unsigned memory disputerDisputeReward = disputerDisputeRewardPercentage.mul(tokenRedemptionValue);\r\n        FixedPoint.Unsigned memory sponsorDisputeReward = sponsorDisputeRewardPercentage.mul(tokenRedemptionValue);\r\n        FixedPoint.Unsigned memory disputeBondAmount = collateral.mul(disputeBondPercentage);\r\n        FixedPoint.Unsigned memory finalFee = liquidation.finalFee.mul(feeAttenuation);\r\n\r\n        // There are three main outcome states: either the dispute succeeded, failed or was not updated.\r\n        // Based on the state, different parties of a liquidation receive different amounts.\r\n        // After assigning rewards based on the liquidation status, decrease the total collateral held in this contract\r\n        // by the amount to pay each party. The actual amounts withdrawn might differ if _removeCollateral causes\r\n        // precision loss.\r\n        RewardsData memory rewards;\r\n        if (liquidation.state == Status.DisputeSucceeded) {\r\n            // If the dispute is successful then all three users should receive rewards:\r\n\r\n            // Pay DISPUTER: disputer reward + dispute bond + returned final fee\r\n            rewards.payToDisputer = disputerDisputeReward.add(disputeBondAmount).add(finalFee);\r\n\r\n            // Pay SPONSOR: remaining collateral (collateral - TRV) + sponsor reward\r\n            rewards.payToSponsor = sponsorDisputeReward.add(collateral.sub(tokenRedemptionValue));\r\n\r\n            // Pay LIQUIDATOR: TRV - dispute reward - sponsor reward\r\n            // If TRV > Collateral, then subtract rewards from collateral\r\n            // NOTE: `payToLiquidator` should never be below zero since we enforce that\r\n            // (sponsorDisputePct+disputerDisputePct) <= 1 in the constructor when these params are set.\r\n            rewards.payToLiquidator = tokenRedemptionValue.sub(sponsorDisputeReward).sub(disputerDisputeReward);\r\n\r\n            // Transfer rewards and debit collateral\r\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\r\n            rewards.paidToSponsor = _removeCollateral(rawLiquidationCollateral, rewards.payToSponsor);\r\n            rewards.paidToDisputer = _removeCollateral(rawLiquidationCollateral, rewards.payToDisputer);\r\n\r\n            collateralCurrency.safeTransfer(liquidation.disputer, rewards.paidToDisputer.rawValue);\r\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\r\n            collateralCurrency.safeTransfer(liquidation.sponsor, rewards.paidToSponsor.rawValue);\r\n\r\n            // In the case of a failed dispute only the liquidator can withdraw.\r\n        } else if (liquidation.state == Status.DisputeFailed) {\r\n            // Pay LIQUIDATOR: collateral + dispute bond + returned final fee\r\n            rewards.payToLiquidator = collateral.add(disputeBondAmount).add(finalFee);\r\n\r\n            // Transfer rewards and debit collateral\r\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\r\n\r\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\r\n\r\n            // If the state is pre-dispute but time has passed liveness then there was no dispute. We represent this\r\n            // state as a dispute failed and the liquidator can withdraw.\r\n        } else if (liquidation.state == Status.NotDisputed) {\r\n            // Pay LIQUIDATOR: collateral + returned final fee\r\n            rewards.payToLiquidator = collateral.add(finalFee);\r\n\r\n            // Transfer rewards and debit collateral\r\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\r\n\r\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\r\n        }\r\n\r\n        emit LiquidationWithdrawn(\r\n            msg.sender,\r\n            rewards.paidToLiquidator.rawValue,\r\n            rewards.paidToDisputer.rawValue,\r\n            rewards.paidToSponsor.rawValue,\r\n            liquidation.state,\r\n            settlementPrice.rawValue\r\n        );\r\n\r\n        // Free up space after collateral is withdrawn by removing the liquidation object from the array.\r\n        delete liquidations[sponsor][liquidationId];\r\n\r\n        return rewards;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets all liquidation information for a given sponsor address.\r\n     * @param sponsor address of the position sponsor.\r\n     * @return liquidationData array of all liquidation information for the given sponsor address.\r\n     */\r\n    function getLiquidations(address sponsor)\r\n        external\r\n        view\r\n        nonReentrantView()\r\n        returns (LiquidationData[] memory liquidationData)\r\n    {\r\n        return liquidations[sponsor];\r\n    }\r\n\r\n    /**\r\n     * @notice Accessor method to calculate a transformed collateral requirement using the finanical product library\r\n      specified during contract deployment. If no library was provided then no modification to the collateral requirement is done.\r\n     * @param price input price used as an input to transform the collateral requirement.\r\n     * @return transformedCollateralRequirement collateral requirement with transformation applied to it.\r\n     * @dev This method should never revert.\r\n     */\r\n    function transformCollateralRequirement(FixedPoint.Unsigned memory price)\r\n        public\r\n        view\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        return _transformCollateralRequirement(price);\r\n    }\r\n\r\n    /****************************************\r\n     *          INTERNAL FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    // This settles a liquidation if it is in the Disputed state. If not, it will immediately return.\r\n    // If the liquidation is in the Disputed state, but a price is not available, this will revert.\r\n    function _settle(uint256 liquidationId, address sponsor) internal {\r\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\r\n\r\n        // Settlement only happens when state == Disputed and will only happen once per liquidation.\r\n        // If this liquidation is not ready to be settled, this method should return immediately.\r\n        if (liquidation.state != Status.Disputed) {\r\n            return;\r\n        }\r\n\r\n        // Get the returned price from the oracle. If this has not yet resolved will revert.\r\n        liquidation.settlementPrice = _getOraclePriceLiquidation(liquidation.liquidationTime);\r\n\r\n        // Find the value of the tokens in the underlying collateral.\r\n        FixedPoint.Unsigned memory tokenRedemptionValue =\r\n            liquidation.tokensOutstanding.mul(liquidation.settlementPrice);\r\n\r\n        // The required collateral is the value of the tokens in underlying * required collateral ratio. The Transform\r\n        // Collateral requirement method applies a from the financial Product library to change the scaled the collateral\r\n        // requirement based on the settlement price. If no library was specified when deploying the emp then this makes no change.\r\n        FixedPoint.Unsigned memory requiredCollateral =\r\n            tokenRedemptionValue.mul(_transformCollateralRequirement(liquidation.settlementPrice));\r\n\r\n        // If the position has more than the required collateral it is solvent and the dispute is valid(liquidation is invalid)\r\n        // Note that this check uses the liquidatedCollateral not the lockedCollateral as this considers withdrawals.\r\n        bool disputeSucceeded = liquidation.liquidatedCollateral.isGreaterThanOrEqual(requiredCollateral);\r\n        liquidation.state = disputeSucceeded ? Status.DisputeSucceeded : Status.DisputeFailed;\r\n\r\n        emit DisputeSettled(\r\n            msg.sender,\r\n            sponsor,\r\n            liquidation.liquidator,\r\n            liquidation.disputer,\r\n            liquidationId,\r\n            disputeSucceeded\r\n        );\r\n    }\r\n\r\n    function _pfc() internal view override returns (FixedPoint.Unsigned memory) {\r\n        return super._pfc().add(_getFeeAdjustedCollateral(rawLiquidationCollateral));\r\n    }\r\n\r\n    function _getLiquidationData(address sponsor, uint256 liquidationId)\r\n        internal\r\n        view\r\n        returns (LiquidationData storage liquidation)\r\n    {\r\n        LiquidationData[] storage liquidationArray = liquidations[sponsor];\r\n\r\n        // Revert if the caller is attempting to access an invalid liquidation\r\n        // (one that has never been created or one has never been initialized).\r\n        require(\r\n            liquidationId < liquidationArray.length && liquidationArray[liquidationId].state != Status.Uninitialized,\r\n            \"Invalid liquidation ID\"\r\n        );\r\n        return liquidationArray[liquidationId];\r\n    }\r\n\r\n    function _getLiquidationExpiry(LiquidationData storage liquidation) internal view returns (uint256) {\r\n        return liquidation.liquidationTime.add(liquidationLiveness);\r\n    }\r\n\r\n    // These internal functions are supposed to act identically to modifiers, but re-used modifiers\r\n    // unnecessarily increase contract bytecode size.\r\n    // source: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6\r\n    function _disputable(uint256 liquidationId, address sponsor) internal view {\r\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\r\n        require(\r\n            (getCurrentTime() < _getLiquidationExpiry(liquidation)) && (liquidation.state == Status.NotDisputed),\r\n            \"Liquidation not disputable\"\r\n        );\r\n    }\r\n\r\n    function _withdrawable(uint256 liquidationId, address sponsor) internal view {\r\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\r\n        Status state = liquidation.state;\r\n\r\n        // Must be disputed or the liquidation has passed expiry.\r\n        require(\r\n            (state > Status.NotDisputed) ||\r\n                ((_getLiquidationExpiry(liquidation) <= getCurrentTime()) && (state == Status.NotDisputed)),\r\n            \"Liquidation not withdrawable\"\r\n        );\r\n    }\r\n\r\n    function _transformCollateralRequirement(FixedPoint.Unsigned memory price)\r\n        internal\r\n        view\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        if (!address(financialProductLibrary).isContract()) return collateralRequirement;\r\n        try financialProductLibrary.transformCollateralRequirement(price, collateralRequirement) returns (\r\n            FixedPoint.Unsigned memory transformedCollateralRequirement\r\n        ) {\r\n            return transformedCollateralRequirement;\r\n        } catch {\r\n            return collateralRequirement;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/expiring-multiparty/PricelessPositionManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\r\nimport \"../../common/interfaces/IERC20Standard.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/OracleInterface.sol\";\r\nimport \"../../optimistic-oracle-v2/interfaces/OptimisticOracleInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\n\r\nimport \"../common/FeePayer.sol\";\r\nimport \"../common/financial-product-libraries/expiring-multiparty-libraries/FinancialProductLibrary.sol\";\r\n\r\n/**\r\n * @title Financial contract with priceless position management.\r\n * @notice Handles positions for multiple sponsors in an optimistic (i.e., priceless) way without relying\r\n * on a price feed. On construction, deploys a new ERC20, managed by this contract, that is the synthetic token.\r\n */\r\n\r\ncontract PricelessPositionManager is FeePayer {\r\n    using SafeMath for uint256;\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SafeERC20 for IERC20;\r\n    using SafeERC20 for ExpandedIERC20;\r\n    using Address for address;\r\n\r\n    /****************************************\r\n     *  PRICELESS POSITION DATA STRUCTURES  *\r\n     ****************************************/\r\n\r\n    // Stores the state of the PricelessPositionManager. Set on expiration, emergency shutdown, or settlement.\r\n    enum ContractState { Open, ExpiredPriceRequested, ExpiredPriceReceived }\r\n    ContractState public contractState;\r\n\r\n    // Represents a single sponsor's position. All collateral is held by this contract.\r\n    // This struct acts as bookkeeping for how much of that collateral is allocated to each sponsor.\r\n    struct PositionData {\r\n        FixedPoint.Unsigned tokensOutstanding;\r\n        // Tracks pending withdrawal requests. A withdrawal request is pending if `withdrawalRequestPassTimestamp != 0`.\r\n        uint256 withdrawalRequestPassTimestamp;\r\n        FixedPoint.Unsigned withdrawalRequestAmount;\r\n        // Raw collateral value. This value should never be accessed directly -- always use _getFeeAdjustedCollateral().\r\n        // To add or remove collateral, use _addCollateral() and _removeCollateral().\r\n        FixedPoint.Unsigned rawCollateral;\r\n        // Tracks pending transfer position requests. A transfer position request is pending if `transferPositionRequestPassTimestamp != 0`.\r\n        uint256 transferPositionRequestPassTimestamp;\r\n    }\r\n\r\n    // Maps sponsor addresses to their positions. Each sponsor can have only one position.\r\n    mapping(address => PositionData) public positions;\r\n\r\n    // Keep track of the total collateral and tokens across all positions to enable calculating the\r\n    // global collateralization ratio without iterating over all positions.\r\n    FixedPoint.Unsigned public totalTokensOutstanding;\r\n\r\n    // Similar to the rawCollateral in PositionData, this value should not be used directly.\r\n    // _getFeeAdjustedCollateral(), _addCollateral() and _removeCollateral() must be used to access and adjust.\r\n    FixedPoint.Unsigned public rawTotalPositionCollateral;\r\n\r\n    // Synthetic token created by this contract.\r\n    ExpandedIERC20 public tokenCurrency;\r\n\r\n    // Unique identifier for DVM price feed ticker.\r\n    bytes32 public priceIdentifier;\r\n    // Time that this contract expires. Should not change post-construction unless an emergency shutdown occurs.\r\n    uint256 public expirationTimestamp;\r\n    // Time that has to elapse for a withdrawal request to be considered passed, if no liquidations occur.\r\n    // !!Note: The lower the withdrawal liveness value, the more risk incurred by the contract.\r\n    //       Extremely low liveness values increase the chance that opportunistic invalid withdrawal requests\r\n    //       expire without liquidation, thereby increasing the insolvency risk for the contract as a whole. An insolvent\r\n    //       contract is extremely risky for any sponsor or synthetic token holder for the contract.\r\n    uint256 public withdrawalLiveness;\r\n\r\n    // Minimum number of tokens in a sponsor's position.\r\n    FixedPoint.Unsigned public minSponsorTokens;\r\n\r\n    // The expiry price pulled from the DVM.\r\n    FixedPoint.Unsigned public expiryPrice;\r\n\r\n    // Instance of FinancialProductLibrary to provide custom price and collateral requirement transformations to extend\r\n    // the functionality of the EMP to support a wider range of financial products.\r\n    FinancialProductLibrary public financialProductLibrary;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event RequestTransferPosition(address indexed oldSponsor);\r\n    event RequestTransferPositionExecuted(address indexed oldSponsor, address indexed newSponsor);\r\n    event RequestTransferPositionCanceled(address indexed oldSponsor);\r\n    event Deposit(address indexed sponsor, uint256 indexed collateralAmount);\r\n    event Withdrawal(address indexed sponsor, uint256 indexed collateralAmount);\r\n    event RequestWithdrawal(address indexed sponsor, uint256 indexed collateralAmount);\r\n    event RequestWithdrawalExecuted(address indexed sponsor, uint256 indexed collateralAmount);\r\n    event RequestWithdrawalCanceled(address indexed sponsor, uint256 indexed collateralAmount);\r\n    event PositionCreated(address indexed sponsor, uint256 indexed collateralAmount, uint256 indexed tokenAmount);\r\n    event NewSponsor(address indexed sponsor);\r\n    event EndedSponsorPosition(address indexed sponsor);\r\n    event Repay(address indexed sponsor, uint256 indexed numTokensRepaid, uint256 indexed newTokenCount);\r\n    event Redeem(address indexed sponsor, uint256 indexed collateralAmount, uint256 indexed tokenAmount);\r\n    event ContractExpired(address indexed caller);\r\n    event SettleExpiredPosition(\r\n        address indexed caller,\r\n        uint256 indexed collateralReturned,\r\n        uint256 indexed tokensBurned\r\n    );\r\n    event EmergencyShutdown(address indexed caller, uint256 originalExpirationTimestamp, uint256 shutdownTimestamp);\r\n\r\n    /****************************************\r\n     *               MODIFIERS              *\r\n     ****************************************/\r\n\r\n    modifier onlyPreExpiration() {\r\n        _onlyPreExpiration();\r\n        _;\r\n    }\r\n\r\n    modifier onlyPostExpiration() {\r\n        _onlyPostExpiration();\r\n        _;\r\n    }\r\n\r\n    modifier onlyCollateralizedPosition(address sponsor) {\r\n        _onlyCollateralizedPosition(sponsor);\r\n        _;\r\n    }\r\n\r\n    // Check that the current state of the pricelessPositionManager is Open.\r\n    // This prevents multiple calls to `expire` and `EmergencyShutdown` post expiration.\r\n    modifier onlyOpenState() {\r\n        _onlyOpenState();\r\n        _;\r\n    }\r\n\r\n    modifier noPendingWithdrawal(address sponsor) {\r\n        _positionHasNoPendingWithdrawal(sponsor);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Construct the PricelessPositionManager\r\n     * @dev Deployer of this contract should consider carefully which parties have ability to mint and burn\r\n     * the synthetic tokens referenced by `_tokenAddress`. This contract's security assumes that no external accounts\r\n     * can mint new tokens, which could be used to steal all of this contract's locked collateral.\r\n     * We recommend to only use synthetic token contracts whose sole Owner role (the role capable of adding & removing roles)\r\n     * is assigned to this contract, whose sole Minter role is assigned to this contract, and whose\r\n     * total supply is 0 prior to construction of this contract.\r\n     * @param _expirationTimestamp unix timestamp of when the contract will expire.\r\n     * @param _withdrawalLiveness liveness delay, in seconds, for pending withdrawals.\r\n     * @param _collateralAddress ERC20 token used as collateral for all positions.\r\n     * @param _tokenAddress ERC20 token used as synthetic token.\r\n     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\r\n     * @param _priceIdentifier registered in the DVM for the synthetic.\r\n     * @param _minSponsorTokens minimum number of tokens that must exist at any time in a position.\r\n     * @param _timerAddress Contract that stores the current time in a testing environment.\r\n     * Must be set to 0x0 for production environments that use live time.\r\n     * @param _financialProductLibraryAddress Contract providing contract state transformations.\r\n     */\r\n    constructor(\r\n        uint256 _expirationTimestamp,\r\n        uint256 _withdrawalLiveness,\r\n        address _collateralAddress,\r\n        address _tokenAddress,\r\n        address _finderAddress,\r\n        bytes32 _priceIdentifier,\r\n        FixedPoint.Unsigned memory _minSponsorTokens,\r\n        address _timerAddress,\r\n        address _financialProductLibraryAddress\r\n    ) FeePayer(_collateralAddress, _finderAddress, _timerAddress) nonReentrant() {\r\n        require(_expirationTimestamp > getCurrentTime());\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(_priceIdentifier));\r\n\r\n        expirationTimestamp = _expirationTimestamp;\r\n        withdrawalLiveness = _withdrawalLiveness;\r\n        tokenCurrency = ExpandedIERC20(_tokenAddress);\r\n        minSponsorTokens = _minSponsorTokens;\r\n        priceIdentifier = _priceIdentifier;\r\n\r\n        // Initialize the financialProductLibrary at the provided address.\r\n        financialProductLibrary = FinancialProductLibrary(_financialProductLibraryAddress);\r\n    }\r\n\r\n    /****************************************\r\n     *          POSITION FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Requests to transfer ownership of the caller's current position to a new sponsor address.\r\n     * Once the request liveness is passed, the sponsor can execute the transfer and specify the new sponsor.\r\n     * @dev The liveness length is the same as the withdrawal liveness.\r\n     */\r\n    function requestTransferPosition() public onlyPreExpiration() nonReentrant() {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(positionData.transferPositionRequestPassTimestamp == 0);\r\n\r\n        // Make sure the proposed expiration of this request is not post-expiry.\r\n        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\r\n        require(requestPassTime < expirationTimestamp);\r\n\r\n        // Update the position object for the user.\r\n        positionData.transferPositionRequestPassTimestamp = requestPassTime;\r\n\r\n        emit RequestTransferPosition(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice After a passed transfer position request (i.e., by a call to `requestTransferPosition` and waiting\r\n     * `withdrawalLiveness`), transfers ownership of the caller's current position to `newSponsorAddress`.\r\n     * @dev Transferring positions can only occur if the recipient does not already have a position.\r\n     * @param newSponsorAddress is the address to which the position will be transferred.\r\n     */\r\n    function transferPositionPassedRequest(address newSponsorAddress)\r\n        public\r\n        onlyPreExpiration()\r\n        noPendingWithdrawal(msg.sender)\r\n        nonReentrant()\r\n    {\r\n        require(\r\n            _getFeeAdjustedCollateral(positions[newSponsorAddress].rawCollateral).isEqual(\r\n                FixedPoint.fromUnscaledUint(0)\r\n            )\r\n        );\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(\r\n            positionData.transferPositionRequestPassTimestamp != 0 &&\r\n                positionData.transferPositionRequestPassTimestamp <= getCurrentTime()\r\n        );\r\n\r\n        // Reset transfer request.\r\n        positionData.transferPositionRequestPassTimestamp = 0;\r\n\r\n        positions[newSponsorAddress] = positionData;\r\n        delete positions[msg.sender];\r\n\r\n        emit RequestTransferPositionExecuted(msg.sender, newSponsorAddress);\r\n        emit NewSponsor(newSponsorAddress);\r\n        emit EndedSponsorPosition(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Cancels a pending transfer position request.\r\n     */\r\n    function cancelTransferPosition() external onlyPreExpiration() nonReentrant() {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(positionData.transferPositionRequestPassTimestamp != 0);\r\n\r\n        emit RequestTransferPositionCanceled(msg.sender);\r\n\r\n        // Reset withdrawal request.\r\n        positionData.transferPositionRequestPassTimestamp = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `collateralAmount` of `collateralCurrency` into the specified sponsor's position.\r\n     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\r\n     * at least `collateralAmount` of `collateralCurrency`.\r\n     * @param sponsor the sponsor to credit the deposit to.\r\n     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\r\n     */\r\n    function depositTo(address sponsor, FixedPoint.Unsigned memory collateralAmount)\r\n        public\r\n        onlyPreExpiration()\r\n        noPendingWithdrawal(sponsor)\r\n        fees()\r\n        nonReentrant()\r\n    {\r\n        require(collateralAmount.isGreaterThan(0));\r\n        PositionData storage positionData = _getPositionData(sponsor);\r\n\r\n        // Increase the position and global collateral balance by collateral amount.\r\n        _incrementCollateralBalances(positionData, collateralAmount);\r\n\r\n        emit Deposit(sponsor, collateralAmount.rawValue);\r\n\r\n        // Move collateral currency from sender to contract.\r\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `collateralAmount` of `collateralCurrency` into the caller's position.\r\n     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\r\n     * at least `collateralAmount` of `collateralCurrency`.\r\n     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\r\n     */\r\n    function deposit(FixedPoint.Unsigned memory collateralAmount) public {\r\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\r\n        depositTo(msg.sender, collateralAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.\r\n     * @dev Reverts if the withdrawal puts this position's collateralization ratio below the global collateralization\r\n     * ratio. In that case, use `requestWithdrawal`. Might not withdraw the full requested amount to account for precision loss.\r\n     * @param collateralAmount is the amount of collateral to withdraw.\r\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\r\n     */\r\n    function withdraw(FixedPoint.Unsigned memory collateralAmount)\r\n        public\r\n        onlyPreExpiration()\r\n        noPendingWithdrawal(msg.sender)\r\n        fees()\r\n        nonReentrant()\r\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\r\n    {\r\n        require(collateralAmount.isGreaterThan(0));\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n\r\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\r\n        // position remains above the GCR within the withdrawal. If this is not the case the caller must submit a request.\r\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\r\n\r\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\r\n\r\n        // Move collateral currency from contract to sender.\r\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\r\n        // instead of the user requested amount. This eliminates precision loss that could occur\r\n        // where the user withdraws more collateral than rawCollateral is decremented by.\r\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Starts a withdrawal request that, if passed, allows the sponsor to withdraw` from their position.\r\n     * @dev The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.\r\n     * @param collateralAmount the amount of collateral requested to withdraw\r\n     */\r\n    function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\r\n        public\r\n        onlyPreExpiration()\r\n        noPendingWithdrawal(msg.sender)\r\n        nonReentrant()\r\n    {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(\r\n            collateralAmount.isGreaterThan(0) &&\r\n                collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral))\r\n        );\r\n\r\n        // Make sure the proposed expiration of this request is not post-expiry.\r\n        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\r\n        require(requestPassTime < expirationTimestamp);\r\n\r\n        // Update the position object for the user.\r\n        positionData.withdrawalRequestPassTimestamp = requestPassTime;\r\n        positionData.withdrawalRequestAmount = collateralAmount;\r\n\r\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting\r\n     * `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.\r\n     * @dev Might not withdraw the full requested amount in order to account for precision loss or if the full requested\r\n     * amount exceeds the collateral in the position (due to paying fees).\r\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\r\n     */\r\n    function withdrawPassedRequest()\r\n        external\r\n        onlyPreExpiration()\r\n        fees()\r\n        nonReentrant()\r\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\r\n    {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(\r\n            positionData.withdrawalRequestPassTimestamp != 0 &&\r\n                positionData.withdrawalRequestPassTimestamp <= getCurrentTime()\r\n        );\r\n\r\n        // If withdrawal request amount is > position collateral, then withdraw the full collateral amount.\r\n        // This situation is possible due to fees charged since the withdrawal was originally requested.\r\n        FixedPoint.Unsigned memory amountToWithdraw = positionData.withdrawalRequestAmount;\r\n        if (positionData.withdrawalRequestAmount.isGreaterThan(_getFeeAdjustedCollateral(positionData.rawCollateral))) {\r\n            amountToWithdraw = _getFeeAdjustedCollateral(positionData.rawCollateral);\r\n        }\r\n\r\n        // Decrement the sponsor's collateral and global collateral amounts.\r\n        amountWithdrawn = _decrementCollateralBalances(positionData, amountToWithdraw);\r\n\r\n        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\r\n        _resetWithdrawalRequest(positionData);\r\n\r\n        // Transfer approved withdrawal amount from the contract to the caller.\r\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\r\n\r\n        emit RequestWithdrawalExecuted(msg.sender, amountWithdrawn.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Cancels a pending withdrawal request.\r\n     */\r\n    function cancelWithdrawal() external nonReentrant() {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(positionData.withdrawalRequestPassTimestamp != 0);\r\n\r\n        emit RequestWithdrawalCanceled(msg.sender, positionData.withdrawalRequestAmount.rawValue);\r\n\r\n        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\r\n        _resetWithdrawalRequest(positionData);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates tokens by creating a new position or by augmenting an existing position. Pulls `collateralAmount` into the sponsor's position and mints `numTokens` of `tokenCurrency`.\r\n     * @dev Reverts if minting these tokens would put the position's collateralization ratio below the\r\n     * global collateralization ratio. This contract must be approved to spend at least `collateralAmount` of\r\n     * `collateralCurrency`.\r\n     * @dev This contract must have the Minter role for the `tokenCurrency`.\r\n     * @param collateralAmount is the number of collateral tokens to collateralize the position with\r\n     * @param numTokens is the number of tokens to mint from the position.\r\n     */\r\n    function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\r\n        public\r\n        onlyPreExpiration()\r\n        fees()\r\n        nonReentrant()\r\n    {\r\n        PositionData storage positionData = positions[msg.sender];\r\n\r\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\r\n        require(\r\n            (_checkCollateralization(\r\n                _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\r\n                positionData.tokensOutstanding.add(numTokens)\r\n            ) || _checkCollateralization(collateralAmount, numTokens)),\r\n            \"Insufficient collateral\"\r\n        );\r\n\r\n        require(positionData.withdrawalRequestPassTimestamp == 0, \"Pending withdrawal\");\r\n        if (positionData.tokensOutstanding.isEqual(0)) {\r\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\r\n            emit NewSponsor(msg.sender);\r\n        }\r\n\r\n        // Increase the position and global collateral balance by collateral amount.\r\n        _incrementCollateralBalances(positionData, collateralAmount);\r\n\r\n        // Add the number of tokens created to the position's outstanding tokens.\r\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\r\n\r\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\r\n\r\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\r\n\r\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\r\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\r\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Burns `numTokens` of `tokenCurrency` to decrease sponsors position size, without sending back `collateralCurrency`.\r\n     * This is done by a sponsor to increase position CR. Resulting size is bounded by minSponsorTokens.\r\n     * @dev Can only be called by token sponsor. This contract must be approved to spend `numTokens` of `tokenCurrency`.\r\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\r\n     * @param numTokens is the number of tokens to be burnt from the sponsor's debt position.\r\n     */\r\n    function repay(FixedPoint.Unsigned memory numTokens)\r\n        public\r\n        onlyPreExpiration()\r\n        noPendingWithdrawal(msg.sender)\r\n        fees()\r\n        nonReentrant()\r\n    {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\r\n\r\n        // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\r\n        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\r\n        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\r\n        positionData.tokensOutstanding = newTokenCount;\r\n\r\n        // Update the totalTokensOutstanding after redemption.\r\n        totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\r\n\r\n        emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\r\n\r\n        // Transfer the tokens back from the sponsor and burn them.\r\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\r\n        tokenCurrency.burn(numTokens.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.\r\n     * @dev Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral\r\n     * in order to account for precision loss. This contract must be approved to spend at least `numTokens` of\r\n     * `tokenCurrency`.\r\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\r\n     * @param numTokens is the number of tokens to be burnt for a commensurate amount of collateral.\r\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\r\n     */\r\n    function redeem(FixedPoint.Unsigned memory numTokens)\r\n        public\r\n        noPendingWithdrawal(msg.sender)\r\n        fees()\r\n        nonReentrant()\r\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\r\n    {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding));\r\n\r\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\r\n        FixedPoint.Unsigned memory collateralRedeemed =\r\n            fractionRedeemed.mul(_getFeeAdjustedCollateral(positionData.rawCollateral));\r\n\r\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\r\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\r\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\r\n        } else {\r\n            // Decrement the sponsor's collateral and global collateral amounts.\r\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\r\n\r\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\r\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\r\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\r\n            positionData.tokensOutstanding = newTokenCount;\r\n\r\n            // Update the totalTokensOutstanding after redemption.\r\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\r\n        }\r\n\r\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\r\n\r\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\r\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\r\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\r\n        tokenCurrency.burn(numTokens.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice After a contract has passed expiry all token holders can redeem their tokens for underlying at the\r\n     * prevailing price defined by the DVM from the `expire` function.\r\n     * @dev This burns all tokens from the caller of `tokenCurrency` and sends back the proportional amount of\r\n     * `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for\r\n     * precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.\r\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\r\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\r\n     */\r\n    function settleExpired()\r\n        external\r\n        onlyPostExpiration()\r\n        fees()\r\n        nonReentrant()\r\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\r\n    {\r\n        // If the contract state is open and onlyPostExpiration passed then `expire()` has not yet been called.\r\n        require(contractState != ContractState.Open, \"Unexpired position\");\r\n\r\n        // Get the current settlement price and store it. If it is not resolved will revert.\r\n        if (contractState != ContractState.ExpiredPriceReceived) {\r\n            expiryPrice = _getOraclePriceExpiration(expirationTimestamp);\r\n            contractState = ContractState.ExpiredPriceReceived;\r\n        }\r\n\r\n        // Get caller's tokens balance and calculate amount of underlying entitled to them.\r\n        FixedPoint.Unsigned memory tokensToRedeem = FixedPoint.Unsigned(tokenCurrency.balanceOf(msg.sender));\r\n        FixedPoint.Unsigned memory totalRedeemableCollateral = tokensToRedeem.mul(expiryPrice);\r\n\r\n        // If the caller is a sponsor with outstanding collateral they are also entitled to their excess collateral after their debt.\r\n        PositionData storage positionData = positions[msg.sender];\r\n        if (_getFeeAdjustedCollateral(positionData.rawCollateral).isGreaterThan(0)) {\r\n            // Calculate the underlying entitled to a token sponsor. This is collateral - debt in underlying.\r\n            FixedPoint.Unsigned memory tokenDebtValueInCollateral = positionData.tokensOutstanding.mul(expiryPrice);\r\n            FixedPoint.Unsigned memory positionCollateral = _getFeeAdjustedCollateral(positionData.rawCollateral);\r\n\r\n            // If the debt is greater than the remaining collateral, they cannot redeem anything.\r\n            FixedPoint.Unsigned memory positionRedeemableCollateral =\r\n                tokenDebtValueInCollateral.isLessThan(positionCollateral)\r\n                    ? positionCollateral.sub(tokenDebtValueInCollateral)\r\n                    : FixedPoint.Unsigned(0);\r\n\r\n            // Add the number of redeemable tokens for the sponsor to their total redeemable collateral.\r\n            totalRedeemableCollateral = totalRedeemableCollateral.add(positionRedeemableCollateral);\r\n\r\n            // Reset the position state as all the value has been removed after settlement.\r\n            delete positions[msg.sender];\r\n            emit EndedSponsorPosition(msg.sender);\r\n        }\r\n\r\n        // Take the min of the remaining collateral and the collateral \"owed\". If the contract is undercapitalized,\r\n        // the caller will get as much collateral as the contract can pay out.\r\n        FixedPoint.Unsigned memory payout =\r\n            FixedPoint.min(_getFeeAdjustedCollateral(rawTotalPositionCollateral), totalRedeemableCollateral);\r\n\r\n        // Decrement total contract collateral and outstanding debt.\r\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, payout);\r\n        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRedeem);\r\n\r\n        emit SettleExpiredPosition(msg.sender, amountWithdrawn.rawValue, tokensToRedeem.rawValue);\r\n\r\n        // Transfer tokens & collateral and burn the redeemed tokens.\r\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\r\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensToRedeem.rawValue);\r\n        tokenCurrency.burn(tokensToRedeem.rawValue);\r\n    }\r\n\r\n    /****************************************\r\n     *        GLOBAL STATE FUNCTIONS        *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Locks contract state in expired and requests oracle price.\r\n     * @dev this function can only be called once the contract is expired and can't be re-called.\r\n     */\r\n    function expire() external onlyPostExpiration() onlyOpenState() fees() nonReentrant() {\r\n        contractState = ContractState.ExpiredPriceRequested;\r\n\r\n        // Final fees do not need to be paid when sending a request to the optimistic oracle.\r\n        _requestOraclePriceExpiration(expirationTimestamp);\r\n\r\n        emit ContractExpired(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Premature contract settlement under emergency circumstances.\r\n     * @dev Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`.\r\n     * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal\r\n     * to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested`\r\n     * which prevents re-entry into this function or the `expire` function. No fees are paid when calling\r\n     * `emergencyShutdown` as the governor who would call the function would also receive the fees.\r\n     */\r\n    function emergencyShutdown() external override onlyPreExpiration() onlyOpenState() nonReentrant() {\r\n        require(msg.sender == _getFinancialContractsAdminAddress());\r\n\r\n        contractState = ContractState.ExpiredPriceRequested;\r\n        // Expiratory time now becomes the current time (emergency shutdown time).\r\n        // Price requested at this time stamp. `settleExpired` can now withdraw at this timestamp.\r\n        uint256 oldExpirationTimestamp = expirationTimestamp;\r\n        expirationTimestamp = getCurrentTime();\r\n        _requestOraclePriceExpiration(expirationTimestamp);\r\n\r\n        emit EmergencyShutdown(msg.sender, oldExpirationTimestamp, expirationTimestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Theoretically supposed to pay fees and move money between margin accounts to make sure they\r\n     * reflect the NAV of the contract. However, this functionality doesn't apply to this contract.\r\n     * @dev This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable\r\n     * only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.\r\n     */\r\n    function remargin() external override onlyPreExpiration() nonReentrant() {\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @notice Accessor method for a sponsor's collateral.\r\n     * @dev This is necessary because the struct returned by the positions() method shows\r\n     * rawCollateral, which isn't a user-readable value.\r\n     * @dev This method accounts for pending regular fees that have not yet been withdrawn from this contract, for\r\n     * example if the `lastPaymentTime != currentTime`.\r\n     * @param sponsor address whose collateral amount is retrieved.\r\n     * @return collateralAmount amount of collateral within a sponsors position.\r\n     */\r\n    function getCollateral(address sponsor) external view nonReentrantView() returns (FixedPoint.Unsigned memory) {\r\n        // Note: do a direct access to avoid the validity check.\r\n        return _getPendingRegularFeeAdjustedCollateral(_getFeeAdjustedCollateral(positions[sponsor].rawCollateral));\r\n    }\r\n\r\n    /**\r\n     * @notice Accessor method for the total collateral stored within the PricelessPositionManager.\r\n     * @return totalCollateral amount of all collateral within the Expiring Multi Party Contract.\r\n     * @dev This method accounts for pending regular fees that have not yet been withdrawn from this contract, for\r\n     * example if the `lastPaymentTime != currentTime`.\r\n     */\r\n    function totalPositionCollateral() external view nonReentrantView() returns (FixedPoint.Unsigned memory) {\r\n        return _getPendingRegularFeeAdjustedCollateral(_getFeeAdjustedCollateral(rawTotalPositionCollateral));\r\n    }\r\n\r\n    /**\r\n     * @notice Accessor method to compute a transformed price using the finanicalProductLibrary specified at contract\r\n     * deployment. If no library was provided then no modification to the price is done.\r\n     * @param price input price to be transformed.\r\n     * @param requestTime timestamp the oraclePrice was requested at.\r\n     * @return transformedPrice price with the transformation function applied to it.\r\n     * @dev This method should never revert.\r\n     */\r\n\r\n    function transformPrice(FixedPoint.Unsigned memory price, uint256 requestTime)\r\n        public\r\n        view\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        return _transformPrice(price, requestTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Accessor method to compute a transformed price identifier using the finanicalProductLibrary specified\r\n     * at contract deployment. If no library was provided then no modification to the identifier is done.\r\n     * @param requestTime timestamp the identifier is to be used at.\r\n     * @return transformedPrice price with the transformation function applied to it.\r\n     * @dev This method should never revert.\r\n     */\r\n    function transformPriceIdentifier(uint256 requestTime) public view nonReentrantView() returns (bytes32) {\r\n        return _transformPriceIdentifier(requestTime);\r\n    }\r\n\r\n    /****************************************\r\n     *          INTERNAL FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    // Reduces a sponsor's position and global counters by the specified parameters. Handles deleting the entire\r\n    // position if the entire position is being removed. Does not make any external transfers.\r\n    function _reduceSponsorPosition(\r\n        address sponsor,\r\n        FixedPoint.Unsigned memory tokensToRemove,\r\n        FixedPoint.Unsigned memory collateralToRemove,\r\n        FixedPoint.Unsigned memory withdrawalAmountToRemove\r\n    ) internal {\r\n        PositionData storage positionData = _getPositionData(sponsor);\r\n\r\n        // If the entire position is being removed, delete it instead.\r\n        if (\r\n            tokensToRemove.isEqual(positionData.tokensOutstanding) &&\r\n            _getFeeAdjustedCollateral(positionData.rawCollateral).isEqual(collateralToRemove)\r\n        ) {\r\n            _deleteSponsorPosition(sponsor);\r\n            return;\r\n        }\r\n\r\n        // Decrement the sponsor's collateral and global collateral amounts.\r\n        _decrementCollateralBalances(positionData, collateralToRemove);\r\n\r\n        // Ensure that the sponsor will meet the min position size after the reduction.\r\n        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(tokensToRemove);\r\n        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\r\n        positionData.tokensOutstanding = newTokenCount;\r\n\r\n        // Decrement the position's withdrawal amount.\r\n        positionData.withdrawalRequestAmount = positionData.withdrawalRequestAmount.sub(withdrawalAmountToRemove);\r\n\r\n        // Decrement the total outstanding tokens in the overall contract.\r\n        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRemove);\r\n    }\r\n\r\n    // Deletes a sponsor's position and updates global counters. Does not make any external transfers.\r\n    function _deleteSponsorPosition(address sponsor) internal returns (FixedPoint.Unsigned memory) {\r\n        PositionData storage positionToLiquidate = _getPositionData(sponsor);\r\n\r\n        FixedPoint.Unsigned memory startingGlobalCollateral = _getFeeAdjustedCollateral(rawTotalPositionCollateral);\r\n\r\n        // Remove the collateral and outstanding from the overall total position.\r\n        FixedPoint.Unsigned memory remainingRawCollateral = positionToLiquidate.rawCollateral;\r\n        rawTotalPositionCollateral = rawTotalPositionCollateral.sub(remainingRawCollateral);\r\n        totalTokensOutstanding = totalTokensOutstanding.sub(positionToLiquidate.tokensOutstanding);\r\n\r\n        // Reset the sponsors position to have zero outstanding and collateral.\r\n        delete positions[sponsor];\r\n\r\n        emit EndedSponsorPosition(sponsor);\r\n\r\n        // Return fee-adjusted amount of collateral deleted from position.\r\n        return startingGlobalCollateral.sub(_getFeeAdjustedCollateral(rawTotalPositionCollateral));\r\n    }\r\n\r\n    function _pfc() internal view virtual override returns (FixedPoint.Unsigned memory) {\r\n        return _getFeeAdjustedCollateral(rawTotalPositionCollateral);\r\n    }\r\n\r\n    function _getPositionData(address sponsor)\r\n        internal\r\n        view\r\n        onlyCollateralizedPosition(sponsor)\r\n        returns (PositionData storage)\r\n    {\r\n        return positions[sponsor];\r\n    }\r\n\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    function _getOracle() internal view returns (OracleInterface) {\r\n        return OracleInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n\r\n    function _getOptimisticOracle() internal view returns (OptimisticOracleInterface) {\r\n        return OptimisticOracleInterface(finder.getImplementationAddress(OracleInterfaces.OptimisticOracle));\r\n    }\r\n\r\n    function _getFinancialContractsAdminAddress() internal view returns (address) {\r\n        return finder.getImplementationAddress(OracleInterfaces.FinancialContractsAdmin);\r\n    }\r\n\r\n    // Requests a price for transformed `priceIdentifier` at `requestedTime` from the Oracle.\r\n    function _requestOraclePriceExpiration(uint256 requestedTime) internal {\r\n        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\r\n\r\n        // Increase token allowance to enable the optimistic oracle reward transfer.\r\n        FixedPoint.Unsigned memory reward = _computeFinalFees();\r\n        collateralCurrency.safeIncreaseAllowance(address(optimisticOracle), reward.rawValue);\r\n        optimisticOracle.requestPrice(\r\n            _transformPriceIdentifier(requestedTime),\r\n            requestedTime,\r\n            _getAncillaryData(),\r\n            collateralCurrency,\r\n            reward.rawValue // Reward is equal to the final fee\r\n        );\r\n\r\n        // Apply haircut to all sponsors by decrementing the cumlativeFeeMultiplier by the amount lost from the final fee.\r\n        _adjustCumulativeFeeMultiplier(reward, _pfc());\r\n    }\r\n\r\n    // Fetches a resolved Oracle price from the Oracle. Reverts if the Oracle hasn't resolved for this request.\r\n    function _getOraclePriceExpiration(uint256 requestedTime) internal returns (FixedPoint.Unsigned memory) {\r\n        // Create an instance of the oracle and get the price. If the price is not resolved revert.\r\n        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\r\n        require(\r\n            optimisticOracle.hasPrice(\r\n                address(this),\r\n                _transformPriceIdentifier(requestedTime),\r\n                requestedTime,\r\n                _getAncillaryData()\r\n            )\r\n        );\r\n        int256 optimisticOraclePrice =\r\n            optimisticOracle.settleAndGetPrice(\r\n                _transformPriceIdentifier(requestedTime),\r\n                requestedTime,\r\n                _getAncillaryData()\r\n            );\r\n\r\n        // For now we don't want to deal with negative prices in positions.\r\n        if (optimisticOraclePrice < 0) {\r\n            optimisticOraclePrice = 0;\r\n        }\r\n        return _transformPrice(FixedPoint.Unsigned(uint256(optimisticOraclePrice)), requestedTime);\r\n    }\r\n\r\n    // Requests a price for transformed `priceIdentifier` at `requestedTime` from the Oracle.\r\n    function _requestOraclePriceLiquidation(uint256 requestedTime) internal {\r\n        OracleInterface oracle = _getOracle();\r\n        oracle.requestPrice(_transformPriceIdentifier(requestedTime), requestedTime);\r\n    }\r\n\r\n    // Fetches a resolved Oracle price from the Oracle. Reverts if the Oracle hasn't resolved for this request.\r\n    function _getOraclePriceLiquidation(uint256 requestedTime) internal view returns (FixedPoint.Unsigned memory) {\r\n        // Create an instance of the oracle and get the price. If the price is not resolved revert.\r\n        OracleInterface oracle = _getOracle();\r\n        require(oracle.hasPrice(_transformPriceIdentifier(requestedTime), requestedTime), \"Unresolved oracle price\");\r\n        int256 oraclePrice = oracle.getPrice(_transformPriceIdentifier(requestedTime), requestedTime);\r\n\r\n        // For now we don't want to deal with negative prices in positions.\r\n        if (oraclePrice < 0) {\r\n            oraclePrice = 0;\r\n        }\r\n        return _transformPrice(FixedPoint.Unsigned(uint256(oraclePrice)), requestedTime);\r\n    }\r\n\r\n    // Reset withdrawal request by setting the withdrawal request and withdrawal timestamp to 0.\r\n    function _resetWithdrawalRequest(PositionData storage positionData) internal {\r\n        positionData.withdrawalRequestAmount = FixedPoint.fromUnscaledUint(0);\r\n        positionData.withdrawalRequestPassTimestamp = 0;\r\n    }\r\n\r\n    // Ensure individual and global consistency when increasing collateral balances. Returns the change to the position.\r\n    function _incrementCollateralBalances(\r\n        PositionData storage positionData,\r\n        FixedPoint.Unsigned memory collateralAmount\r\n    ) internal returns (FixedPoint.Unsigned memory) {\r\n        _addCollateral(positionData.rawCollateral, collateralAmount);\r\n        return _addCollateral(rawTotalPositionCollateral, collateralAmount);\r\n    }\r\n\r\n    // Ensure individual and global consistency when decrementing collateral balances. Returns the change to the\r\n    // position. We elect to return the amount that the global collateral is decreased by, rather than the individual\r\n    // position's collateral, because we need to maintain the invariant that the global collateral is always\r\n    // <= the collateral owned by the contract to avoid reverts on withdrawals. The amount returned = amount withdrawn.\r\n    function _decrementCollateralBalances(\r\n        PositionData storage positionData,\r\n        FixedPoint.Unsigned memory collateralAmount\r\n    ) internal returns (FixedPoint.Unsigned memory) {\r\n        _removeCollateral(positionData.rawCollateral, collateralAmount);\r\n        return _removeCollateral(rawTotalPositionCollateral, collateralAmount);\r\n    }\r\n\r\n    // Ensure individual and global consistency when decrementing collateral balances. Returns the change to the position.\r\n    // This function is similar to the _decrementCollateralBalances function except this function checks position GCR\r\n    // between the decrements. This ensures that collateral removal will not leave the position undercollateralized.\r\n    function _decrementCollateralBalancesCheckGCR(\r\n        PositionData storage positionData,\r\n        FixedPoint.Unsigned memory collateralAmount\r\n    ) internal returns (FixedPoint.Unsigned memory) {\r\n        _removeCollateral(positionData.rawCollateral, collateralAmount);\r\n        require(_checkPositionCollateralization(positionData), \"CR below GCR\");\r\n        return _removeCollateral(rawTotalPositionCollateral, collateralAmount);\r\n    }\r\n\r\n    // These internal functions are supposed to act identically to modifiers, but re-used modifiers\r\n    // unnecessarily increase contract bytecode size.\r\n    // source: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6\r\n    function _onlyOpenState() internal view {\r\n        require(contractState == ContractState.Open, \"Contract state is not OPEN\");\r\n    }\r\n\r\n    function _onlyPreExpiration() internal view {\r\n        require(getCurrentTime() < expirationTimestamp, \"Only callable pre-expiry\");\r\n    }\r\n\r\n    function _onlyPostExpiration() internal view {\r\n        require(getCurrentTime() >= expirationTimestamp, \"Only callable post-expiry\");\r\n    }\r\n\r\n    function _onlyCollateralizedPosition(address sponsor) internal view {\r\n        require(\r\n            _getFeeAdjustedCollateral(positions[sponsor].rawCollateral).isGreaterThan(0),\r\n            \"Position has no collateral\"\r\n        );\r\n    }\r\n\r\n    // Note: This checks whether an already existing position has a pending withdrawal. This cannot be used on the\r\n    // `create` method because it is possible that `create` is called on a new position (i.e. one without any collateral\r\n    // or tokens outstanding) which would fail the `onlyCollateralizedPosition` modifier on `_getPositionData`.\r\n    function _positionHasNoPendingWithdrawal(address sponsor) internal view {\r\n        require(_getPositionData(sponsor).withdrawalRequestPassTimestamp == 0, \"Pending withdrawal\");\r\n    }\r\n\r\n    /****************************************\r\n     *          PRIVATE FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    function _checkPositionCollateralization(PositionData storage positionData) private view returns (bool) {\r\n        return\r\n            _checkCollateralization(\r\n                _getFeeAdjustedCollateral(positionData.rawCollateral),\r\n                positionData.tokensOutstanding\r\n            );\r\n    }\r\n\r\n    // Checks whether the provided `collateral` and `numTokens` have a collateralization ratio above the global\r\n    // collateralization ratio.\r\n    function _checkCollateralization(FixedPoint.Unsigned memory collateral, FixedPoint.Unsigned memory numTokens)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        FixedPoint.Unsigned memory global =\r\n            _getCollateralizationRatio(_getFeeAdjustedCollateral(rawTotalPositionCollateral), totalTokensOutstanding);\r\n        FixedPoint.Unsigned memory thisChange = _getCollateralizationRatio(collateral, numTokens);\r\n        return !global.isGreaterThan(thisChange);\r\n    }\r\n\r\n    function _getCollateralizationRatio(FixedPoint.Unsigned memory collateral, FixedPoint.Unsigned memory numTokens)\r\n        private\r\n        pure\r\n        returns (FixedPoint.Unsigned memory ratio)\r\n    {\r\n        if (!numTokens.isGreaterThan(0)) {\r\n            return FixedPoint.fromUnscaledUint(0);\r\n        } else {\r\n            return collateral.div(numTokens);\r\n        }\r\n    }\r\n\r\n    // IERC20Standard.decimals() will revert if the collateral contract has not implemented the decimals() method,\r\n    // which is possible since the method is only an OPTIONAL method in the ERC20 standard:\r\n    // https://eips.ethereum.org/EIPS/eip-20#methods.\r\n    function _getSyntheticDecimals(address _collateralAddress) public view returns (uint8 decimals) {\r\n        try IERC20Standard(_collateralAddress).decimals() returns (uint8 _decimals) {\r\n            return _decimals;\r\n        } catch {\r\n            return 18;\r\n        }\r\n    }\r\n\r\n    function _transformPrice(FixedPoint.Unsigned memory price, uint256 requestTime)\r\n        internal\r\n        view\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        if (!address(financialProductLibrary).isContract()) return price;\r\n        try financialProductLibrary.transformPrice(price, requestTime) returns (\r\n            FixedPoint.Unsigned memory transformedPrice\r\n        ) {\r\n            return transformedPrice;\r\n        } catch {\r\n            return price;\r\n        }\r\n    }\r\n\r\n    function _transformPriceIdentifier(uint256 requestTime) internal view returns (bytes32) {\r\n        if (!address(financialProductLibrary).isContract()) return priceIdentifier;\r\n        try financialProductLibrary.transformPriceIdentifier(priceIdentifier, requestTime) returns (\r\n            bytes32 transformedIdentifier\r\n        ) {\r\n            return transformedIdentifier;\r\n        } catch {\r\n            return priceIdentifier;\r\n        }\r\n    }\r\n\r\n    function _getAncillaryData() internal view returns (bytes memory) {\r\n        // Note: when ancillary data is passed to the optimistic oracle, it should be tagged with the token address\r\n        // whose funding rate it's trying to get.\r\n        return abi.encodePacked(address(tokenCurrency));\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/long-short-pair/LongShortPair.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../common/financial-product-libraries/long-short-pair-libraries/LongShortPairFinancialProductLibrary.sol\";\r\n\r\nimport \"../../common/implementation/AncillaryData.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\r\nimport \"../../common/interfaces/AddressWhitelistInterface.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/OracleInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\n\r\nimport \"../../optimistic-oracle-v2/interfaces/OptimisticOracleV2Interface.sol\";\r\n\r\n/**\r\n * @title Long Short Pair.\r\n * @notice Uses a combination of long and short tokens to tokenize the bounded price exposure to a given identifier.\r\n */\r\ncontract LongShortPair is Testable, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /*************************************\r\n     *  LONG SHORT PAIR DATA STRUCTURES  *\r\n     *************************************/\r\n\r\n    // Define the contract's constructor parameters as a struct to enable more variables to be specified.\r\n    struct ConstructorParams {\r\n        string pairName; // Name of the long short pair contract.\r\n        uint64 expirationTimestamp; // Unix timestamp of when the contract will expire.\r\n        uint256 collateralPerPair; // How many units of collateral are required to mint one pair of synthetic tokens.\r\n        bytes32 priceIdentifier; // Price identifier, registered in the DVM for the long short pair.\r\n        bool enableEarlyExpiration; // Enables the LSP contract to be settled early.\r\n        ExpandedIERC20 longToken; // Token used as long in the LSP. Mint and burn rights needed by this contract.\r\n        ExpandedIERC20 shortToken; // Token used as short in the LSP. Mint and burn rights needed by this contract.\r\n        IERC20 collateralToken; // Collateral token used to back LSP synthetics.\r\n        LongShortPairFinancialProductLibrary financialProductLibrary; // Contract providing settlement payout logic.\r\n        bytes customAncillaryData; // Custom ancillary data to be passed along with the price request to the OO.\r\n        uint256 proposerReward; // Optimistic oracle reward amount, pulled from the caller of the expire function.\r\n        uint256 optimisticOracleLivenessTime; // OO liveness time for price requests.\r\n        uint256 optimisticOracleProposerBond; // OO proposer bond for price requests.\r\n        FinderInterface finder; // DVM finder to find other UMA ecosystem contracts.\r\n        address timerAddress; // Timer used to synchronize contract time in testing. Set to 0x000... in production.\r\n    }\r\n\r\n    bool public receivedSettlementPrice;\r\n\r\n    bool public enableEarlyExpiration; // If set, the LSP contract can request to be settled early by calling the OO.\r\n    uint64 public expirationTimestamp;\r\n    uint64 public earlyExpirationTimestamp; // Set in the case the contract is expired early.\r\n    string public pairName;\r\n    uint256 public collateralPerPair; // Amount of collateral a pair of tokens is always redeemable for.\r\n\r\n    // Number between 0 and 1e18 to allocate collateral between long & short tokens at redemption. 0 entitles each short\r\n    // to collateralPerPair and each long to 0. 1e18 makes each long worth collateralPerPair and short 0.\r\n    uint256 public expiryPercentLong;\r\n    bytes32 public priceIdentifier;\r\n\r\n    // Price returned from the Optimistic oracle at settlement time.\r\n    int256 public expiryPrice;\r\n\r\n    // External contract interfaces.\r\n    IERC20 public collateralToken;\r\n    ExpandedIERC20 public longToken;\r\n    ExpandedIERC20 public shortToken;\r\n    FinderInterface public finder;\r\n    LongShortPairFinancialProductLibrary public financialProductLibrary;\r\n\r\n    // Optimistic oracle customization parameters.\r\n    bytes public customAncillaryData;\r\n    uint256 public proposerReward;\r\n    uint256 public optimisticOracleLivenessTime;\r\n    uint256 public optimisticOracleProposerBond;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event TokensCreated(address indexed sponsor, uint256 indexed collateralUsed, uint256 indexed tokensMinted);\r\n    event TokensRedeemed(address indexed sponsor, uint256 indexed collateralReturned, uint256 indexed tokensRedeemed);\r\n    event ContractExpired(address indexed caller);\r\n    event EarlyExpirationRequested(address indexed caller, uint64 earlyExpirationTimeStamp);\r\n    event PositionSettled(address indexed sponsor, uint256 collateralReturned, uint256 longTokens, uint256 shortTokens);\r\n\r\n    /****************************************\r\n     *               MODIFIERS              *\r\n     ****************************************/\r\n\r\n    modifier preExpiration() {\r\n        require(getCurrentTime() < expirationTimestamp, \"Only callable pre-expiry\");\r\n        _;\r\n    }\r\n\r\n    modifier postExpiration() {\r\n        require(getCurrentTime() >= expirationTimestamp, \"Only callable post-expiry\");\r\n        _;\r\n    }\r\n\r\n    modifier notEarlyExpired() {\r\n        require(!isContractEarlyExpired(), \"Contract already early expired\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Construct the LongShortPair\r\n     * @param params Constructor params used to initialize the LSP. Key-valued object with the following structure:\r\n     *    - `pairName`: Name of the long short pair contract.\r\n     *    - `expirationTimestamp`: Unix timestamp of when the contract will expire.\r\n     *    - `collateralPerPair`: How many units of collateral are required to mint one pair of synthetic tokens.\r\n     *    - `priceIdentifier`: Price identifier, registered in the DVM for the long short pair.\r\n     *    - `longToken`: Token used as long in the LSP. Mint and burn rights needed by this contract.\r\n     *    - `shortToken`: Token used as short in the LSP. Mint and burn rights needed by this contract.\r\n     *    - `collateralToken`: Collateral token used to back LSP synthetics.\r\n     *    - `financialProductLibrary`: Contract providing settlement payout logic.\r\n     *    - `customAncillaryData`: Custom ancillary data to be passed along with the price request to the OO.\r\n     *    - `proposerReward`: Preloaded reward to incentivize settlement price proposals.\r\n     *    - `optimisticOracleLivenessTime`: OO liveness time for price requests.\r\n     *    - `optimisticOracleProposerBond`: OO proposer bond for price requests.\r\n     *    - `finder`: DVM finder to find other UMA ecosystem contracts.\r\n     *    - `timerAddress`: Timer used to synchronize contract time in testing. Set to 0x000... in production.\r\n     */\r\n    constructor(ConstructorParams memory params) Testable(params.timerAddress) {\r\n        finder = params.finder;\r\n        require(bytes(params.pairName).length > 0, \"Pair name cant be empty\");\r\n        require(params.expirationTimestamp > getCurrentTime(), \"Expiration timestamp in past\");\r\n        require(params.collateralPerPair > 0, \"Collateral per pair cannot be 0\");\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(params.priceIdentifier), \"Identifier not registered\");\r\n        require(address(_getOptimisticOracle()) != address(0), \"Invalid finder\");\r\n        require(address(params.financialProductLibrary) != address(0), \"Invalid FinancialProductLibrary\");\r\n        require(_getCollateralWhitelist().isOnWhitelist(address(params.collateralToken)), \"Collateral not whitelisted\");\r\n        require(params.optimisticOracleLivenessTime > 0, \"OO liveness cannot be 0\");\r\n        require(params.optimisticOracleLivenessTime < 5200 weeks, \"OO liveness too large\");\r\n\r\n        pairName = params.pairName;\r\n        expirationTimestamp = params.expirationTimestamp;\r\n        collateralPerPair = params.collateralPerPair;\r\n        priceIdentifier = params.priceIdentifier;\r\n        enableEarlyExpiration = params.enableEarlyExpiration;\r\n\r\n        longToken = params.longToken;\r\n        shortToken = params.shortToken;\r\n        collateralToken = params.collateralToken;\r\n\r\n        financialProductLibrary = params.financialProductLibrary;\r\n        OptimisticOracleV2Interface optimisticOracle = _getOptimisticOracle();\r\n\r\n        // Ancillary data + additional stamped information should be less than ancillary data limit. Consider early\r\n        // expiration ancillary data, if enableEarlyExpiration is set.\r\n        customAncillaryData = params.customAncillaryData;\r\n        require(\r\n            optimisticOracle\r\n                .stampAncillaryData(\r\n                (enableEarlyExpiration ? getEarlyExpirationAncillaryData() : customAncillaryData),\r\n                address(this)\r\n            )\r\n                .length <= optimisticOracle.ancillaryBytesLimit(),\r\n            \"Ancillary Data too long\"\r\n        );\r\n\r\n        proposerReward = params.proposerReward;\r\n        optimisticOracleLivenessTime = params.optimisticOracleLivenessTime;\r\n        optimisticOracleProposerBond = params.optimisticOracleProposerBond;\r\n    }\r\n\r\n    /****************************************\r\n     *          POSITION FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Creates a pair of long and short tokens equal in number to tokensToCreate. Pulls the required collateral\r\n     * amount into this contract, defined by the collateralPerPair value.\r\n     * @dev The caller must approve this contract to transfer `tokensToCreate * collateralPerPair` amount of collateral.\r\n     * @param tokensToCreate number of long and short synthetic tokens to create.\r\n     * @return collateralUsed total collateral used to mint the synthetics.\r\n     */\r\n    function create(uint256 tokensToCreate) public preExpiration() nonReentrant() returns (uint256 collateralUsed) {\r\n        // Note the use of mulCeil to prevent small collateralPerPair causing rounding of collateralUsed to 0 enabling\r\n        // callers to mint dust LSP tokens without paying any collateral.\r\n        collateralUsed = FixedPoint.Unsigned(tokensToCreate).mulCeil(FixedPoint.Unsigned(collateralPerPair)).rawValue;\r\n\r\n        collateralToken.safeTransferFrom(msg.sender, address(this), collateralUsed);\r\n\r\n        require(longToken.mint(msg.sender, tokensToCreate));\r\n        require(shortToken.mint(msg.sender, tokensToCreate));\r\n\r\n        emit TokensCreated(msg.sender, collateralUsed, tokensToCreate);\r\n    }\r\n\r\n    /**\r\n     * @notice Redeems a pair of long and short tokens equal in number to tokensToRedeem. Returns the commensurate\r\n     * amount of collateral to the caller for the pair of tokens, defined by the collateralPerPair value.\r\n     * @dev This contract must have the `Burner` role for the `longToken` and `shortToken` in order to call `burnFrom`.\r\n     * @dev The caller does not need to approve this contract to transfer any amount of `tokensToRedeem` since long\r\n     * and short tokens are burned, rather than transferred, from the caller.\r\n     * @dev This method can be called either pre or post expiration.\r\n     * @param tokensToRedeem number of long and short synthetic tokens to redeem.\r\n     * @return collateralReturned total collateral returned in exchange for the pair of synthetics.\r\n     */\r\n    function redeem(uint256 tokensToRedeem) public nonReentrant() returns (uint256 collateralReturned) {\r\n        require(longToken.burnFrom(msg.sender, tokensToRedeem));\r\n        require(shortToken.burnFrom(msg.sender, tokensToRedeem));\r\n\r\n        collateralReturned = FixedPoint.Unsigned(tokensToRedeem).mul(FixedPoint.Unsigned(collateralPerPair)).rawValue;\r\n\r\n        collateralToken.safeTransfer(msg.sender, collateralReturned);\r\n\r\n        emit TokensRedeemed(msg.sender, collateralReturned, tokensToRedeem);\r\n    }\r\n\r\n    /**\r\n     * @notice Settle long and/or short tokens in for collateral at a rate informed by the contract settlement.\r\n     * @dev Uses financialProductLibrary to compute the redemption rate between long and short tokens.\r\n     * @dev This contract must have the `Burner` role for the `longToken` and `shortToken` in order to call `burnFrom`.\r\n     * @dev The caller does not need to approve this contract to transfer any amount of `tokensToRedeem` since long\r\n     * and short tokens are burned, rather than transferred, from the caller.\r\n     * @dev This function can be called before or after expiration to facilitate early expiration. If a price has\r\n     * not yet been resolved for either normal or early expiration yet then it will revert.\r\n     * @param longTokensToRedeem number of long tokens to settle.\r\n     * @param shortTokensToRedeem number of short tokens to settle.\r\n     * @return collateralReturned total collateral returned in exchange for the pair of synthetics.\r\n     */\r\n    function settle(uint256 longTokensToRedeem, uint256 shortTokensToRedeem)\r\n        public\r\n        nonReentrant()\r\n        returns (uint256 collateralReturned)\r\n    {\r\n        // Either early expiration is enabled and it's before the expiration time or it's after the expiration time.\r\n        require(\r\n            (enableEarlyExpiration && getCurrentTime() < expirationTimestamp) ||\r\n                getCurrentTime() >= expirationTimestamp,\r\n            \"Cannot settle\"\r\n        );\r\n\r\n        // Get the settlement price and store it. Also sets expiryPercentLong to inform settlement. Reverts if either:\r\n        // a) the price request has not resolved (either a normal expiration call or early expiration call) or b) If the\r\n        // the contract was attempted to be settled early but the price returned is the ignore oracle price.\r\n        // Note that we use the bool receivedSettlementPrice over checking for price != 0 as 0 is a valid price.\r\n        if (!receivedSettlementPrice) getExpirationPrice();\r\n\r\n        require(longToken.burnFrom(msg.sender, longTokensToRedeem));\r\n        require(shortToken.burnFrom(msg.sender, shortTokensToRedeem));\r\n\r\n        // expiryPercentLong is a number between 0 and 1e18. 0 means all collateral goes to short tokens and 1e18 means\r\n        // all collateral goes to the long token. Total collateral returned is the sum of payouts.\r\n        uint256 longCollateralRedeemed =\r\n            FixedPoint\r\n                .Unsigned(longTokensToRedeem)\r\n                .mul(FixedPoint.Unsigned(collateralPerPair))\r\n                .mul(FixedPoint.Unsigned(expiryPercentLong))\r\n                .rawValue;\r\n        uint256 shortCollateralRedeemed =\r\n            FixedPoint\r\n                .Unsigned(shortTokensToRedeem)\r\n                .mul(FixedPoint.Unsigned(collateralPerPair))\r\n                .mul(FixedPoint.fromUnscaledUint(1).sub(FixedPoint.Unsigned(expiryPercentLong)))\r\n                .rawValue;\r\n\r\n        collateralReturned = longCollateralRedeemed + shortCollateralRedeemed;\r\n        collateralToken.safeTransfer(msg.sender, collateralReturned);\r\n\r\n        emit PositionSettled(msg.sender, collateralReturned, longTokensToRedeem, shortTokensToRedeem);\r\n    }\r\n\r\n    /****************************************\r\n     *        GLOBAL STATE FUNCTIONS        *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Enables the LSP to request early expiration. This initiates a price request to the optimistic oracle at\r\n     * the provided timestamp with a modified version of the ancillary data that includes the key \"earlyExpiration:1\"\r\n     * which signals to the OO that this is an early expiration request, rather than standard settlement.\r\n     * @dev The caller must approve this contract to transfer `proposerReward` amount of collateral.\r\n     * @dev Will revert if: a) the contract is already early expired, b) it is after the expiration timestamp, c)\r\n     * early expiration is disabled for this contract, d) the proposed expiration timestamp is in the future.\r\n     * e) an early expiration attempt has already been made (in pending state).\r\n     * @param _earlyExpirationTimestamp timestamp at which the early expiration is proposed.\r\n     */\r\n    function requestEarlyExpiration(uint64 _earlyExpirationTimestamp)\r\n        public\r\n        nonReentrant()\r\n        notEarlyExpired()\r\n        preExpiration()\r\n    {\r\n        require(enableEarlyExpiration, \"Early expiration disabled\");\r\n        require(_earlyExpirationTimestamp <= getCurrentTime(), \"Only propose expire in the past\");\r\n        require(_earlyExpirationTimestamp > 0, \"Early expiration can't be 0\");\r\n\r\n        earlyExpirationTimestamp = _earlyExpirationTimestamp;\r\n\r\n        _requestOraclePrice(earlyExpirationTimestamp, getEarlyExpirationAncillaryData());\r\n\r\n        emit EarlyExpirationRequested(msg.sender, _earlyExpirationTimestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Expire the LSP contract. Makes a request to the optimistic oracle to inform the settlement price.\r\n     * @dev The caller must approve this contract to transfer `proposerReward` amount of collateral.\r\n     * @dev Will revert if: a) the contract is already early expired, b) it is before the expiration timestamp or c)\r\n     * an expire call has already been made.\r\n     */\r\n    function expire() public nonReentrant() notEarlyExpired() postExpiration() {\r\n        _requestOraclePrice(expirationTimestamp, customAncillaryData);\r\n\r\n        emit ContractExpired(msg.sender);\r\n    }\r\n\r\n    /***********************************\r\n     *      GLOBAL VIEW FUNCTIONS      *\r\n     ***********************************/\r\n\r\n    /**\r\n     * @notice Returns the number of long and short tokens a sponsor wallet holds.\r\n     * @param sponsor address of the sponsor to query.\r\n     * @return longTokens the number of long tokens held by the sponsor.\r\n     * @return shortTokens the number of short tokens held by the sponsor.\r\n     */\r\n    function getPositionTokens(address sponsor)\r\n        public\r\n        view\r\n        nonReentrantView()\r\n        returns (uint256 longTokens, uint256 shortTokens)\r\n    {\r\n        return (longToken.balanceOf(sponsor), shortToken.balanceOf(sponsor));\r\n    }\r\n\r\n    /**\r\n     * @notice Generates a modified ancillary data that indicates the contract is being expired early.\r\n     */\r\n    function getEarlyExpirationAncillaryData() public view returns (bytes memory) {\r\n        return AncillaryData.appendKeyValueUint(customAncillaryData, \"earlyExpiration\", 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Defines a special number that, if returned during an attempted early expiration, will cause the contract\r\n     * to do nothing and not expire. This enables the OO (and DVM voters in the case of a dispute) to choose to keep\r\n     * the contract running, thereby denying the early settlement request.\r\n     */\r\n    function ignoreEarlyExpirationPrice() public pure returns (int256) {\r\n        return type(int256).min;\r\n    }\r\n\r\n    /**\r\n     * @notice If the earlyExpirationTimestamp is != 0 then a previous early expiration OO request might still be in the\r\n     * pending state. Check if the OO contains the ignore early price. If it does not contain this then the contract\r\n     * was early expired correctly. Note that _getOraclePrice call will revert if the price request is still pending,\r\n     * thereby reverting all upstream calls pre-settlement of the early expiration price request.\r\n     */\r\n    function isContractEarlyExpired() public returns (bool) {\r\n        return (earlyExpirationTimestamp != 0 &&\r\n            _getOraclePrice(earlyExpirationTimestamp, getEarlyExpirationAncillaryData()) !=\r\n            ignoreEarlyExpirationPrice());\r\n    }\r\n\r\n    /****************************************\r\n     *          INTERNAL FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    // Return the oracle price for a given request timestamp and ancillary data combo.\r\n    function _getOraclePrice(uint64 requestTimestamp, bytes memory requestAncillaryData) internal returns (int256) {\r\n        return _getOptimisticOracle().settleAndGetPrice(priceIdentifier, requestTimestamp, requestAncillaryData);\r\n    }\r\n\r\n    // Request a price in the optimistic oracle for a given request timestamp and ancillary data combo. Set the bonds\r\n    // accordingly to the deployer's parameters. Will revert if re-requesting for a previously requested combo.\r\n    function _requestOraclePrice(uint64 requestTimestamp, bytes memory requestAncillaryData) internal {\r\n        OptimisticOracleV2Interface optimisticOracle = _getOptimisticOracle();\r\n\r\n        // If the proposer reward was set then pull it from the caller of the function.\r\n        if (proposerReward > 0) {\r\n            collateralToken.safeTransferFrom(msg.sender, address(this), proposerReward);\r\n            collateralToken.safeApprove(address(optimisticOracle), proposerReward);\r\n        }\r\n        optimisticOracle.requestPrice(\r\n            priceIdentifier,\r\n            uint256(requestTimestamp),\r\n            requestAncillaryData,\r\n            collateralToken,\r\n            proposerReward\r\n        );\r\n\r\n        // Set the Optimistic oracle liveness for the price request.\r\n        optimisticOracle.setCustomLiveness(\r\n            priceIdentifier,\r\n            uint256(requestTimestamp),\r\n            requestAncillaryData,\r\n            optimisticOracleLivenessTime\r\n        );\r\n\r\n        // Set the Optimistic oracle proposer bond for the price request.\r\n        optimisticOracle.setBond(\r\n            priceIdentifier,\r\n            uint256(requestTimestamp),\r\n            requestAncillaryData,\r\n            optimisticOracleProposerBond\r\n        );\r\n    }\r\n\r\n    // Fetch the optimistic oracle expiration price. If the oracle has the price for the provided expiration timestamp\r\n    // and customData combo then return this. Else, try fetch the price on the early expiration ancillary data. If\r\n    // there is no price for either, revert. If the early expiration price is the ignore price will also revert.\r\n    function getExpirationPrice() internal {\r\n        if (_getOptimisticOracle().hasPrice(address(this), priceIdentifier, expirationTimestamp, customAncillaryData))\r\n            expiryPrice = _getOraclePrice(expirationTimestamp, customAncillaryData);\r\n        else {\r\n            expiryPrice = _getOraclePrice(earlyExpirationTimestamp, getEarlyExpirationAncillaryData());\r\n            require(expiryPrice != ignoreEarlyExpirationPrice(), \"Oracle prevents early expiration\");\r\n        }\r\n\r\n        // Finally, compute the value of expiryPercentLong based on the expiryPrice. Cap the return value at 1e18 as\r\n        // this should, by definition, between 0 and 1e18.\r\n        expiryPercentLong = Math.min(\r\n            financialProductLibrary.percentageLongCollateralAtExpiry(expiryPrice),\r\n            FixedPoint.fromUnscaledUint(1).rawValue\r\n        );\r\n\r\n        receivedSettlementPrice = true;\r\n    }\r\n\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    function _getCollateralWhitelist() internal view returns (AddressWhitelistInterface) {\r\n        return AddressWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n    }\r\n\r\n    function _getOptimisticOracle() internal view returns (OptimisticOracleV2Interface) {\r\n        return OptimisticOracleV2Interface(finder.getImplementationAddress(OracleInterfaces.OptimisticOracleV2));\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/long-short-pair/LongShortPairCreator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\r\nimport \"../../common/interfaces/IERC20Standard.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../common/TokenFactory.sol\";\r\nimport \"./LongShortPair.sol\";\r\nimport \"../common/financial-product-libraries/long-short-pair-libraries/LongShortPairFinancialProductLibrary.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title Long Short Pair Contract Creator.\r\n * @notice Factory contract to create new instances of long short pair contracts.\r\n * Responsible for constraining the parameters used to construct a new LSP. These constraints can evolve over time and\r\n * are initially constrained to conservative values in this first iteration.\r\n */\r\ncontract LongShortPairCreator is Testable, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SafeERC20 for IERC20Standard;\r\n\r\n    struct CreatorParams {\r\n        string pairName;\r\n        uint64 expirationTimestamp;\r\n        uint256 collateralPerPair;\r\n        bytes32 priceIdentifier;\r\n        bool enableEarlyExpiration;\r\n        string longSynthName;\r\n        string longSynthSymbol;\r\n        string shortSynthName;\r\n        string shortSynthSymbol;\r\n        IERC20Standard collateralToken;\r\n        LongShortPairFinancialProductLibrary financialProductLibrary;\r\n        bytes customAncillaryData;\r\n        uint256 proposerReward;\r\n        uint256 optimisticOracleLivenessTime;\r\n        uint256 optimisticOracleProposerBond;\r\n    }\r\n\r\n    // Address of TokenFactory used to create a new synthetic token.\r\n    TokenFactory public tokenFactory;\r\n\r\n    FinderInterface public finder;\r\n\r\n    event CreatedLongShortPair(\r\n        address indexed longShortPair,\r\n        address indexed deployerAddress,\r\n        address longToken,\r\n        address shortToken\r\n    );\r\n\r\n    /**\r\n     * @notice Constructs the LongShortPairCreator contract.\r\n     * @param _finder UMA protocol Finder used to discover other protocol contracts.\r\n     * @param _tokenFactory ERC20 token factory used to deploy synthetic token instances.\r\n     * @param _timer Contract that stores the current time in a testing environment.\r\n     */\r\n    constructor(\r\n        FinderInterface _finder,\r\n        TokenFactory _tokenFactory,\r\n        address _timer\r\n    ) Testable(_timer) nonReentrant() {\r\n        tokenFactory = _tokenFactory;\r\n        finder = _finder;\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a longShortPair contract and associated long and short tokens.\r\n     * @param params Constructor params used to initialize the LSP. Key-valued object with the following structure:\r\n     *     - `pairName`: Name of the long short pair contract.\r\n     *     - `expirationTimestamp`: Unix timestamp of when the contract will expire.\r\n     *     - `collateralPerPair`: How many units of collateral are required to mint one pair of synthetic tokens.\r\n     *     - `priceIdentifier`: Registered in the DVM for the synthetic.\r\n     *     - `enableEarlyExpiration`: Enables the LSP contract to be settled early.\r\n     *     - `longSynthName`: Name of the long synthetic tokens to be created.\r\n     *     - `longSynthSymbol`: Symbol of the long synthetic tokens to be created.\r\n     *     - `shortSynthName`: Name of the short synthetic tokens to be created.\r\n     *     - `shortSynthSymbol`: Symbol of the short synthetic tokens to be created.\r\n     *     - `collateralToken`: ERC20 token used as collateral in the LSP.\r\n     *     - `financialProductLibrary`: Contract providing settlement payout logic.\r\n     *     - `customAncillaryData`: Custom ancillary data to be passed along with the price request. If not needed, this\r\n     *                              should be left as a 0-length bytes array.\r\n     *     - `proposerReward`: Optimistic oracle reward amount, pulled from the caller of the expire function.\r\n     *     - `optimisticOracleLivenessTime`: Optimistic oracle liveness time for price requests.\r\n     *     - `optimisticOracleProposerBond`: Optimistic oracle proposer bond for price requests.\r\n     * @return lspAddress the deployed address of the new long short pair contract.\r\n     * @notice Created LSP is not registered within the registry as the LSP uses the Optimistic Oracle for settlement.\r\n     * @notice The LSP constructor does a number of validations on input params. These are not repeated here.\r\n     */\r\n    function createLongShortPair(CreatorParams memory params) public nonReentrant() returns (address) {\r\n        // Create a new synthetic token using the params.\r\n        require(bytes(params.longSynthName).length != 0, \"Missing long synthetic name\");\r\n        require(bytes(params.shortSynthName).length != 0, \"Missing short synthetic name\");\r\n        require(bytes(params.longSynthSymbol).length != 0, \"Missing long synthetic symbol\");\r\n        require(bytes(params.shortSynthSymbol).length != 0, \"Missing short synthetic symbol\");\r\n\r\n        // If the collateral token does not have a `decimals()` method, then a default precision of 18 will be\r\n        // applied to the newly created synthetic token.\r\n        uint8 collateralDecimals = _getSyntheticDecimals(params.collateralToken);\r\n        ExpandedIERC20 longToken =\r\n            tokenFactory.createToken(params.longSynthName, params.longSynthSymbol, collateralDecimals);\r\n        ExpandedIERC20 shortToken =\r\n            tokenFactory.createToken(params.shortSynthName, params.shortSynthSymbol, collateralDecimals);\r\n\r\n        // Deploy the LSP contract.\r\n        LongShortPair lsp = new LongShortPair(_convertParams(params, longToken, shortToken));\r\n\r\n        address lspAddress = address(lsp);\r\n\r\n        // Give permissions to new lsp contract and then hand over ownership.\r\n        longToken.addMinter(lspAddress);\r\n        longToken.addBurner(lspAddress);\r\n        longToken.resetOwner(lspAddress);\r\n\r\n        shortToken.addMinter(lspAddress);\r\n        shortToken.addBurner(lspAddress);\r\n        shortToken.resetOwner(lspAddress);\r\n\r\n        emit CreatedLongShortPair(lspAddress, msg.sender, address(longToken), address(shortToken));\r\n\r\n        return lspAddress;\r\n    }\r\n\r\n    // Converts createLongShortPair creator params to LongShortPair constructor params.\r\n    function _convertParams(\r\n        CreatorParams memory creatorParams,\r\n        ExpandedIERC20 longToken,\r\n        ExpandedIERC20 shortToken\r\n    ) private view returns (LongShortPair.ConstructorParams memory constructorParams) {\r\n        // Input from function call.\r\n        constructorParams.pairName = creatorParams.pairName;\r\n        constructorParams.expirationTimestamp = creatorParams.expirationTimestamp;\r\n        constructorParams.collateralPerPair = creatorParams.collateralPerPair;\r\n        constructorParams.priceIdentifier = creatorParams.priceIdentifier;\r\n        constructorParams.enableEarlyExpiration = creatorParams.enableEarlyExpiration;\r\n        constructorParams.collateralToken = creatorParams.collateralToken;\r\n        constructorParams.financialProductLibrary = creatorParams.financialProductLibrary;\r\n        constructorParams.customAncillaryData = creatorParams.customAncillaryData;\r\n        constructorParams.proposerReward = creatorParams.proposerReward;\r\n        constructorParams.optimisticOracleLivenessTime = creatorParams.optimisticOracleLivenessTime;\r\n        constructorParams.optimisticOracleProposerBond = creatorParams.optimisticOracleProposerBond;\r\n\r\n        // Constructed long & short synthetic tokens.\r\n        constructorParams.longToken = longToken;\r\n        constructorParams.shortToken = shortToken;\r\n\r\n        // Finder and timer. Should be the same as that used in this factory contract.\r\n        constructorParams.finder = finder;\r\n        constructorParams.timerAddress = timerAddress;\r\n    }\r\n\r\n    // IERC20Standard.decimals() will revert if the collateral contract has not implemented the decimals() method,\r\n    // which is possible since the method is only an OPTIONAL method in the ERC20 standard:\r\n    // https://eips.ethereum.org/EIPS/eip-20#methods.\r\n    function _getSyntheticDecimals(IERC20Standard _collateralToken) private view returns (uint8 decimals) {\r\n        try _collateralToken.decimals() returns (uint8 _decimals) {\r\n            return _decimals;\r\n        } catch {\r\n            return 18;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/optimistic-distributor/OptimisticDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/AncillaryData.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/MultiCaller.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/interfaces/AddressWhitelistInterface.sol\";\r\nimport \"../../merkle-distributor/implementation/MerkleDistributor.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../../optimistic-oracle-v2/interfaces/OptimisticOracleV2Interface.sol\";\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n/**\r\n * @title  OptimisticDistributor contract.\r\n * @notice Allows sponsors to distribute rewards through MerkleDistributor contract secured by UMA Optimistic Oracle.\r\n */\r\ncontract OptimisticDistributor is Lockable, MultiCaller, Testable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /********************************************\r\n     *  OPTIMISTIC DISTRIBUTOR DATA STRUCTURES  *\r\n     ********************************************/\r\n\r\n    // Represents reward posted by a sponsor.\r\n    struct Reward {\r\n        bool distributionExecuted;\r\n        address sponsor;\r\n        IERC20 rewardToken;\r\n        uint256 maximumRewardAmount;\r\n        uint256 earliestProposalTimestamp;\r\n        uint256 optimisticOracleProposerBond;\r\n        uint256 optimisticOracleLivenessTime;\r\n        uint256 previousProposalTimestamp;\r\n        bytes32 priceIdentifier;\r\n        bytes customAncillaryData;\r\n    }\r\n\r\n    // Represents proposed rewards distribution.\r\n    struct Proposal {\r\n        uint256 rewardIndex;\r\n        uint256 timestamp;\r\n        bytes32 merkleRoot;\r\n        string ipfsHash;\r\n    }\r\n\r\n    /********************************************\r\n     *      STATE VARIABLES AND CONSTANTS       *\r\n     ********************************************/\r\n\r\n    // Reserve for bytes appended to ancillary data (e.g. OracleSpoke) when resolving price from non-mainnet chains.\r\n    // This also covers appending rewardIndex by this contract.\r\n    uint256 public constant ANCILLARY_BYTES_RESERVE = 512;\r\n\r\n    // Restrict Optimistic Oracle liveness to between 10 minutes and 100 years.\r\n    uint256 public constant MINIMUM_LIVENESS = 10 minutes;\r\n    uint256 public constant MAXIMUM_LIVENESS = 5200 weeks;\r\n\r\n    // Ancillary data length limit can be synced and stored in the contract.\r\n    uint256 public ancillaryBytesLimit;\r\n\r\n    // Rewards are stored in dynamic array.\r\n    Reward[] public rewards;\r\n\r\n    // Immutable variables used to validate input parameters when funding new rewards.\r\n    uint256 public immutable maximumFundingPeriod;\r\n    uint256 public immutable maximumProposerBond;\r\n\r\n    // Proposals are mapped to hash of their identifier, timestamp and ancillaryData.\r\n    mapping(bytes32 => Proposal) public proposals;\r\n\r\n    // Immutable variables provided at deployment.\r\n    FinderInterface public immutable finder;\r\n    IERC20 public immutable bondToken;\r\n\r\n    // Merkle Distributor is automatically deployed on constructor and owned by this contract.\r\n    MerkleDistributor public immutable merkleDistributor;\r\n\r\n    // Interface parameters that can be synced and stored in the contract.\r\n    OptimisticOracleV2Interface public optimisticOracle;\r\n\r\n    /********************************************\r\n     *                  EVENTS                  *\r\n     ********************************************/\r\n\r\n    event RewardCreated(\r\n        address indexed sponsor,\r\n        IERC20 rewardToken,\r\n        uint256 indexed rewardIndex,\r\n        uint256 maximumRewardAmount,\r\n        uint256 earliestProposalTimestamp,\r\n        uint256 optimisticOracleProposerBond,\r\n        uint256 optimisticOracleLivenessTime,\r\n        bytes32 indexed priceIdentifier,\r\n        bytes customAncillaryData\r\n    );\r\n    event RewardIncreased(uint256 indexed rewardIndex, uint256 newMaximumRewardAmount);\r\n    event ProposalCreated(\r\n        address indexed sponsor,\r\n        IERC20 rewardToken,\r\n        uint256 indexed rewardIndex,\r\n        uint256 proposalTimestamp,\r\n        uint256 maximumRewardAmount,\r\n        bytes32 indexed proposalId,\r\n        bytes32 merkleRoot,\r\n        string ipfsHash\r\n    );\r\n    event RewardDistributed(\r\n        address indexed sponsor,\r\n        IERC20 rewardToken,\r\n        uint256 indexed rewardIndex,\r\n        uint256 maximumRewardAmount,\r\n        bytes32 indexed proposalId,\r\n        bytes32 merkleRoot,\r\n        string ipfsHash\r\n    );\r\n    event ProposalRejected(uint256 indexed rewardIndex, bytes32 indexed proposalId);\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _finder Finder to look up UMA contract addresses.\r\n     * @param _bondToken ERC20 token that the bond is paid in.\r\n     * @param _timer Contract that stores the current time in a testing environment.\r\n     * @param _maximumFundingPeriod Maximum period for reward funding (proposals allowed only afterwards).\r\n     * @param _maximumProposerBond Maximum allowed Optimistic Oracle proposer bond amount.\r\n     */\r\n    constructor(\r\n        FinderInterface _finder,\r\n        IERC20 _bondToken,\r\n        address _timer,\r\n        uint256 _maximumFundingPeriod,\r\n        uint256 _maximumProposerBond\r\n    ) Testable(_timer) {\r\n        finder = _finder;\r\n        require(_getCollateralWhitelist().isOnWhitelist(address(_bondToken)), \"Bond token not supported\");\r\n        bondToken = _bondToken;\r\n        syncUmaEcosystemParams();\r\n        maximumFundingPeriod = _maximumFundingPeriod;\r\n        maximumProposerBond = _maximumProposerBond;\r\n        merkleDistributor = new MerkleDistributor();\r\n    }\r\n\r\n    /********************************************\r\n     *            FUNDING FUNCTIONS             *\r\n     ********************************************/\r\n\r\n    /**\r\n     * @notice Allows any caller to create a Reward struct and deposit tokens that are linked to these rewards.\r\n     * @dev The caller must approve this contract to transfer `maximumRewardAmount` amount of `rewardToken`.\r\n     * @param rewardToken ERC20 token that the rewards will be paid in.\r\n     * @param maximumRewardAmount Maximum reward amount that the sponsor is posting for distribution.\r\n     * @param earliestProposalTimestamp Starting timestamp when proposals for distribution can be made.\r\n     * @param priceIdentifier Identifier that should be passed to the Optimistic Oracle on proposed distribution.\r\n     * @param customAncillaryData Custom ancillary data that should be sent to the Optimistic Oracle on proposed\r\n     * distribution.\r\n     * @param optimisticOracleProposerBond Amount of bondToken that should be posted in addition to final fee\r\n     * to the Optimistic Oracle on proposed distribution.\r\n     * @param optimisticOracleLivenessTime Liveness period in seconds during which proposed distribution can be\r\n     * disputed through Optimistic Oracle.\r\n     */\r\n    function createReward(\r\n        uint256 maximumRewardAmount,\r\n        uint256 earliestProposalTimestamp,\r\n        uint256 optimisticOracleProposerBond,\r\n        uint256 optimisticOracleLivenessTime,\r\n        bytes32 priceIdentifier,\r\n        IERC20 rewardToken,\r\n        bytes calldata customAncillaryData\r\n    ) external nonReentrant() {\r\n        require(earliestProposalTimestamp <= getCurrentTime() + maximumFundingPeriod, \"Too long till proposal opening\");\r\n        require(optimisticOracleProposerBond <= maximumProposerBond, \"OO proposer bond too high\");\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(priceIdentifier), \"Identifier not registered\");\r\n        require(_ancillaryDataWithinLimits(customAncillaryData), \"Ancillary data too long\");\r\n        require(optimisticOracleLivenessTime >= MINIMUM_LIVENESS, \"OO liveness too small\");\r\n        require(optimisticOracleLivenessTime < MAXIMUM_LIVENESS, \"OO liveness too large\");\r\n\r\n        // Store funded reward and log created reward.\r\n        Reward memory reward =\r\n            Reward({\r\n                distributionExecuted: false,\r\n                sponsor: msg.sender,\r\n                rewardToken: rewardToken,\r\n                maximumRewardAmount: maximumRewardAmount,\r\n                earliestProposalTimestamp: earliestProposalTimestamp,\r\n                optimisticOracleProposerBond: optimisticOracleProposerBond,\r\n                optimisticOracleLivenessTime: optimisticOracleLivenessTime,\r\n                previousProposalTimestamp: 0,\r\n                priceIdentifier: priceIdentifier,\r\n                customAncillaryData: customAncillaryData\r\n            });\r\n        uint256 rewardIndex = rewards.length;\r\n        rewards.push() = reward;\r\n        emit RewardCreated(\r\n            reward.sponsor,\r\n            reward.rewardToken,\r\n            rewardIndex,\r\n            reward.maximumRewardAmount,\r\n            reward.earliestProposalTimestamp,\r\n            reward.optimisticOracleProposerBond,\r\n            reward.optimisticOracleLivenessTime,\r\n            reward.priceIdentifier,\r\n            reward.customAncillaryData\r\n        );\r\n\r\n        // Pull maximum rewards from the sponsor.\r\n        rewardToken.safeTransferFrom(msg.sender, address(this), maximumRewardAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows anyone to deposit additional rewards for distribution before `earliestProposalTimestamp`.\r\n     * @dev The caller must approve this contract to transfer `additionalRewardAmount` amount of `rewardToken`.\r\n     * @param rewardIndex Index for identifying existing Reward struct that should receive additional funding.\r\n     * @param additionalRewardAmount Additional reward amount that the sponsor is posting for distribution.\r\n     */\r\n    function increaseReward(uint256 rewardIndex, uint256 additionalRewardAmount) external nonReentrant() {\r\n        require(rewardIndex < rewards.length, \"Invalid rewardIndex\");\r\n        require(getCurrentTime() < rewards[rewardIndex].earliestProposalTimestamp, \"Funding period ended\");\r\n\r\n        // Update maximumRewardAmount and log new amount.\r\n        rewards[rewardIndex].maximumRewardAmount += additionalRewardAmount;\r\n        emit RewardIncreased(rewardIndex, rewards[rewardIndex].maximumRewardAmount);\r\n\r\n        // Pull additional rewards from the sponsor.\r\n        rewards[rewardIndex].rewardToken.safeTransferFrom(msg.sender, address(this), additionalRewardAmount);\r\n    }\r\n\r\n    /********************************************\r\n     *          DISTRIBUTION FUNCTIONS          *\r\n     ********************************************/\r\n\r\n    /**\r\n     * @notice Allows any caller to propose distribution for funded reward starting from `earliestProposalTimestamp`.\r\n     * Only one undisputed proposal at a time is allowed.\r\n     * @dev The caller must approve this contract to transfer `optimisticOracleProposerBond` + final fee amount\r\n     * of `bondToken`.\r\n     * @param rewardIndex Index for identifying existing Reward struct that should be proposed for distribution.\r\n     * @param merkleRoot Merkle root describing allocation of proposed rewards distribution.\r\n     * @param ipfsHash Hash of IPFS object, conveniently stored for clients to verify proposed distribution.\r\n     */\r\n    function proposeDistribution(\r\n        uint256 rewardIndex,\r\n        bytes32 merkleRoot,\r\n        string calldata ipfsHash\r\n    ) external nonReentrant() {\r\n        require(rewardIndex < rewards.length, \"Invalid rewardIndex\");\r\n\r\n        uint256 timestamp = getCurrentTime();\r\n        Reward memory reward = rewards[rewardIndex];\r\n        require(timestamp >= reward.earliestProposalTimestamp, \"Cannot propose in funding period\");\r\n        require(!reward.distributionExecuted, \"Reward already distributed\");\r\n        require(_noBlockingProposal(rewardIndex, reward), \"New proposals blocked\");\r\n\r\n        // Store current timestamp at reward struct so that any subsequent proposals are blocked till dispute.\r\n        rewards[rewardIndex].previousProposalTimestamp = timestamp;\r\n\r\n        // Append rewardIndex to ancillary data.\r\n        bytes memory ancillaryData = _appendRewardIndex(rewardIndex, reward.customAncillaryData);\r\n\r\n        // Generate hash for proposalId.\r\n        bytes32 proposalId = _getProposalId(reward.priceIdentifier, timestamp, ancillaryData);\r\n\r\n        // Request price from Optimistic Oracle.\r\n        optimisticOracle.requestPrice(reward.priceIdentifier, timestamp, ancillaryData, bondToken, 0);\r\n\r\n        // Set proposal liveness and bond and calculate total bond amount.\r\n        optimisticOracle.setCustomLiveness(\r\n            reward.priceIdentifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            reward.optimisticOracleLivenessTime\r\n        );\r\n        uint256 totalBond =\r\n            optimisticOracle.setBond(\r\n                reward.priceIdentifier,\r\n                timestamp,\r\n                ancillaryData,\r\n                reward.optimisticOracleProposerBond\r\n            );\r\n\r\n        // Pull proposal bond and final fee from the proposer, and approve it for Optimistic Oracle.\r\n        bondToken.safeTransferFrom(msg.sender, address(this), totalBond);\r\n        bondToken.safeApprove(address(optimisticOracle), totalBond);\r\n\r\n        // Propose canonical value representing \"True\"; i.e. the proposed distribution is valid.\r\n        optimisticOracle.proposePriceFor(\r\n            msg.sender,\r\n            address(this),\r\n            reward.priceIdentifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            int256(1e18)\r\n        );\r\n\r\n        // Store and log proposed distribution.\r\n        proposals[proposalId] = Proposal({\r\n            rewardIndex: rewardIndex,\r\n            timestamp: timestamp,\r\n            merkleRoot: merkleRoot,\r\n            ipfsHash: ipfsHash\r\n        });\r\n        emit ProposalCreated(\r\n            reward.sponsor,\r\n            reward.rewardToken,\r\n            rewardIndex,\r\n            timestamp,\r\n            reward.maximumRewardAmount,\r\n            proposalId,\r\n            merkleRoot,\r\n            ipfsHash\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allows any caller to execute distribution that has been validated by the Optimistic Oracle.\r\n     * @param proposalId Hash for identifying existing rewards distribution proposal.\r\n     * @dev Calling this for unresolved proposals will revert.\r\n     */\r\n    function executeDistribution(bytes32 proposalId) external nonReentrant() {\r\n        // All valid proposals should have non-zero proposal timestamp.\r\n        Proposal memory proposal = proposals[proposalId];\r\n        require(proposal.timestamp != 0, \"Invalid proposalId\");\r\n\r\n        // Only one validated proposal per reward can be executed for distribution.\r\n        Reward memory reward = rewards[proposal.rewardIndex];\r\n        require(!reward.distributionExecuted, \"Reward already distributed\");\r\n\r\n        // Append reward index to ancillary data.\r\n        bytes memory ancillaryData = _appendRewardIndex(proposal.rewardIndex, reward.customAncillaryData);\r\n\r\n        // Get resolved price. Reverts if the request is not settled or settleable.\r\n        int256 resolvedPrice =\r\n            optimisticOracle.settleAndGetPrice(reward.priceIdentifier, proposal.timestamp, ancillaryData);\r\n\r\n        // Transfer rewards to MerkleDistributor for accepted proposal and flag distributionExecuted.\r\n        // This does not revert on rejected proposals so that disputer could receive back its bond and winning\r\n        // in the same transaction when settleAndGetPrice is called above.\r\n        if (resolvedPrice == 1e18) {\r\n            rewards[proposal.rewardIndex].distributionExecuted = true;\r\n\r\n            reward.rewardToken.safeApprove(address(merkleDistributor), reward.maximumRewardAmount);\r\n            merkleDistributor.setWindow(\r\n                reward.maximumRewardAmount,\r\n                address(reward.rewardToken),\r\n                proposal.merkleRoot,\r\n                proposal.ipfsHash\r\n            );\r\n            emit RewardDistributed(\r\n                reward.sponsor,\r\n                reward.rewardToken,\r\n                proposal.rewardIndex,\r\n                reward.maximumRewardAmount,\r\n                proposalId,\r\n                proposal.merkleRoot,\r\n                proposal.ipfsHash\r\n            );\r\n        }\r\n        // ProposalRejected can be emitted multiple times whenever someone tries to execute the same rejected proposal.\r\n        else emit ProposalRejected(proposal.rewardIndex, proposalId);\r\n    }\r\n\r\n    /********************************************\r\n     *          MAINTENANCE FUNCTIONS           *\r\n     ********************************************/\r\n\r\n    /**\r\n     * @notice Updates the address stored in this contract for the OptimisticOracle to the latest version set\r\n     * in the Finder.\r\n     * @dev There is no risk of leaving this function public for anyone to call as in all cases we want the address of\r\n     * OptimisticOracle in this contract to map to the latest version in the Finder.\r\n     */\r\n    function syncUmaEcosystemParams() public nonReentrant() {\r\n        optimisticOracle = _getOptimisticOracle();\r\n        ancillaryBytesLimit = optimisticOracle.ancillaryBytesLimit();\r\n    }\r\n\r\n    /********************************************\r\n     *            INTERNAL FUNCTIONS            *\r\n     ********************************************/\r\n\r\n    function _getOptimisticOracle() internal view returns (OptimisticOracleV2Interface) {\r\n        return OptimisticOracleV2Interface(finder.getImplementationAddress(OracleInterfaces.OptimisticOracleV2));\r\n    }\r\n\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    function _getCollateralWhitelist() internal view returns (AddressWhitelistInterface) {\r\n        return AddressWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n    }\r\n\r\n    function _appendRewardIndex(uint256 rewardIndex, bytes memory customAncillaryData)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return AncillaryData.appendKeyValueUint(customAncillaryData, \"rewardIndex\", rewardIndex);\r\n    }\r\n\r\n    function _ancillaryDataWithinLimits(bytes memory customAncillaryData) internal view returns (bool) {\r\n        // Since rewardIndex has variable length as string, it is not appended here and is assumed\r\n        // to be included in ANCILLARY_BYTES_RESERVE.\r\n        return\r\n            optimisticOracle.stampAncillaryData(customAncillaryData, address(this)).length + ANCILLARY_BYTES_RESERVE <=\r\n            ancillaryBytesLimit;\r\n    }\r\n\r\n    function _getProposalId(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(identifier, timestamp, ancillaryData));\r\n    }\r\n\r\n    // Returns true if there are no blocking proposals (eiter there were no prior proposals or they were disputed).\r\n    function _noBlockingProposal(uint256 rewardIndex, Reward memory reward) internal view returns (bool) {\r\n        // Valid proposal cannot have zero timestamp.\r\n        if (reward.previousProposalTimestamp == 0) return true;\r\n\r\n        bytes memory ancillaryData = _appendRewardIndex(rewardIndex, reward.customAncillaryData);\r\n        OptimisticOracleV2Interface.Request memory blockingRequest =\r\n            optimisticOracle.getRequest(\r\n                address(this),\r\n                reward.priceIdentifier,\r\n                reward.previousProposalTimestamp,\r\n                ancillaryData\r\n            );\r\n\r\n        // Previous proposal is blocking till disputed that can be detected by non-zero disputer address.\r\n        // In case Optimistic Oracle was upgraded since the previous proposal it needs to be unblocked for new proposal.\r\n        // This can be detected by uninitialized bonding currency for the previous proposal.\r\n        return blockingRequest.disputer != address(0) || address(blockingRequest.currency) == address(0);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/optimistic-rewarder/OptimisticRewarder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"./OptimisticRewarderBase.sol\";\r\nimport \"./OptimisticRewarderToken.sol\";\r\n\r\n/**\r\n * @notice The common optimistic rewarder contract. It is both the contract that pays out the rewards and the ERC721\r\n * token itself.\r\n */\r\ncontract OptimisticRewarder is OptimisticRewarderBase, OptimisticRewarderToken {\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _name name for the ERC721 token.\r\n     * @param _symbol symbol for the ERC721 token.\r\n     * @param _baseUri prefix to each ERC721 tokenId's name.\r\n     * @param _liveness liveness period between submission and verification of a reward.\r\n     * @param _bondToken ERC20 token that the bond is paid in.\r\n     * @param _bond size of the bond.\r\n     * @param _identifier identifier that should be passed to the optimistic oracle on dispute.\r\n     * @param _customAncillaryData custom ancillary data that should be sent to the optimistic oracle on dispute.\r\n     * @param _finder finder to look up UMA contract addresses.\r\n     */\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _baseUri,\r\n        uint256 _liveness,\r\n        IERC20 _bondToken,\r\n        uint256 _bond,\r\n        bytes32 _identifier,\r\n        bytes memory _customAncillaryData,\r\n        FinderInterface _finder\r\n    )\r\n        OptimisticRewarderBase(_liveness, _bondToken, _bond, _identifier, _customAncillaryData, _finder)\r\n        OptimisticRewarderToken(_name, _symbol, _baseUri)\r\n    {}\r\n\r\n    /**\r\n     * @notice Used to mint the next ERC721 tokenId.\r\n     * @param recipient the recipient of the newly minted token.\r\n     */\r\n    function mintNextToken(address recipient)\r\n        public\r\n        virtual\r\n        override(OptimisticRewarderBase, OptimisticRewarderToken)\r\n        returns (uint256)\r\n    {\r\n        return OptimisticRewarderToken.mintNextToken(recipient);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to check the owner of the token.\r\n     * @dev this override is a formality required by solidity. It forwards the call to the internal ERC721\r\n     * immplentation.\r\n     * @param tokenId the tokenId to check the owner of.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override(OptimisticRewarderBase, ERC721) returns (address) {\r\n        return ERC721.ownerOf(tokenId);\r\n    }\r\n}\r\n\r\n/**\r\n * @notice The optimistic rewarder that does not contain the ERC721 token. It allows the user to pass in an external\r\n * ERC721 token.\r\n * @dev this setup allows for graceful migrations to new rewarder contracts. It also allows external ERC721 tokens,\r\n * like uniswap v3 positions to be rewarded.\r\n */\r\ncontract OptimisticRewarderNoToken is OptimisticRewarderBase {\r\n    OptimisticRewarderToken public token;\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _token external ERC721 token for the rewarder to base redemptions on. Note: this token doesn't\r\n     * necessarily need to implement the mintNextToken method. See mintNextToken below for details.\r\n     * @param _liveness liveness period between submission and verification of a reward.\r\n     * @param _bondToken ERC20 token that the bond is paid in.\r\n     * @param _bond size of the bond.\r\n     * @param _identifier identifier that should be passed to the optimistic oracle on dispute.\r\n     * @param _customAncillaryData custom ancillary data that should be sent to the optimistic oracle on dispute.\r\n     * @param _finder finder to look up UMA contract addresses.\r\n     */\r\n    constructor(\r\n        OptimisticRewarderToken _token,\r\n        uint256 _liveness,\r\n        IERC20 _bondToken,\r\n        uint256 _bond,\r\n        bytes32 _identifier,\r\n        bytes memory _customAncillaryData,\r\n        FinderInterface _finder\r\n    ) OptimisticRewarderBase(_liveness, _bondToken, _bond, _identifier, _customAncillaryData, _finder) {\r\n        token = _token;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to mint the next ERC721 tokenId.\r\n     * @dev even if token contract does not support the `mintNextToken` function, this contract can still function\r\n     * correctly assuming there is some other way to mint the ERC721 tokens. An issue in this method will only\r\n     * affect the mint token in the base contract. Other methods will work fine.\r\n     * @param recipient the recipient of the newly minted token.\r\n     */\r\n    function mintNextToken(address recipient) public virtual override returns (uint256) {\r\n        return token.mintNextToken(recipient);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to check the owner of the token.\r\n     * @dev this override forwards the call to the external token contract.\r\n     * @param tokenId the tokenId to check the owner of.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        return token.ownerOf(tokenId);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/optimistic-rewarder/OptimisticRewarderBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/MultiCaller.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../../optimistic-oracle-v2/interfaces/SkinnyOptimisticOracleInterface.sol\";\r\nimport \"../../common/implementation/AncillaryData.sol\";\r\nimport \"../../common/interfaces/AddressWhitelistInterface.sol\";\r\n\r\n/**\r\n * @notice The base rewarder contract. This manages depositing rewards and paying them out to token holders using values\r\n * backed by the OptimisticOracle's dispute process.\r\n */\r\nabstract contract OptimisticRewarderBase is Lockable, MultiCaller {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct RedemptionAmount {\r\n        uint256 amount;\r\n        IERC20 token;\r\n    }\r\n\r\n    struct Redemption {\r\n        uint256 finalFee;\r\n        uint256 expiryTime;\r\n    }\r\n\r\n    // Constants.\r\n    FinderInterface public finder;\r\n    bytes public customAncillaryData;\r\n    IERC20 public bondToken;\r\n    bytes32 public identifier;\r\n\r\n    // Note: setters are intentionally absent for these parameters. If a deployer intends to modify these parameters,\r\n    // this contract suite offers a simple migration path where a new Rewarder is created and the existing ERC721 token\r\n    // can be passed in and used as the reward token there as well. This would be minimally painful for users.\r\n    uint256 public liveness;\r\n    uint256 public bond;\r\n\r\n    // Parameters that can be synced and stored in the contract.\r\n    uint256 public finalFee;\r\n    StoreInterface public store;\r\n    SkinnyOptimisticOracleInterface public optimisticOracle;\r\n\r\n    // Mapping to track redemptions.\r\n    mapping(bytes32 => Redemption) public redemptions;\r\n\r\n    // Mapping to track the past total cumulative redemptions for tokenIds.\r\n    mapping(uint256 => mapping(IERC20 => uint256)) public redeemedAmounts;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    // This allows other contracts to publish reward updates.\r\n    event UpdateToken(uint256 indexed tokenId, address indexed caller, bytes data);\r\n\r\n    event Deposited(address indexed depositor, IERC20 indexed token, uint256 amount);\r\n\r\n    // Lifecycle events for redemptions.\r\n    event Requested(\r\n        uint256 indexed tokenId,\r\n        bytes32 indexed redemptionId,\r\n        RedemptionAmount[] cumulativeRedemptions,\r\n        uint256 expiryTime\r\n    );\r\n    event Canceled(uint256 indexed tokenId, bytes32 indexed redemptionId, uint256 expiryTime);\r\n    event Disputed(uint256 indexed tokenId, bytes32 indexed redemptionId, uint256 expiryTime);\r\n    event Redeemed(uint256 indexed tokenId, bytes32 indexed redemptionId, uint256 expiryTime);\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _liveness liveness period between submission and verification of a reward.\r\n     * @param _bondToken ERC20 token that the bond is paid in.\r\n     * @param _bond size of the bond.\r\n     * @param _identifier identifier that should be passed to the optimistic oracle on dispute.\r\n     * @param _customAncillaryData custom ancillary data that should be sent to the optimistic oracle on dispute.\r\n     * @param _finder finder to look up UMA contract addresses.\r\n     */\r\n    constructor(\r\n        uint256 _liveness,\r\n        IERC20 _bondToken,\r\n        uint256 _bond,\r\n        bytes32 _identifier,\r\n        bytes memory _customAncillaryData,\r\n        FinderInterface _finder\r\n    ) {\r\n        require(_liveness > 0, \"liveness can't be 0\");\r\n        liveness = _liveness;\r\n        finder = _finder;\r\n        require(_getCollateralWhitelist().isOnWhitelist(address(_bondToken)), \"bond token not supported\");\r\n        bondToken = _bondToken;\r\n        bond = _bond;\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(_identifier), \"identifier not supported\");\r\n        identifier = _identifier;\r\n        SkinnyOptimisticOracleInterface skinnyOptimisticOracle = _getOptimisticOracle();\r\n        require(\r\n            skinnyOptimisticOracle\r\n                .stampAncillaryData(\r\n                AncillaryData.appendKeyValueBytes32(_customAncillaryData, \"redemptionId\", bytes32(0)),\r\n                address(this)\r\n            )\r\n                .length <= skinnyOptimisticOracle.ancillaryBytesLimit(),\r\n            \"ancillary data too long\"\r\n        );\r\n        customAncillaryData = _customAncillaryData;\r\n        _sync();\r\n    }\r\n\r\n    /****************************************\r\n     *       GLOBAL PUBLIC FUNCTIONS        *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Allows anyone to deposit reward tokens into the contract. Presumably, this would be the deployer or\r\n     * protocol that wishes to reward the users interacting with the system.\r\n     * @dev Once tokens are deposited, they cannot be withdrawn without claiming a reward. If a deployer wants an\r\n     * \"escape hatch\", they can create a special tokenId for this purpose.\r\n     * @param token ERC20 token that is being deposited.\r\n     * @param amount amount of rewards to deposit.\r\n     */\r\n    function depositRewards(IERC20 token, uint256 amount) public nonReentrant {\r\n        token.safeTransferFrom(msg.sender, address(this), amount);\r\n        emit Deposited(msg.sender, token, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the caller to mint a token to the receiver and include a reward-relevant update event with it.\r\n     * This is intended to be used when the user first interacts with a reward-granting protocol.\r\n     * @dev if the user prefers to only mint a new token, they should call the mintNextToken function.\r\n     * @param receiver user that will receive the newly minted token.\r\n     * @param data arbitrary caller-generated data that will be associated with this update.\r\n     * @return tokenId of the newly minted token.\r\n     */\r\n    function mint(address receiver, bytes memory data) public nonReentrant returns (uint256 tokenId) {\r\n        tokenId = mintNextToken(receiver);\r\n        emit UpdateToken(tokenId, msg.sender, data);\r\n    }\r\n\r\n    /**\r\n     * @notice Applies a reward-relevant update to an existing token.\r\n     * @param tokenId the existing tokenId that the update should be applied to.\r\n     * @param data arbitrary caller-generated data that will be associated with this update.\r\n     */\r\n    function updateToken(uint256 tokenId, bytes memory data) public nonReentrant {\r\n        emit UpdateToken(tokenId, msg.sender, data);\r\n    }\r\n\r\n    /**\r\n     * @notice Requests a redemption for any tokenId. This can be called by anyone.\r\n     * @dev If called by someone who doesn't own the token, they are effectively gifting their bond to the owner.\r\n     * @param tokenId the tokenId the redemption is for.\r\n     * @param cumulativeRedemptions the cumulative token addresses and amounts that this tokenId is eligible for\r\n     * at the current timestamp. cumulative redemptions that are too low should be considered to be valid.\r\n     * @return totalBond sum of finalFee and bond paid by the caller of this function.\r\n     */\r\n    function requestRedemption(uint256 tokenId, RedemptionAmount[] memory cumulativeRedemptions)\r\n        public\r\n        nonReentrant\r\n        returns (uint256 totalBond)\r\n    {\r\n        bytes32 redemptionId = getRedemptionId(tokenId, cumulativeRedemptions);\r\n        require(redemptions[redemptionId].expiryTime == 0, \"Redemption already exists\");\r\n        require(ownerOf(tokenId) != address(0), \"tokenId is invalid\");\r\n        // Note: it's important to put _some_ limit on the length of data passed in here. Otherwise, it is possible to\r\n        // create values that are so long that this transaction would fit within the block gas limit, but the dispute\r\n        // transaction would not.\r\n        require(cumulativeRedemptions.length <= 100, \"too many token transfers\");\r\n\r\n        uint256 expiryTime = getCurrentTime() + liveness;\r\n\r\n        totalBond = finalFee + bond;\r\n        bondToken.safeTransferFrom(msg.sender, address(this), totalBond);\r\n\r\n        redemptions[redemptionId] = Redemption({ finalFee: finalFee, expiryTime: expiryTime });\r\n\r\n        emit Requested(tokenId, redemptionId, cumulativeRedemptions, expiryTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a redemption request.\r\n     * @dev will cancel a request if the final fee changes or something causes the optimistic oracle proposal to fail.\r\n     * @param tokenId the tokenId the redemption is for.\r\n     * @param cumulativeRedemptions the cumulative redemptions that were provided in the original request.\r\n     */\r\n    function dispute(uint256 tokenId, RedemptionAmount[] memory cumulativeRedemptions) public nonReentrant {\r\n        bytes32 redemptionId = getRedemptionId(tokenId, cumulativeRedemptions);\r\n\r\n        // This automatically checks that redemptions[redemptionId] != 0.\r\n        // Check that it has not passed liveness.\r\n        Redemption storage redemption = redemptions[redemptionId];\r\n        uint256 currentTime = getCurrentTime();\r\n        require(currentTime < redemption.expiryTime, \"redemption expired or nonexistent\");\r\n\r\n        // Final fees don't match to those in the current store, which means the bond the initial caller provided was\r\n        // incorrect. Cancel the request to allow the requester to resubmit with the correct params.\r\n        // Note: we pull the store directly from the finder to avoid any issues with an outdated store causing the\r\n        // final fee to appear to be correct, but actually be outdated due to the OptimisticOracle pulling from a\r\n        // newer store deployment.\r\n        if (redemption.finalFee != _getStore().computeFinalFee(address(bondToken)).rawValue) {\r\n            _cancelRedemption(tokenId, redemptionId);\r\n            return;\r\n        } else {\r\n            uint256 totalBond = bond + redemption.finalFee;\r\n            bondToken.safeIncreaseAllowance(address(optimisticOracle), totalBond * 2);\r\n            bytes memory ancillaryData =\r\n                AncillaryData.appendKeyValueBytes32(customAncillaryData, \"redemptionId\", redemptionId);\r\n            uint32 requestTimestamp = uint32(redemption.expiryTime - liveness);\r\n            address proposer = ownerOf(tokenId);\r\n\r\n            try\r\n                optimisticOracle.requestAndProposePriceFor(\r\n                    identifier,\r\n                    requestTimestamp,\r\n                    ancillaryData,\r\n                    bondToken,\r\n                    0, // Reward = 0\r\n                    bond, // Bond (on top of the final fee) for the proposer and disputer.\r\n                    liveness,\r\n                    proposer,\r\n                    int256(1e18) // Canonical value representing \"True\"; i.e. the proposed redemption is valid.\r\n                )\r\n            returns (uint256) {} catch {\r\n                // There are various cases that can cause an OptimisticOracle proposal to fail. These are unlikely, but\r\n                // this is intended as a worst-case fallback to avoid undisputable requests.\r\n                // A few examples:\r\n                // 1. The token ceases to be approved.\r\n                // 2. The identifier ceases to be approved.\r\n                // 3. The request has been submitted before (same identifier, timestap, ancillary data, and requester).\r\n                //    This should be impossible for this contract.\r\n                // 4. The money bond + final fee is larger than approved or in the contract's balance. This should also\r\n                //    be impossible in this contract.\r\n                _cancelRedemption(tokenId, redemptionId);\r\n                bondToken.safeApprove(address(optimisticOracle), 0); // Reset allowance.\r\n                return;\r\n            }\r\n\r\n            SkinnyOptimisticOracleInterface.Request memory request =\r\n                SkinnyOptimisticOracleInterface.Request({\r\n                    proposer: proposer,\r\n                    disputer: address(0),\r\n                    currency: bondToken,\r\n                    settled: false,\r\n                    proposedPrice: int256(1e18),\r\n                    resolvedPrice: 0,\r\n                    expirationTime: currentTime + liveness,\r\n                    reward: 0,\r\n                    finalFee: redemption.finalFee,\r\n                    bond: bond,\r\n                    customLiveness: liveness\r\n                });\r\n\r\n            // Note: don't pull funds until here to avoid any transfers that aren't needed.\r\n            bondToken.safeTransferFrom(msg.sender, address(this), totalBond);\r\n\r\n            // Dispute the request that we just sent.\r\n            optimisticOracle.disputePriceFor(\r\n                identifier,\r\n                requestTimestamp,\r\n                ancillaryData,\r\n                request,\r\n                msg.sender,\r\n                address(this)\r\n            );\r\n\r\n            emit Disputed(tokenId, redemptionId, redemption.expiryTime);\r\n        }\r\n\r\n        delete redemptions[redemptionId];\r\n    }\r\n\r\n    /**\r\n     * @notice Redeem a redemption request that has passed liveness.\r\n     * @dev returns the bond that was paid with the initial proposal.\r\n     * @param tokenId the tokenId the redemption is for.\r\n     * @param cumulativeRedemptions the cumulative redemptions that were provided in the original request.\r\n     */\r\n    function redeem(uint256 tokenId, RedemptionAmount[] memory cumulativeRedemptions) public nonReentrant {\r\n        bytes32 redemptionId = getRedemptionId(tokenId, cumulativeRedemptions);\r\n\r\n        // Can only be redeemed by owner.\r\n        require(msg.sender == ownerOf(tokenId), \"must be called by token owner\");\r\n\r\n        // Check that the redemption is initialized and that it passed liveness.\r\n        require(\r\n            redemptions[redemptionId].expiryTime != 0 && getCurrentTime() >= redemptions[redemptionId].expiryTime,\r\n            \"unexpired or nonexistent\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < cumulativeRedemptions.length; i++) {\r\n            IERC20 token = cumulativeRedemptions[i].token;\r\n            uint256 currentRedemptionTotal = redeemedAmounts[tokenId][token];\r\n            uint256 proposedRedemptionTotal = cumulativeRedemptions[i].amount;\r\n\r\n            // Only pay if the cumulative amount specified in the request is larger than the amount paid out already.\r\n            // Note: disallow payments of the bond token even if it's in the approved request is passed to ensure\r\n            // rewards don't interfere with bond bookkeeping. This is checked here rather than at the initiation of the\r\n            // request to avoid the cost of looping over the array twice in the lifecycle.\r\n            if (proposedRedemptionTotal > currentRedemptionTotal && token != bondToken) {\r\n                uint256 amountToPay = proposedRedemptionTotal - currentRedemptionTotal;\r\n                redeemedAmounts[tokenId][token] = proposedRedemptionTotal;\r\n                token.safeTransfer(msg.sender, amountToPay);\r\n            }\r\n        }\r\n\r\n        // Return the bond to the owner.\r\n        bondToken.safeTransfer(msg.sender, bond + redemptions[redemptionId].finalFee);\r\n\r\n        emit Redeemed(tokenId, redemptionId, redemptions[redemptionId].expiryTime);\r\n\r\n        delete redemptions[redemptionId];\r\n    }\r\n\r\n    /**\r\n     * @notice Syncs external addresses and parameters into the contract.\r\n     * @dev These are stored rather than read on each run to avoid expensive external calls in the happy-path.\r\n     */\r\n    function sync() public nonReentrant {\r\n        _sync();\r\n    }\r\n\r\n    /**\r\n     * @notice gets the current time. Can be overridden for testing.\r\n     * @return current block timestamp.\r\n     */\r\n    function getCurrentTime() public view virtual returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Abstract function that is called to mint the next ERC721 tokenId.\r\n     * @param recipient the recipient of the newly minted token.\r\n     * @return index of the next minted token.\r\n     */\r\n    function mintNextToken(address recipient) public virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice Abstract function that is called to check the owner of the token.\r\n     * @dev this matches the ERC721 ownerOf interface.\r\n     * @param tokenId the tokenId to check the owner of.\r\n     * @return owner of a particular tokenId.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual returns (address);\r\n\r\n    /**\r\n     * @notice Generates a redemption id for the tokenId and the claim amounts.\r\n     * @param tokenId the tokenId that the claim is for.\r\n     * @param cumulativeRedemptions the cumulative redemptions that were provided in the request.\r\n     * @return redemption id. This is a hash of the tokenId and the cumulative redemptions.\r\n     */\r\n    function getRedemptionId(uint256 tokenId, RedemptionAmount[] memory cumulativeRedemptions)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(tokenId, cumulativeRedemptions));\r\n    }\r\n\r\n    /****************************************\r\n     *          INTERNAL FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    function _sync() internal {\r\n        store = _getStore();\r\n        finalFee = store.computeFinalFee(address(bondToken)).rawValue;\r\n        optimisticOracle = _getOptimisticOracle();\r\n    }\r\n\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n\r\n    function _getOptimisticOracle() internal view returns (SkinnyOptimisticOracleInterface) {\r\n        return\r\n            SkinnyOptimisticOracleInterface(finder.getImplementationAddress(OracleInterfaces.SkinnyOptimisticOracle));\r\n    }\r\n\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    function _getCollateralWhitelist() internal view returns (AddressWhitelistInterface) {\r\n        return AddressWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n    }\r\n\r\n    function _cancelRedemption(uint256 tokenId, bytes32 redemptionId) internal {\r\n        // On cancellation, perform a sync to ensure the contract has the most up-to-date addresses and params.\r\n        _sync();\r\n        Redemption storage redemption = redemptions[redemptionId];\r\n        bondToken.safeTransfer(ownerOf(tokenId), redemption.finalFee + bond);\r\n        emit Canceled(tokenId, redemptionId, redemption.expiryTime);\r\n        delete redemptions[redemptionId];\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/optimistic-rewarder/OptimisticRewarderCreator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../../common/implementation/Lockable.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"./OptimisticRewarder.sol\";\r\n\r\n/**\r\n * @notice The creator contract for optimistic rewarders. Using this contract is totally optional. It only aids in\r\n * creating a simpler deployment experience with a guarantee of repeatable verification and easier tracking through\r\n * events.\r\n */\r\ncontract OptimisticRewarderCreator is Lockable {\r\n    FinderInterface public finder;\r\n\r\n    event CreatedOptimisticRewarder(address indexed optimisticRewarder, bool includesToken);\r\n\r\n    constructor(FinderInterface _finder) {\r\n        finder = _finder;\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys an optimistic rewarder.\r\n     * @param _name name for the ERC721 token.\r\n     * @param _symbol symbol for the ERC721 token.\r\n     * @param _baseUri prefix to each ERC721 tokenId's name.\r\n     * @param _liveness liveness period between submission and verification of a reward.\r\n     * @param _bondToken ERC20 token that the bond is paid in.\r\n     * @param _bond size of the bond.\r\n     * @param _identifier identifier that should be passed to the optimistic oracle on dispute.\r\n     * @param _customAncillaryData custom ancillary data that should be sent to the optimistic oracle on dispute.\r\n     */\r\n    function createOptimisticRewarder(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _baseUri,\r\n        uint256 _liveness,\r\n        IERC20 _bondToken,\r\n        uint256 _bond,\r\n        bytes32 _identifier,\r\n        bytes memory _customAncillaryData\r\n    ) public nonReentrant returns (address) {\r\n        OptimisticRewarder optimisticRewarder =\r\n            new OptimisticRewarder(\r\n                _name,\r\n                _symbol,\r\n                _baseUri,\r\n                _liveness,\r\n                _bondToken,\r\n                _bond,\r\n                _identifier,\r\n                _customAncillaryData,\r\n                finder\r\n            );\r\n        emit CreatedOptimisticRewarder(address(optimisticRewarder), true);\r\n        return address(optimisticRewarder);\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys an optimistic rewarder with an external ERC721 token.\r\n     * @param _token external ERC721 token for the rewarder to base redemptions on.\r\n     * @param _liveness liveness period between submission and verification of a reward.\r\n     * @param _bondToken ERC20 token that the bond is paid in.\r\n     * @param _bond size of the bond.\r\n     * @param _identifier identifier that should be passed to the optimistic oracle on dispute.\r\n     * @param _customAncillaryData custom ancillary data that should be sent to the optimistic oracle on dispute.\r\n     */\r\n    function createOptimisticRewarderNoToken(\r\n        OptimisticRewarderToken _token,\r\n        uint256 _liveness,\r\n        IERC20 _bondToken,\r\n        uint256 _bond,\r\n        bytes32 _identifier,\r\n        bytes memory _customAncillaryData\r\n    ) public nonReentrant returns (address) {\r\n        OptimisticRewarderNoToken optimisticRewarder =\r\n            new OptimisticRewarderNoToken(\r\n                _token,\r\n                _liveness,\r\n                _bondToken,\r\n                _bond,\r\n                _identifier,\r\n                _customAncillaryData,\r\n                finder\r\n            );\r\n        emit CreatedOptimisticRewarder(address(optimisticRewarder), false);\r\n        return address(optimisticRewarder);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/optimistic-rewarder/OptimisticRewarderToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\n\r\ncontract OptimisticRewarderToken is ERC721 {\r\n    string public baseUri;\r\n    uint256 public nextTokenId;\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _name name for the ERC721 token.\r\n     * @param _symbol symbol for the ERC721 token.\r\n     * @param _baseUri prefix to each ERC721 tokenId's name.\r\n     */\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _baseUri\r\n    ) ERC721(_name, _symbol) {\r\n        nextTokenId = 0;\r\n        baseUri = _baseUri;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to mint the next ERC721 tokenId.\r\n     * @param recipient the recipient of the newly minted token.\r\n     */\r\n    function mintNextToken(address recipient) public virtual returns (uint256 tokenId) {\r\n        tokenId = nextTokenId++;\r\n        _safeMint(recipient, tokenId);\r\n    }\r\n\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return baseUri;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/optimistic-rewarder/OptimisticStaker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/MultiCaller.sol\";\r\nimport \"./OptimisticRewarderBase.sol\";\r\n\r\n/**\r\n * @notice An example use case of the OptimisticRewarder in use by a contract that allows users to stake an ERC20 to\r\n * earn rewards.\r\n */\r\ncontract OptimisticStaker is Lockable, MultiCaller {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Optimistic rewarder contract used to pay out user rewards.\r\n    OptimisticRewarderBase public optimisticRewarder;\r\n\r\n    // Staked ERC20 token.\r\n    IERC20 public stakedToken;\r\n\r\n    // Balances by tokenId.\r\n    mapping(uint256 => uint256) public balances;\r\n\r\n    event Deposit(uint256 indexed tokenId, uint256 amount);\r\n    event Withdraw(uint256 indexed tokenId, uint256 amount);\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _optimisticRewarder Optimistic rewarder contract used to pay out user rewards.\r\n     * @param _stakedToken staked ERC20 token.\r\n     */\r\n    constructor(OptimisticRewarderBase _optimisticRewarder, IERC20 _stakedToken) {\r\n        optimisticRewarder = _optimisticRewarder;\r\n        stakedToken = _stakedToken;\r\n    }\r\n\r\n    modifier onlyTokenOwner(uint256 tokenId) {\r\n        require(optimisticRewarder.ownerOf(tokenId) == msg.sender, \"caller != token owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit the staked token into the contract and mint a fresh token to manage the position.\r\n     * @param amount the amount of the ERC20 to deposit.\r\n     * @return tokenId the token id for the freshly minted token.\r\n     */\r\n    function depositNew(uint256 amount) public nonReentrant returns (uint256 tokenId) {\r\n        tokenId = optimisticRewarder.mint(msg.sender, msg.data);\r\n        _depositFor(tokenId, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit the staked token into the contract.\r\n     * @param tokenId the tokenId that will own this liquidity. User must be the owner of this tokenId.\r\n     * @param amount the amount of the ERC20 to deposit.\r\n     */\r\n    function deposit(uint256 tokenId, uint256 amount) public nonReentrant onlyTokenOwner(tokenId) {\r\n        _depositFor(tokenId, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit staked tokens on behalf of a tokenId that the user may not control.\r\n     * @param tokenId the tokenId that will own this liquidity.\r\n     * @param amount the amount of the ERC20 to deposit.\r\n     */\r\n    function depositFor(uint256 tokenId, uint256 amount) public nonReentrant {\r\n        _depositFor(tokenId, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw the staked tokens.\r\n     * @param tokenId the tokenId that owns this liquidity. User must own this tokenId.\r\n     * @param amount the amount of the ERC20 to withdraw.\r\n     */\r\n    function withdraw(uint256 tokenId, uint256 amount) public nonReentrant onlyTokenOwner(tokenId) {\r\n        balances[tokenId] -= amount;\r\n        stakedToken.safeTransfer(msg.sender, amount);\r\n        optimisticRewarder.updateToken(tokenId, msg.data);\r\n        emit Withdraw(tokenId, amount);\r\n    }\r\n\r\n    function _depositFor(uint256 tokenId, uint256 amount) internal {\r\n        balances[tokenId] += amount;\r\n        stakedToken.safeTransferFrom(msg.sender, address(this), amount);\r\n        optimisticRewarder.updateToken(tokenId, msg.data);\r\n        emit Deposit(tokenId, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/optimistic-rewarder/test/OptimisticRewarderTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../OptimisticRewarder.sol\";\r\nimport \"../../../common/implementation/Testable.sol\";\r\n\r\n// Test contract to add controllable timing to the OptimisticRewarder.\r\ncontract OptimisticRewarderTest is OptimisticRewarder, Testable {\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _baseUri,\r\n        uint256 _liveness,\r\n        IERC20 _bondToken,\r\n        uint256 _bond,\r\n        bytes32 _identifier,\r\n        bytes memory _customAncillaryData,\r\n        FinderInterface _finder,\r\n        address _timerAddress\r\n    )\r\n        Testable(_timerAddress)\r\n        OptimisticRewarder(\r\n            _name,\r\n            _symbol,\r\n            _baseUri,\r\n            _liveness,\r\n            _bondToken,\r\n            _bond,\r\n            _identifier,\r\n            _customAncillaryData,\r\n            _finder\r\n        )\r\n    {}\r\n\r\n    function getCurrentTime() public view override(OptimisticRewarderBase, Testable) returns (uint256) {\r\n        return Testable.getCurrentTime();\r\n    }\r\n}\r\n\r\n// Test contract to add controllable timing to the OptimisticRewarderNoToken.\r\ncontract OptimisticRewarderNoTokenTest is OptimisticRewarderNoToken, Testable {\r\n    constructor(\r\n        OptimisticRewarderToken _token,\r\n        uint256 _liveness,\r\n        IERC20 _bondToken,\r\n        uint256 _bond,\r\n        bytes32 _identifier,\r\n        bytes memory _customAncillaryData,\r\n        FinderInterface _finder,\r\n        address _timerAddress\r\n    )\r\n        Testable(_timerAddress)\r\n        OptimisticRewarderNoToken(_token, _liveness, _bondToken, _bond, _identifier, _customAncillaryData, _finder)\r\n    {}\r\n\r\n    function getCurrentTime() public view override(OptimisticRewarderBase, Testable) returns (uint256) {\r\n        return Testable.getCurrentTime();\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/perpetual-multiparty/ConfigStore.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"./ConfigStoreInterface.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n/**\r\n * @notice ConfigStore stores configuration settings for a perpetual contract and provides an interface for it\r\n * to query settings such as reward rates, proposal bond sizes, etc. The configuration settings can be upgraded\r\n * by a privileged account and the upgraded changes are timelocked.\r\n */\r\ncontract ConfigStore is ConfigStoreInterface, Testable, Lockable, Ownable {\r\n    using SafeMath for uint256;\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    /****************************************\r\n     *        STORE DATA STRUCTURES         *\r\n     ****************************************/\r\n\r\n    // Make currentConfig private to force user to call getCurrentConfig, which returns the pendingConfig\r\n    // if its liveness has expired.\r\n    ConfigStoreInterface.ConfigSettings private currentConfig;\r\n\r\n    // Beginning on `pendingPassedTimestamp`, the `pendingConfig` can be published as the current config.\r\n    ConfigStoreInterface.ConfigSettings public pendingConfig;\r\n    uint256 public pendingPassedTimestamp;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event ProposedNewConfigSettings(\r\n        address indexed proposer,\r\n        uint256 rewardRatePerSecond,\r\n        uint256 proposerBondPercentage,\r\n        uint256 timelockLiveness,\r\n        int256 maxFundingRate,\r\n        int256 minFundingRate,\r\n        uint256 proposalTimePastLimit,\r\n        uint256 proposalPassedTimestamp\r\n    );\r\n    event ChangedConfigSettings(\r\n        uint256 rewardRatePerSecond,\r\n        uint256 proposerBondPercentage,\r\n        uint256 timelockLiveness,\r\n        int256 maxFundingRate,\r\n        int256 minFundingRate,\r\n        uint256 proposalTimePastLimit\r\n    );\r\n\r\n    /****************************************\r\n     *                MODIFIERS             *\r\n     ****************************************/\r\n\r\n    // Update config settings if possible.\r\n    modifier updateConfig() {\r\n        _updateConfig();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Construct the Config Store. An initial configuration is provided and set on construction.\r\n     * @param _initialConfig Configuration settings to initialize `currentConfig` with.\r\n     * @param _timerAddress Address of testable Timer contract.\r\n     */\r\n    constructor(ConfigSettings memory _initialConfig, address _timerAddress) Testable(_timerAddress) {\r\n        _validateConfig(_initialConfig);\r\n        currentConfig = _initialConfig;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns current config or pending config if pending liveness has expired.\r\n     * @return ConfigSettings config settings that calling financial contract should view as \"live\".\r\n     */\r\n    function updateAndGetCurrentConfig()\r\n        external\r\n        override\r\n        updateConfig()\r\n        nonReentrant()\r\n        returns (ConfigStoreInterface.ConfigSettings memory)\r\n    {\r\n        return currentConfig;\r\n    }\r\n\r\n    /**\r\n     * @notice Propose new configuration settings. New settings go into effect after a liveness period passes.\r\n     * @param newConfig Configuration settings to publish after `currentConfig.timelockLiveness` passes from block.timestamp.\r\n     * @dev Callable only by owner. Calling this while there is already a pending proposal will overwrite the pending proposal.\r\n     */\r\n    function proposeNewConfig(ConfigSettings memory newConfig) external onlyOwner() nonReentrant() updateConfig() {\r\n        _validateConfig(newConfig);\r\n\r\n        // Warning: This overwrites a pending proposal!\r\n        pendingConfig = newConfig;\r\n\r\n        // Use current config's liveness period to timelock this proposal.\r\n        pendingPassedTimestamp = getCurrentTime().add(currentConfig.timelockLiveness);\r\n\r\n        emit ProposedNewConfigSettings(\r\n            msg.sender,\r\n            newConfig.rewardRatePerSecond.rawValue,\r\n            newConfig.proposerBondPercentage.rawValue,\r\n            newConfig.timelockLiveness,\r\n            newConfig.maxFundingRate.rawValue,\r\n            newConfig.minFundingRate.rawValue,\r\n            newConfig.proposalTimePastLimit,\r\n            pendingPassedTimestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Publish any pending configuration settings if there is a pending proposal that has passed liveness.\r\n     */\r\n    function publishPendingConfig() external nonReentrant() updateConfig() {}\r\n\r\n    /****************************************\r\n     *         INTERNAL FUNCTIONS           *\r\n     ****************************************/\r\n\r\n    // Check if pending proposal can overwrite the current config.\r\n    function _updateConfig() internal {\r\n        // If liveness has passed, publish proposed configuration settings.\r\n        if (_pendingProposalPassed()) {\r\n            currentConfig = pendingConfig;\r\n\r\n            _deletePendingConfig();\r\n\r\n            emit ChangedConfigSettings(\r\n                currentConfig.rewardRatePerSecond.rawValue,\r\n                currentConfig.proposerBondPercentage.rawValue,\r\n                currentConfig.timelockLiveness,\r\n                currentConfig.maxFundingRate.rawValue,\r\n                currentConfig.minFundingRate.rawValue,\r\n                currentConfig.proposalTimePastLimit\r\n            );\r\n        }\r\n    }\r\n\r\n    function _deletePendingConfig() internal {\r\n        delete pendingConfig;\r\n        pendingPassedTimestamp = 0;\r\n    }\r\n\r\n    function _pendingProposalPassed() internal view returns (bool) {\r\n        return (pendingPassedTimestamp != 0 && pendingPassedTimestamp <= getCurrentTime());\r\n    }\r\n\r\n    // Use this method to constrain values with which you can set ConfigSettings.\r\n    function _validateConfig(ConfigStoreInterface.ConfigSettings memory config) internal pure {\r\n        // We don't set limits on proposal timestamps because there are already natural limits:\r\n        // - Future: price requests to the OptimisticOracle must be in the past---we can't add further constraints.\r\n        // - Past: proposal times must always be after the last update time, and  a reasonable past limit would be 30\r\n        //   mins, meaning that no proposal timestamp can be more than 30 minutes behind the current time.\r\n\r\n        // Make sure timelockLiveness is not too long, otherwise contract might not be able to fix itself\r\n        // before a vulnerability drains its collateral.\r\n        require(config.timelockLiveness <= 7 days && config.timelockLiveness >= 1 days, \"Invalid timelockLiveness\");\r\n\r\n        // The reward rate should be modified as needed to incentivize honest proposers appropriately.\r\n        // Additionally, the rate should be less than 100% a year => 100% / 360 days / 24 hours / 60 mins / 60 secs\r\n        // = 0.0000033\r\n        FixedPoint.Unsigned memory maxRewardRatePerSecond = FixedPoint.fromUnscaledUint(33).div(1e7);\r\n        require(config.rewardRatePerSecond.isLessThan(maxRewardRatePerSecond), \"Invalid rewardRatePerSecond\");\r\n\r\n        // We don't set a limit on the proposer bond because it is a defense against dishonest proposers. If a proposer\r\n        // were to successfully propose a very high or low funding rate, then their PfC would be very high. The proposer\r\n        // could theoretically keep their \"evil\" funding rate alive indefinitely by continuously disputing honest\r\n        // proposers, so we would want to be able to set the proposal bond (equal to the dispute bond) higher than their\r\n        // PfC for each proposal liveness window. The downside of not limiting this is that the config store owner\r\n        // can set it arbitrarily high and preclude a new funding rate from ever coming in. We suggest setting the\r\n        // proposal bond based on the configuration's funding rate range like in this discussion:\r\n        // https://github.com/UMAprotocol/protocol/issues/2039#issuecomment-719734383\r\n\r\n        // We also don't set a limit on the funding rate max/min because we might need to allow very high magnitude\r\n        // funding rates in extraordinarily volatile market situations. Note, that even though we do not bound\r\n        // the max/min, we still recommend that the deployer of this contract set the funding rate max/min values\r\n        // to bound the PfC of a dishonest proposer. A reasonable range might be the equivalent of [+200%/year, -200%/year].\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/perpetual-multiparty/ConfigStoreInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\ninterface ConfigStoreInterface {\r\n    // All of the configuration settings available for querying by a perpetual.\r\n    struct ConfigSettings {\r\n        // Liveness period (in seconds) for an update to currentConfig to become official.\r\n        uint256 timelockLiveness;\r\n        // Reward rate paid to successful proposers. Percentage of 1 E.g., .1 is 10%.\r\n        FixedPoint.Unsigned rewardRatePerSecond;\r\n        // Bond % (of given contract's PfC) that must be staked by proposers. Percentage of 1, e.g. 0.0005 is 0.05%.\r\n        FixedPoint.Unsigned proposerBondPercentage;\r\n        // Maximum funding rate % per second that can be proposed.\r\n        FixedPoint.Signed maxFundingRate;\r\n        // Minimum funding rate % per second that can be proposed.\r\n        FixedPoint.Signed minFundingRate;\r\n        // Funding rate proposal timestamp cannot be more than this amount of seconds in the past from the latest\r\n        // update time.\r\n        uint256 proposalTimePastLimit;\r\n    }\r\n\r\n    function updateAndGetCurrentConfig() external returns (ConfigSettings memory);\r\n}\r\n"
    },
    "contracts/financial-templates/perpetual-multiparty/Perpetual.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./PerpetualLiquidatable.sol\";\r\n\r\n/**\r\n * @title Perpetual Multiparty Contract.\r\n * @notice Convenient wrapper for Liquidatable.\r\n */\r\ncontract Perpetual is PerpetualLiquidatable {\r\n    /**\r\n     * @notice Constructs the Perpetual contract.\r\n     * @param params struct to define input parameters for construction of Liquidatable. Some params\r\n     * are fed directly into the PositionManager's constructor within the inheritance tree.\r\n     */\r\n    constructor(ConstructorParams memory params)\r\n        PerpetualLiquidatable(params)\r\n    // Note: since there is no logic here, there is no need to add a re-entrancy guard.\r\n    {\r\n\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/perpetual-multiparty/PerpetualCreator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../data-verification-mechanism/implementation/ContractCreator.sol\";\r\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\r\nimport \"../../common/interfaces/IERC20Standard.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/implementation/AddressWhitelist.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../common/TokenFactory.sol\";\r\nimport \"../common/SyntheticToken.sol\";\r\nimport \"./PerpetualLib.sol\";\r\nimport \"./ConfigStore.sol\";\r\n\r\n/**\r\n * @title Perpetual Contract creator.\r\n * @notice Factory contract to create and register new instances of perpetual contracts.\r\n * Responsible for constraining the parameters used to construct a new perpetual. This creator contains a number of constraints\r\n * that are applied to newly created contract. These constraints can evolve over time and are\r\n * initially constrained to conservative values in this first iteration. Technically there is nothing in the\r\n * Perpetual contract requiring these constraints. However, because `createPerpetual()` is intended\r\n * to be the only way to create valid financial contracts that are registered with the DVM (via _registerContract),\r\n  we can enforce deployment configurations here.\r\n */\r\ncontract PerpetualCreator is ContractCreator, Testable, Lockable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    /****************************************\r\n     *     PERP CREATOR DATA STRUCTURES      *\r\n     ****************************************/\r\n\r\n    // Immutable params for perpetual contract.\r\n    struct Params {\r\n        address collateralAddress;\r\n        bytes32 priceFeedIdentifier;\r\n        bytes32 fundingRateIdentifier;\r\n        string syntheticName;\r\n        string syntheticSymbol;\r\n        FixedPoint.Unsigned collateralRequirement;\r\n        FixedPoint.Unsigned disputeBondPercentage;\r\n        FixedPoint.Unsigned sponsorDisputeRewardPercentage;\r\n        FixedPoint.Unsigned disputerDisputeRewardPercentage;\r\n        FixedPoint.Unsigned minSponsorTokens;\r\n        FixedPoint.Unsigned tokenScaling;\r\n        uint256 withdrawalLiveness;\r\n        uint256 liquidationLiveness;\r\n    }\r\n    // Address of TokenFactory used to create a new synthetic token.\r\n    address public tokenFactoryAddress;\r\n\r\n    event CreatedPerpetual(address indexed perpetualAddress, address indexed deployerAddress);\r\n    event CreatedConfigStore(address indexed configStoreAddress, address indexed ownerAddress);\r\n\r\n    /**\r\n     * @notice Constructs the Perpetual contract.\r\n     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\r\n     * @param _tokenFactoryAddress ERC20 token factory used to deploy synthetic token instances.\r\n     * @param _timerAddress Contract that stores the current time in a testing environment.\r\n     */\r\n    constructor(\r\n        address _finderAddress,\r\n        address _tokenFactoryAddress,\r\n        address _timerAddress\r\n    ) ContractCreator(_finderAddress) Testable(_timerAddress) nonReentrant() {\r\n        tokenFactoryAddress = _tokenFactoryAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Creates an instance of perpetual and registers it within the registry.\r\n     * @param params is a `ConstructorParams` object from Perpetual.\r\n     * @return address of the deployed contract.\r\n     */\r\n    function createPerpetual(Params memory params, ConfigStore.ConfigSettings memory configSettings)\r\n        public\r\n        nonReentrant()\r\n        returns (address)\r\n    {\r\n        require(bytes(params.syntheticName).length != 0, \"Missing synthetic name\");\r\n        require(bytes(params.syntheticSymbol).length != 0, \"Missing synthetic symbol\");\r\n\r\n        // Create new config settings store for this contract and reset ownership to the deployer.\r\n        ConfigStore configStore = new ConfigStore(configSettings, timerAddress);\r\n        configStore.transferOwnership(msg.sender);\r\n        emit CreatedConfigStore(address(configStore), configStore.owner());\r\n\r\n        // Create a new synthetic token using the params.\r\n        TokenFactory tf = TokenFactory(tokenFactoryAddress);\r\n\r\n        // If the collateral token does not have a `decimals()` method,\r\n        // then a default precision of 18 will be applied to the newly created synthetic token.\r\n        uint8 syntheticDecimals = _getSyntheticDecimals(params.collateralAddress);\r\n        ExpandedIERC20 tokenCurrency = tf.createToken(params.syntheticName, params.syntheticSymbol, syntheticDecimals);\r\n        address derivative = PerpetualLib.deploy(_convertParams(params, tokenCurrency, address(configStore)));\r\n\r\n        // Give permissions to new derivative contract and then hand over ownership.\r\n        tokenCurrency.addMinter(derivative);\r\n        tokenCurrency.addBurner(derivative);\r\n        tokenCurrency.resetOwner(derivative);\r\n\r\n        _registerContract(new address[](0), derivative);\r\n\r\n        emit CreatedPerpetual(derivative, msg.sender);\r\n\r\n        return derivative;\r\n    }\r\n\r\n    /****************************************\r\n     *          PRIVATE FUNCTIONS           *\r\n     ****************************************/\r\n\r\n    // Converts createPerpetual params to Perpetual constructor params.\r\n    function _convertParams(\r\n        Params memory params,\r\n        ExpandedIERC20 newTokenCurrency,\r\n        address configStore\r\n    ) private view returns (Perpetual.ConstructorParams memory constructorParams) {\r\n        // Known from creator deployment.\r\n        constructorParams.finderAddress = finderAddress;\r\n        constructorParams.timerAddress = timerAddress;\r\n\r\n        // Enforce configuration constraints.\r\n        require(params.withdrawalLiveness != 0, \"Withdrawal liveness cannot be 0\");\r\n        require(params.liquidationLiveness != 0, \"Liquidation liveness cannot be 0\");\r\n        _requireWhitelistedCollateral(params.collateralAddress);\r\n\r\n        // We don't want perpetual deployers to be able to intentionally or unintentionally set\r\n        // liveness periods that could induce arithmetic overflow, but we also don't want\r\n        // to be opinionated about what livenesses are \"correct\", so we will somewhat\r\n        // arbitrarily set the liveness upper bound to 100 years (5200 weeks). In practice, liveness\r\n        // periods even greater than a few days would make the perpetual unusable for most users.\r\n        require(params.withdrawalLiveness < 5200 weeks, \"Withdrawal liveness too large\");\r\n        require(params.liquidationLiveness < 5200 weeks, \"Liquidation liveness too large\");\r\n\r\n        // To avoid precision loss or overflows, prevent the token scaling from being too large or too small.\r\n        FixedPoint.Unsigned memory minScaling = FixedPoint.Unsigned(1e8); // 1e-10\r\n        FixedPoint.Unsigned memory maxScaling = FixedPoint.Unsigned(1e28); // 1e10\r\n        require(\r\n            params.tokenScaling.isGreaterThan(minScaling) && params.tokenScaling.isLessThan(maxScaling),\r\n            \"Invalid tokenScaling\"\r\n        );\r\n\r\n        // Input from function call.\r\n        constructorParams.configStoreAddress = configStore;\r\n        constructorParams.tokenAddress = address(newTokenCurrency);\r\n        constructorParams.collateralAddress = params.collateralAddress;\r\n        constructorParams.priceFeedIdentifier = params.priceFeedIdentifier;\r\n        constructorParams.fundingRateIdentifier = params.fundingRateIdentifier;\r\n        constructorParams.collateralRequirement = params.collateralRequirement;\r\n        constructorParams.disputeBondPercentage = params.disputeBondPercentage;\r\n        constructorParams.sponsorDisputeRewardPercentage = params.sponsorDisputeRewardPercentage;\r\n        constructorParams.disputerDisputeRewardPercentage = params.disputerDisputeRewardPercentage;\r\n        constructorParams.minSponsorTokens = params.minSponsorTokens;\r\n        constructorParams.withdrawalLiveness = params.withdrawalLiveness;\r\n        constructorParams.liquidationLiveness = params.liquidationLiveness;\r\n        constructorParams.tokenScaling = params.tokenScaling;\r\n    }\r\n\r\n    // IERC20Standard.decimals() will revert if the collateral contract has not implemented the decimals() method,\r\n    // which is possible since the method is only an OPTIONAL method in the ERC20 standard:\r\n    // https://eips.ethereum.org/EIPS/eip-20#methods.\r\n    function _getSyntheticDecimals(address _collateralAddress) public view returns (uint8 decimals) {\r\n        try IERC20Standard(_collateralAddress).decimals() returns (uint8 _decimals) {\r\n            return _decimals;\r\n        } catch {\r\n            return 18;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/perpetual-multiparty/PerpetualLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Perpetual.sol\";\r\n\r\n/**\r\n * @title Provides convenient Perpetual Multi Party contract utilities.\r\n * @dev Using this library to deploy Perpetuals allows calling contracts to avoid importing the full bytecode.\r\n */\r\nlibrary PerpetualLib {\r\n    /**\r\n     * @notice Returns address of new Perpetual deployed with given `params` configuration.\r\n     * @dev Caller will need to register new Perpetual with the Registry to begin requesting prices. Caller is also\r\n     * responsible for enforcing constraints on `params`.\r\n     * @param params is a `ConstructorParams` object from Perpetual.\r\n     * @return address of the deployed Perpetual contract\r\n     */\r\n    function deploy(Perpetual.ConstructorParams memory params) public returns (address) {\r\n        Perpetual derivative = new Perpetual(params);\r\n        return address(derivative);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/perpetual-multiparty/PerpetualLiquidatable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"./PerpetualPositionManager.sol\";\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n/**\r\n * @title PerpetualLiquidatable\r\n * @notice Adds logic to a position-managing contract that enables callers to liquidate an undercollateralized position.\r\n * @dev The liquidation has a liveness period before expiring successfully, during which someone can \"dispute\" the\r\n * liquidation, which sends a price request to the relevant Oracle to settle the final collateralization ratio based on\r\n * a DVM price. The contract enforces dispute rewards in order to incentivize disputers to correctly dispute false\r\n * liquidations and compensate position sponsors who had their position incorrectly liquidated. Importantly, a\r\n * prospective disputer must deposit a dispute bond that they can lose in the case of an unsuccessful dispute.\r\n * NOTE: this contract does _not_ work with ERC777 collateral currencies or any others that call into the receiver on\r\n * transfer(). Using an ERC777 token would allow a user to maliciously grief other participants (while also losing\r\n * money themselves).\r\n */\r\ncontract PerpetualLiquidatable is PerpetualPositionManager {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using SafeERC20 for ExpandedIERC20;\r\n\r\n    /****************************************\r\n     *     LIQUIDATION DATA STRUCTURES      *\r\n     ****************************************/\r\n\r\n    // Because of the check in withdrawable(), the order of these enum values should not change.\r\n    enum Status { Uninitialized, NotDisputed, Disputed, DisputeSucceeded, DisputeFailed }\r\n\r\n    struct LiquidationData {\r\n        // Following variables set upon creation of liquidation:\r\n        address sponsor; // Address of the liquidated position's sponsor\r\n        address liquidator; // Address who created this liquidation\r\n        Status state; // Liquidated (and expired or not), Pending a Dispute, or Dispute has resolved\r\n        uint256 liquidationTime; // Time when liquidation is initiated, needed to get price from Oracle\r\n        // Following variables determined by the position that is being liquidated:\r\n        FixedPoint.Unsigned tokensOutstanding; // Synthetic tokens required to be burned by liquidator to initiate dispute\r\n        FixedPoint.Unsigned lockedCollateral; // Collateral locked by contract and released upon expiry or post-dispute\r\n        // Amount of collateral being liquidated, which could be different from\r\n        // lockedCollateral if there were pending withdrawals at the time of liquidation\r\n        FixedPoint.Unsigned liquidatedCollateral;\r\n        // Unit value (starts at 1) that is used to track the fees per unit of collateral over the course of the liquidation.\r\n        FixedPoint.Unsigned rawUnitCollateral;\r\n        // Following variable set upon initiation of a dispute:\r\n        address disputer; // Person who is disputing a liquidation\r\n        // Following variable set upon a resolution of a dispute:\r\n        FixedPoint.Unsigned settlementPrice; // Final price as determined by an Oracle following a dispute\r\n        FixedPoint.Unsigned finalFee;\r\n    }\r\n\r\n    // Define the contract's constructor parameters as a struct to enable more variables to be specified.\r\n    // This is required to enable more params, over and above Solidity's limits.\r\n    struct ConstructorParams {\r\n        // Params for PerpetualPositionManager only.\r\n        uint256 withdrawalLiveness;\r\n        address configStoreAddress;\r\n        address collateralAddress;\r\n        address tokenAddress;\r\n        address finderAddress;\r\n        address timerAddress;\r\n        bytes32 priceFeedIdentifier;\r\n        bytes32 fundingRateIdentifier;\r\n        FixedPoint.Unsigned minSponsorTokens;\r\n        FixedPoint.Unsigned tokenScaling;\r\n        // Params specifically for PerpetualLiquidatable.\r\n        uint256 liquidationLiveness;\r\n        FixedPoint.Unsigned collateralRequirement;\r\n        FixedPoint.Unsigned disputeBondPercentage;\r\n        FixedPoint.Unsigned sponsorDisputeRewardPercentage;\r\n        FixedPoint.Unsigned disputerDisputeRewardPercentage;\r\n    }\r\n\r\n    // This struct is used in the `withdrawLiquidation` method that disperses liquidation and dispute rewards.\r\n    // `payToX` stores the total collateral to withdraw from the contract to pay X. This value might differ\r\n    // from `paidToX` due to precision loss between accounting for the `rawCollateral` versus the\r\n    // fee-adjusted collateral. These variables are stored within a struct to avoid the stack too deep error.\r\n    struct RewardsData {\r\n        FixedPoint.Unsigned payToSponsor;\r\n        FixedPoint.Unsigned payToLiquidator;\r\n        FixedPoint.Unsigned payToDisputer;\r\n        FixedPoint.Unsigned paidToSponsor;\r\n        FixedPoint.Unsigned paidToLiquidator;\r\n        FixedPoint.Unsigned paidToDisputer;\r\n    }\r\n\r\n    // Liquidations are unique by ID per sponsor\r\n    mapping(address => LiquidationData[]) public liquidations;\r\n\r\n    // Total collateral in liquidation.\r\n    FixedPoint.Unsigned public rawLiquidationCollateral;\r\n\r\n    // Immutable contract parameters:\r\n    // Amount of time for pending liquidation before expiry.\r\n    // !!Note: The lower the liquidation liveness value, the more risk incurred by sponsors.\r\n    //       Extremely low liveness values increase the chance that opportunistic invalid liquidations\r\n    //       expire without dispute, thereby decreasing the usability for sponsors and increasing the risk\r\n    //       for the contract as a whole. An insolvent contract is extremely risky for any sponsor or synthetic\r\n    //       token holder for the contract.\r\n    uint256 public liquidationLiveness;\r\n    // Required collateral:TRV ratio for a position to be considered sufficiently collateralized.\r\n    FixedPoint.Unsigned public collateralRequirement;\r\n    // Percent of a Liquidation/Position's lockedCollateral to be deposited by a potential disputer\r\n    // Represented as a multiplier, for example 1.5e18 = \"150%\" and 0.05e18 = \"5%\"\r\n    FixedPoint.Unsigned public disputeBondPercentage;\r\n    // Percent of oraclePrice paid to sponsor in the Disputed state (i.e. following a successful dispute)\r\n    // Represented as a multiplier, see above.\r\n    FixedPoint.Unsigned public sponsorDisputeRewardPercentage;\r\n    // Percent of oraclePrice paid to disputer in the Disputed state (i.e. following a successful dispute)\r\n    // Represented as a multiplier, see above.\r\n    FixedPoint.Unsigned public disputerDisputeRewardPercentage;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event LiquidationCreated(\r\n        address indexed sponsor,\r\n        address indexed liquidator,\r\n        uint256 indexed liquidationId,\r\n        uint256 tokensOutstanding,\r\n        uint256 lockedCollateral,\r\n        uint256 liquidatedCollateral,\r\n        uint256 liquidationTime\r\n    );\r\n    event LiquidationDisputed(\r\n        address indexed sponsor,\r\n        address indexed liquidator,\r\n        address indexed disputer,\r\n        uint256 liquidationId,\r\n        uint256 disputeBondAmount\r\n    );\r\n    event DisputeSettled(\r\n        address indexed caller,\r\n        address indexed sponsor,\r\n        address indexed liquidator,\r\n        address disputer,\r\n        uint256 liquidationId,\r\n        bool disputeSucceeded\r\n    );\r\n    event LiquidationWithdrawn(\r\n        address indexed caller,\r\n        uint256 paidToLiquidator,\r\n        uint256 paidToDisputer,\r\n        uint256 paidToSponsor,\r\n        Status indexed liquidationStatus,\r\n        uint256 settlementPrice\r\n    );\r\n\r\n    /****************************************\r\n     *              MODIFIERS               *\r\n     ****************************************/\r\n\r\n    modifier disputable(uint256 liquidationId, address sponsor) {\r\n        _disputable(liquidationId, sponsor);\r\n        _;\r\n    }\r\n\r\n    modifier withdrawable(uint256 liquidationId, address sponsor) {\r\n        _withdrawable(liquidationId, sponsor);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructs the liquidatable contract.\r\n     * @param params struct to define input parameters for construction of Liquidatable. Some params\r\n     * are fed directly into the PositionManager's constructor within the inheritance tree.\r\n     */\r\n    constructor(ConstructorParams memory params)\r\n        PerpetualPositionManager(\r\n            params.withdrawalLiveness,\r\n            params.collateralAddress,\r\n            params.tokenAddress,\r\n            params.finderAddress,\r\n            params.priceFeedIdentifier,\r\n            params.fundingRateIdentifier,\r\n            params.minSponsorTokens,\r\n            params.configStoreAddress,\r\n            params.tokenScaling,\r\n            params.timerAddress\r\n        )\r\n    {\r\n        require(params.collateralRequirement.isGreaterThan(1));\r\n        require(params.sponsorDisputeRewardPercentage.add(params.disputerDisputeRewardPercentage).isLessThan(1));\r\n\r\n        // Set liquidatable specific variables.\r\n        liquidationLiveness = params.liquidationLiveness;\r\n        collateralRequirement = params.collateralRequirement;\r\n        disputeBondPercentage = params.disputeBondPercentage;\r\n        sponsorDisputeRewardPercentage = params.sponsorDisputeRewardPercentage;\r\n        disputerDisputeRewardPercentage = params.disputerDisputeRewardPercentage;\r\n    }\r\n\r\n    /****************************************\r\n     *        LIQUIDATION FUNCTIONS         *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Liquidates the sponsor's position if the caller has enough\r\n     * synthetic tokens to retire the position's outstanding tokens. Liquidations above\r\n     * a minimum size also reset an ongoing \"slow withdrawal\"'s liveness.\r\n     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor. This contract must be\r\n     * approved to spend at least `tokensLiquidated` of `tokenCurrency` and at least `finalFeeBond` of `collateralCurrency`.\r\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\r\n     * @param sponsor address of the sponsor to liquidate.\r\n     * @param minCollateralPerToken abort the liquidation if the position's collateral per token is below this value.\r\n     * @param maxCollateralPerToken abort the liquidation if the position's collateral per token exceeds this value.\r\n     * @param maxTokensToLiquidate max number of tokens to liquidate.\r\n     * @param deadline abort the liquidation if the transaction is mined after this timestamp.\r\n     * @return liquidationId ID of the newly created liquidation.\r\n     * @return tokensLiquidated amount of synthetic tokens removed and liquidated from the `sponsor`'s position.\r\n     * @return finalFeeBond amount of collateral to be posted by liquidator and returned if not disputed successfully.\r\n     */\r\n    function createLiquidation(\r\n        address sponsor,\r\n        FixedPoint.Unsigned calldata minCollateralPerToken,\r\n        FixedPoint.Unsigned calldata maxCollateralPerToken,\r\n        FixedPoint.Unsigned calldata maxTokensToLiquidate,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        notEmergencyShutdown()\r\n        fees()\r\n        nonReentrant()\r\n        returns (\r\n            uint256 liquidationId,\r\n            FixedPoint.Unsigned memory tokensLiquidated,\r\n            FixedPoint.Unsigned memory finalFeeBond\r\n        )\r\n    {\r\n        // Check that this transaction was mined pre-deadline.\r\n        require(getCurrentTime() <= deadline);\r\n\r\n        // Retrieve Position data for sponsor\r\n        PositionData storage positionToLiquidate = _getPositionData(sponsor);\r\n\r\n        tokensLiquidated = FixedPoint.min(maxTokensToLiquidate, positionToLiquidate.tokensOutstanding);\r\n        require(tokensLiquidated.isGreaterThan(0));\r\n\r\n        // Starting values for the Position being liquidated. If withdrawal request amount is > position's collateral,\r\n        // then set this to 0, otherwise set it to (startCollateral - withdrawal request amount).\r\n        FixedPoint.Unsigned memory startCollateral = _getFeeAdjustedCollateral(positionToLiquidate.rawCollateral);\r\n        FixedPoint.Unsigned memory startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);\r\n        if (positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(startCollateral)) {\r\n            startCollateralNetOfWithdrawal = startCollateral.sub(positionToLiquidate.withdrawalRequestAmount);\r\n        }\r\n\r\n        // Scoping to get rid of a stack too deep error.\r\n        {\r\n            FixedPoint.Unsigned memory startTokens = positionToLiquidate.tokensOutstanding;\r\n\r\n            // The Position's collateralization ratio must be between [minCollateralPerToken, maxCollateralPerToken].\r\n            require(maxCollateralPerToken.mul(startTokens).isGreaterThanOrEqual(startCollateralNetOfWithdrawal));\r\n            // minCollateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\r\n            require(minCollateralPerToken.mul(startTokens).isLessThanOrEqual(startCollateralNetOfWithdrawal));\r\n        }\r\n\r\n        // Compute final fee at time of liquidation.\r\n        finalFeeBond = _computeFinalFees();\r\n\r\n        // These will be populated within the scope below.\r\n        FixedPoint.Unsigned memory lockedCollateral;\r\n        FixedPoint.Unsigned memory liquidatedCollateral;\r\n\r\n        // Scoping to get rid of a stack too deep error. The amount of tokens to remove from the position\r\n        // are not funding-rate adjusted because the multiplier only affects their redemption value, not their\r\n        // notional.\r\n        {\r\n            FixedPoint.Unsigned memory ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding);\r\n\r\n            // The actual amount of collateral that gets moved to the liquidation.\r\n            lockedCollateral = startCollateral.mul(ratio);\r\n\r\n            // For purposes of disputes, it's actually this liquidatedCollateral value that's used. This value is net of\r\n            // withdrawal requests.\r\n            liquidatedCollateral = startCollateralNetOfWithdrawal.mul(ratio);\r\n\r\n            // Part of the withdrawal request is also removed. Ideally:\r\n            // liquidatedCollateral + withdrawalAmountToRemove = lockedCollateral.\r\n            FixedPoint.Unsigned memory withdrawalAmountToRemove =\r\n                positionToLiquidate.withdrawalRequestAmount.mul(ratio);\r\n            _reduceSponsorPosition(sponsor, tokensLiquidated, lockedCollateral, withdrawalAmountToRemove);\r\n        }\r\n\r\n        // Add to the global liquidation collateral count.\r\n        _addCollateral(rawLiquidationCollateral, lockedCollateral.add(finalFeeBond));\r\n\r\n        // Construct liquidation object.\r\n        // Note: All dispute-related values are zeroed out until a dispute occurs. liquidationId is the index of the new\r\n        // LiquidationData that is pushed into the array, which is equal to the current length of the array pre-push.\r\n        liquidationId = liquidations[sponsor].length;\r\n        liquidations[sponsor].push(\r\n            LiquidationData({\r\n                sponsor: sponsor,\r\n                liquidator: msg.sender,\r\n                state: Status.NotDisputed,\r\n                liquidationTime: getCurrentTime(),\r\n                tokensOutstanding: _getFundingRateAppliedTokenDebt(tokensLiquidated),\r\n                lockedCollateral: lockedCollateral,\r\n                liquidatedCollateral: liquidatedCollateral,\r\n                rawUnitCollateral: _convertToRawCollateral(FixedPoint.fromUnscaledUint(1)),\r\n                disputer: address(0),\r\n                settlementPrice: FixedPoint.fromUnscaledUint(0),\r\n                finalFee: finalFeeBond\r\n            })\r\n        );\r\n\r\n        // If this liquidation is a subsequent liquidation on the position, and the liquidation size is larger than\r\n        // some \"griefing threshold\", then re-set the liveness. This enables a liquidation against a withdraw request to be\r\n        // \"dragged out\" if the position is very large and liquidators need time to gather funds. The griefing threshold\r\n        // is enforced so that liquidations for trivially small # of tokens cannot drag out an honest sponsor's slow withdrawal.\r\n\r\n        // We arbitrarily set the \"griefing threshold\" to `minSponsorTokens` because it is the only parameter\r\n        // denominated in token currency units and we can avoid adding another parameter.\r\n        FixedPoint.Unsigned memory griefingThreshold = minSponsorTokens;\r\n        if (\r\n            positionToLiquidate.withdrawalRequestPassTimestamp > 0 && // The position is undergoing a slow withdrawal.\r\n            positionToLiquidate.withdrawalRequestPassTimestamp > getCurrentTime() && // The slow withdrawal has not yet expired.\r\n            tokensLiquidated.isGreaterThanOrEqual(griefingThreshold) // The liquidated token count is above a \"griefing threshold\".\r\n        ) {\r\n            positionToLiquidate.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);\r\n        }\r\n\r\n        emit LiquidationCreated(\r\n            sponsor,\r\n            msg.sender,\r\n            liquidationId,\r\n            _getFundingRateAppliedTokenDebt(tokensLiquidated).rawValue,\r\n            lockedCollateral.rawValue,\r\n            liquidatedCollateral.rawValue,\r\n            getCurrentTime()\r\n        );\r\n\r\n        // Destroy tokens\r\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensLiquidated.rawValue);\r\n        tokenCurrency.burn(tokensLiquidated.rawValue);\r\n\r\n        // Pull final fee from liquidator.\r\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), finalFeeBond.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond and pay a fixed final\r\n     * fee charged on each price request.\r\n     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.\r\n     * This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute\r\n     * bond amount is calculated from `disputeBondPercentage` times the collateral in the liquidation.\r\n     * @param liquidationId of the disputed liquidation.\r\n     * @param sponsor the address of the sponsor whose liquidation is being disputed.\r\n     * @return totalPaid amount of collateral charged to disputer (i.e. final fee bond + dispute bond).\r\n     */\r\n    function dispute(uint256 liquidationId, address sponsor)\r\n        external\r\n        disputable(liquidationId, sponsor)\r\n        fees()\r\n        nonReentrant()\r\n        returns (FixedPoint.Unsigned memory totalPaid)\r\n    {\r\n        LiquidationData storage disputedLiquidation = _getLiquidationData(sponsor, liquidationId);\r\n\r\n        // Multiply by the unit collateral so the dispute bond is a percentage of the locked collateral after fees.\r\n        FixedPoint.Unsigned memory disputeBondAmount =\r\n            disputedLiquidation.lockedCollateral.mul(disputeBondPercentage).mul(\r\n                _getFeeAdjustedCollateral(disputedLiquidation.rawUnitCollateral)\r\n            );\r\n        _addCollateral(rawLiquidationCollateral, disputeBondAmount);\r\n\r\n        // Request a price from DVM. Liquidation is pending dispute until DVM returns a price.\r\n        disputedLiquidation.state = Status.Disputed;\r\n        disputedLiquidation.disputer = msg.sender;\r\n\r\n        // Enqueue a request with the DVM.\r\n        _requestOraclePrice(disputedLiquidation.liquidationTime);\r\n\r\n        emit LiquidationDisputed(\r\n            sponsor,\r\n            disputedLiquidation.liquidator,\r\n            msg.sender,\r\n            liquidationId,\r\n            disputeBondAmount.rawValue\r\n        );\r\n        totalPaid = disputeBondAmount.add(disputedLiquidation.finalFee);\r\n\r\n        // Pay the final fee for requesting price from the DVM.\r\n        _payFinalFees(msg.sender, disputedLiquidation.finalFee);\r\n\r\n        // Transfer the dispute bond amount from the caller to this contract.\r\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), disputeBondAmount.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice After a dispute has settled or after a non-disputed liquidation has expired,\r\n     * anyone can call this method to disperse payments to the sponsor, liquidator, and disputer.\r\n     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment.\r\n     * If the dispute FAILED: only the liquidator receives payment. This method deletes the liquidation data.\r\n     * This method will revert if rewards have already been dispersed.\r\n     * @param liquidationId uniquely identifies the sponsor's liquidation.\r\n     * @param sponsor address of the sponsor associated with the liquidation.\r\n     * @return data about rewards paid out.\r\n     */\r\n    function withdrawLiquidation(uint256 liquidationId, address sponsor)\r\n        public\r\n        withdrawable(liquidationId, sponsor)\r\n        fees()\r\n        nonReentrant()\r\n        returns (RewardsData memory)\r\n    {\r\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\r\n\r\n        // Settles the liquidation if necessary. This call will revert if the price has not resolved yet.\r\n        _settle(liquidationId, sponsor);\r\n\r\n        // Calculate rewards as a function of the TRV.\r\n        // Note1: all payouts are scaled by the unit collateral value so all payouts are charged the fees pro rata.\r\n        // Note2: the tokenRedemptionValue uses the tokensOutstanding which was calculated using the funding rate at\r\n        // liquidation time from _getFundingRateAppliedTokenDebt. Therefore the TRV considers the full debt value at that time.\r\n        FixedPoint.Unsigned memory feeAttenuation = _getFeeAdjustedCollateral(liquidation.rawUnitCollateral);\r\n        FixedPoint.Unsigned memory settlementPrice = liquidation.settlementPrice;\r\n        FixedPoint.Unsigned memory tokenRedemptionValue =\r\n            liquidation.tokensOutstanding.mul(settlementPrice).mul(feeAttenuation);\r\n        FixedPoint.Unsigned memory collateral = liquidation.lockedCollateral.mul(feeAttenuation);\r\n        FixedPoint.Unsigned memory disputerDisputeReward = disputerDisputeRewardPercentage.mul(tokenRedemptionValue);\r\n        FixedPoint.Unsigned memory sponsorDisputeReward = sponsorDisputeRewardPercentage.mul(tokenRedemptionValue);\r\n        FixedPoint.Unsigned memory disputeBondAmount = collateral.mul(disputeBondPercentage);\r\n        FixedPoint.Unsigned memory finalFee = liquidation.finalFee.mul(feeAttenuation);\r\n\r\n        // There are three main outcome states: either the dispute succeeded, failed or was not updated.\r\n        // Based on the state, different parties of a liquidation receive different amounts.\r\n        // After assigning rewards based on the liquidation status, decrease the total collateral held in this contract\r\n        // by the amount to pay each party. The actual amounts withdrawn might differ if _removeCollateral causes\r\n        // precision loss.\r\n        RewardsData memory rewards;\r\n        if (liquidation.state == Status.DisputeSucceeded) {\r\n            // If the dispute is successful then all three users should receive rewards:\r\n\r\n            // Pay DISPUTER: disputer reward + dispute bond + returned final fee\r\n            rewards.payToDisputer = disputerDisputeReward.add(disputeBondAmount).add(finalFee);\r\n\r\n            // Pay SPONSOR: remaining collateral (collateral - TRV) + sponsor reward\r\n            rewards.payToSponsor = sponsorDisputeReward.add(collateral.sub(tokenRedemptionValue));\r\n\r\n            // Pay LIQUIDATOR: TRV - dispute reward - sponsor reward\r\n            // If TRV > Collateral, then subtract rewards from collateral\r\n            // NOTE: This should never be below zero since we prevent (sponsorDisputePercentage+disputerDisputePercentage) >= 0 in\r\n            // the constructor when these params are set.\r\n            rewards.payToLiquidator = tokenRedemptionValue.sub(sponsorDisputeReward).sub(disputerDisputeReward);\r\n\r\n            // Transfer rewards and debit collateral\r\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\r\n            rewards.paidToSponsor = _removeCollateral(rawLiquidationCollateral, rewards.payToSponsor);\r\n            rewards.paidToDisputer = _removeCollateral(rawLiquidationCollateral, rewards.payToDisputer);\r\n\r\n            collateralCurrency.safeTransfer(liquidation.disputer, rewards.paidToDisputer.rawValue);\r\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\r\n            collateralCurrency.safeTransfer(liquidation.sponsor, rewards.paidToSponsor.rawValue);\r\n\r\n            // In the case of a failed dispute only the liquidator can withdraw.\r\n        } else if (liquidation.state == Status.DisputeFailed) {\r\n            // Pay LIQUIDATOR: collateral + dispute bond + returned final fee\r\n            rewards.payToLiquidator = collateral.add(disputeBondAmount).add(finalFee);\r\n\r\n            // Transfer rewards and debit collateral\r\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\r\n\r\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\r\n\r\n            // If the state is pre-dispute but time has passed liveness then there was no dispute. We represent this\r\n            // state as a dispute failed and the liquidator can withdraw.\r\n        } else if (liquidation.state == Status.NotDisputed) {\r\n            // Pay LIQUIDATOR: collateral + returned final fee\r\n            rewards.payToLiquidator = collateral.add(finalFee);\r\n\r\n            // Transfer rewards and debit collateral\r\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\r\n\r\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\r\n        }\r\n\r\n        emit LiquidationWithdrawn(\r\n            msg.sender,\r\n            rewards.paidToLiquidator.rawValue,\r\n            rewards.paidToDisputer.rawValue,\r\n            rewards.paidToSponsor.rawValue,\r\n            liquidation.state,\r\n            settlementPrice.rawValue\r\n        );\r\n\r\n        // Free up space after collateral is withdrawn by removing the liquidation object from the array.\r\n        delete liquidations[sponsor][liquidationId];\r\n\r\n        return rewards;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets all liquidation information for a given sponsor address.\r\n     * @param sponsor address of the position sponsor.\r\n     * @return liquidationData array of all liquidation information for the given sponsor address.\r\n     */\r\n    function getLiquidations(address sponsor)\r\n        external\r\n        view\r\n        nonReentrantView()\r\n        returns (LiquidationData[] memory liquidationData)\r\n    {\r\n        return liquidations[sponsor];\r\n    }\r\n\r\n    /****************************************\r\n     *          INTERNAL FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    // This settles a liquidation if it is in the Disputed state. If not, it will immediately return.\r\n    // If the liquidation is in the Disputed state, but a price is not available, this will revert.\r\n    function _settle(uint256 liquidationId, address sponsor) internal {\r\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\r\n\r\n        // Settlement only happens when state == Disputed and will only happen once per liquidation.\r\n        // If this liquidation is not ready to be settled, this method should return immediately.\r\n        if (liquidation.state != Status.Disputed) {\r\n            return;\r\n        }\r\n\r\n        // Get the returned price from the oracle. If this has not yet resolved will revert.\r\n        liquidation.settlementPrice = _getOraclePrice(liquidation.liquidationTime);\r\n\r\n        // Find the value of the tokens in the underlying collateral.\r\n        FixedPoint.Unsigned memory tokenRedemptionValue =\r\n            liquidation.tokensOutstanding.mul(liquidation.settlementPrice);\r\n\r\n        // The required collateral is the value of the tokens in underlying * required collateral ratio.\r\n        FixedPoint.Unsigned memory requiredCollateral = tokenRedemptionValue.mul(collateralRequirement);\r\n\r\n        // If the position has more than the required collateral it is solvent and the dispute is valid (liquidation is invalid)\r\n        // Note that this check uses the liquidatedCollateral not the lockedCollateral as this considers withdrawals.\r\n        bool disputeSucceeded = liquidation.liquidatedCollateral.isGreaterThanOrEqual(requiredCollateral);\r\n        liquidation.state = disputeSucceeded ? Status.DisputeSucceeded : Status.DisputeFailed;\r\n\r\n        emit DisputeSettled(\r\n            msg.sender,\r\n            sponsor,\r\n            liquidation.liquidator,\r\n            liquidation.disputer,\r\n            liquidationId,\r\n            disputeSucceeded\r\n        );\r\n    }\r\n\r\n    function _pfc() internal view override returns (FixedPoint.Unsigned memory) {\r\n        return super._pfc().add(_getFeeAdjustedCollateral(rawLiquidationCollateral));\r\n    }\r\n\r\n    function _getLiquidationData(address sponsor, uint256 liquidationId)\r\n        internal\r\n        view\r\n        returns (LiquidationData storage liquidation)\r\n    {\r\n        LiquidationData[] storage liquidationArray = liquidations[sponsor];\r\n\r\n        // Revert if the caller is attempting to access an invalid liquidation\r\n        // (one that has never been created or one has never been initialized).\r\n        require(\r\n            liquidationId < liquidationArray.length && liquidationArray[liquidationId].state != Status.Uninitialized\r\n        );\r\n        return liquidationArray[liquidationId];\r\n    }\r\n\r\n    function _getLiquidationExpiry(LiquidationData storage liquidation) internal view returns (uint256) {\r\n        return liquidation.liquidationTime.add(liquidationLiveness);\r\n    }\r\n\r\n    // These internal functions are supposed to act identically to modifiers, but re-used modifiers\r\n    // unnecessarily increase contract bytecode size.\r\n    // source: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6\r\n    function _disputable(uint256 liquidationId, address sponsor) internal view {\r\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\r\n        require((getCurrentTime() < _getLiquidationExpiry(liquidation)) && (liquidation.state == Status.NotDisputed));\r\n    }\r\n\r\n    function _withdrawable(uint256 liquidationId, address sponsor) internal view {\r\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\r\n        Status state = liquidation.state;\r\n\r\n        // Must be disputed or the liquidation has passed expiry.\r\n        require(\r\n            (state > Status.NotDisputed) ||\r\n                ((_getLiquidationExpiry(liquidation) <= getCurrentTime()) && (state == Status.NotDisputed))\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/perpetual-multiparty/PerpetualPositionManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/OracleInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\n\r\nimport \"../common/FundingRateApplier.sol\";\r\n\r\n/**\r\n * @title Financial contract with priceless position management.\r\n * @notice Handles positions for multiple sponsors in an optimistic (i.e., priceless) way without relying\r\n * on a price feed. On construction, deploys a new ERC20, managed by this contract, that is the synthetic token.\r\n */\r\n\r\ncontract PerpetualPositionManager is FundingRateApplier {\r\n    using SafeMath for uint256;\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n    using SafeERC20 for IERC20;\r\n    using SafeERC20 for ExpandedIERC20;\r\n\r\n    /****************************************\r\n     *  PRICELESS POSITION DATA STRUCTURES  *\r\n     ****************************************/\r\n\r\n    // Represents a single sponsor's position. All collateral is held by this contract.\r\n    // This struct acts as bookkeeping for how much of that collateral is allocated to each sponsor.\r\n    struct PositionData {\r\n        FixedPoint.Unsigned tokensOutstanding;\r\n        // Tracks pending withdrawal requests. A withdrawal request is pending if `withdrawalRequestPassTimestamp != 0`.\r\n        uint256 withdrawalRequestPassTimestamp;\r\n        FixedPoint.Unsigned withdrawalRequestAmount;\r\n        // Raw collateral value. This value should never be accessed directly -- always use _getFeeAdjustedCollateral().\r\n        // To add or remove collateral, use _addCollateral() and _removeCollateral().\r\n        FixedPoint.Unsigned rawCollateral;\r\n    }\r\n\r\n    // Maps sponsor addresses to their positions. Each sponsor can have only one position.\r\n    mapping(address => PositionData) public positions;\r\n\r\n    // Keep track of the total collateral and tokens across all positions to enable calculating the\r\n    // global collateralization ratio without iterating over all positions.\r\n    FixedPoint.Unsigned public totalTokensOutstanding;\r\n\r\n    // Similar to the rawCollateral in PositionData, this value should not be used directly.\r\n    // _getFeeAdjustedCollateral(), _addCollateral() and _removeCollateral() must be used to access and adjust.\r\n    FixedPoint.Unsigned public rawTotalPositionCollateral;\r\n\r\n    // Synthetic token created by this contract.\r\n    ExpandedIERC20 public tokenCurrency;\r\n\r\n    // Unique identifier for DVM price feed ticker.\r\n    bytes32 public priceIdentifier;\r\n\r\n    // Time that has to elapse for a withdrawal request to be considered passed, if no liquidations occur.\r\n    // !!Note: The lower the withdrawal liveness value, the more risk incurred by the contract.\r\n    //       Extremely low liveness values increase the chance that opportunistic invalid withdrawal requests\r\n    //       expire without liquidation, thereby increasing the insolvency risk for the contract as a whole. An insolvent\r\n    //       contract is extremely risky for any sponsor or synthetic token holder for the contract.\r\n    uint256 public withdrawalLiveness;\r\n\r\n    // Minimum number of tokens in a sponsor's position.\r\n    FixedPoint.Unsigned public minSponsorTokens;\r\n\r\n    // Expiry price pulled from the DVM in the case of an emergency shutdown.\r\n    FixedPoint.Unsigned public emergencyShutdownPrice;\r\n\r\n    /****************************************\r\n     *                EVENTS                *\r\n     ****************************************/\r\n\r\n    event Deposit(address indexed sponsor, uint256 indexed collateralAmount);\r\n    event Withdrawal(address indexed sponsor, uint256 indexed collateralAmount);\r\n    event RequestWithdrawal(address indexed sponsor, uint256 indexed collateralAmount);\r\n    event RequestWithdrawalExecuted(address indexed sponsor, uint256 indexed collateralAmount);\r\n    event RequestWithdrawalCanceled(address indexed sponsor, uint256 indexed collateralAmount);\r\n    event PositionCreated(address indexed sponsor, uint256 indexed collateralAmount, uint256 indexed tokenAmount);\r\n    event NewSponsor(address indexed sponsor);\r\n    event EndedSponsorPosition(address indexed sponsor);\r\n    event Redeem(address indexed sponsor, uint256 indexed collateralAmount, uint256 indexed tokenAmount);\r\n    event Repay(address indexed sponsor, uint256 indexed numTokensRepaid, uint256 indexed newTokenCount);\r\n    event EmergencyShutdown(address indexed caller, uint256 shutdownTimestamp);\r\n    event SettleEmergencyShutdown(\r\n        address indexed caller,\r\n        uint256 indexed collateralReturned,\r\n        uint256 indexed tokensBurned\r\n    );\r\n\r\n    /****************************************\r\n     *               MODIFIERS              *\r\n     ****************************************/\r\n\r\n    modifier onlyCollateralizedPosition(address sponsor) {\r\n        _onlyCollateralizedPosition(sponsor);\r\n        _;\r\n    }\r\n\r\n    modifier noPendingWithdrawal(address sponsor) {\r\n        _positionHasNoPendingWithdrawal(sponsor);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Construct the PerpetualPositionManager.\r\n     * @dev Deployer of this contract should consider carefully which parties have ability to mint and burn\r\n     * the synthetic tokens referenced by `_tokenAddress`. This contract's security assumes that no external accounts\r\n     * can mint new tokens, which could be used to steal all of this contract's locked collateral.\r\n     * We recommend to only use synthetic token contracts whose sole Owner role (the role capable of adding & removing roles)\r\n     * is assigned to this contract, whose sole Minter role is assigned to this contract, and whose\r\n     * total supply is 0 prior to construction of this contract.\r\n     * @param _withdrawalLiveness liveness delay, in seconds, for pending withdrawals.\r\n     * @param _collateralAddress ERC20 token used as collateral for all positions.\r\n     * @param _tokenAddress ERC20 token used as synthetic token.\r\n     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\r\n     * @param _priceIdentifier registered in the DVM for the synthetic.\r\n     * @param _fundingRateIdentifier Unique identifier for DVM price feed ticker for child financial contract.\r\n     * @param _minSponsorTokens minimum number of tokens that must exist at any time in a position.\r\n     * @param _tokenScaling initial scaling to apply to the token value (i.e. scales the tracking index).\r\n     * @param _timerAddress Contract that stores the current time in a testing environment. Set to 0x0 for production.\r\n     */\r\n    constructor(\r\n        uint256 _withdrawalLiveness,\r\n        address _collateralAddress,\r\n        address _tokenAddress,\r\n        address _finderAddress,\r\n        bytes32 _priceIdentifier,\r\n        bytes32 _fundingRateIdentifier,\r\n        FixedPoint.Unsigned memory _minSponsorTokens,\r\n        address _configStoreAddress,\r\n        FixedPoint.Unsigned memory _tokenScaling,\r\n        address _timerAddress\r\n    )\r\n        FundingRateApplier(\r\n            _fundingRateIdentifier,\r\n            _collateralAddress,\r\n            _finderAddress,\r\n            _configStoreAddress,\r\n            _tokenScaling,\r\n            _timerAddress\r\n        )\r\n    {\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(_priceIdentifier));\r\n\r\n        withdrawalLiveness = _withdrawalLiveness;\r\n        tokenCurrency = ExpandedIERC20(_tokenAddress);\r\n        minSponsorTokens = _minSponsorTokens;\r\n        priceIdentifier = _priceIdentifier;\r\n    }\r\n\r\n    /****************************************\r\n     *          POSITION FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Transfers `collateralAmount` of `collateralCurrency` into the specified sponsor's position.\r\n     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\r\n     * at least `collateralAmount` of `collateralCurrency`.\r\n     * @param sponsor the sponsor to credit the deposit to.\r\n     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\r\n     */\r\n    function depositTo(address sponsor, FixedPoint.Unsigned memory collateralAmount)\r\n        public\r\n        notEmergencyShutdown()\r\n        noPendingWithdrawal(sponsor)\r\n        fees()\r\n        nonReentrant()\r\n    {\r\n        require(collateralAmount.isGreaterThan(0));\r\n        PositionData storage positionData = _getPositionData(sponsor);\r\n\r\n        // Increase the position and global collateral balance by collateral amount.\r\n        _incrementCollateralBalances(positionData, collateralAmount);\r\n\r\n        emit Deposit(sponsor, collateralAmount.rawValue);\r\n\r\n        // Move collateral currency from sender to contract.\r\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `collateralAmount` of `collateralCurrency` into the caller's position.\r\n     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\r\n     * at least `collateralAmount` of `collateralCurrency`.\r\n     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\r\n     */\r\n    function deposit(FixedPoint.Unsigned memory collateralAmount) public {\r\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\r\n        depositTo(msg.sender, collateralAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.\r\n     * @dev Reverts if the withdrawal puts this position's collateralization ratio below the global collateralization\r\n     * ratio. In that case, use `requestWithdrawal`. Might not withdraw the full requested amount to account for precision loss.\r\n     * @param collateralAmount is the amount of collateral to withdraw.\r\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\r\n     */\r\n    function withdraw(FixedPoint.Unsigned memory collateralAmount)\r\n        public\r\n        notEmergencyShutdown()\r\n        noPendingWithdrawal(msg.sender)\r\n        fees()\r\n        nonReentrant()\r\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\r\n    {\r\n        require(collateralAmount.isGreaterThan(0));\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n\r\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\r\n        // position remains above the GCR within the withdrawal. If this is not the case the caller must submit a request.\r\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\r\n\r\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\r\n\r\n        // Move collateral currency from contract to sender.\r\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\r\n        // instead of the user requested amount. This eliminates precision loss that could occur\r\n        // where the user withdraws more collateral than rawCollateral is decremented by.\r\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Starts a withdrawal request that, if passed, allows the sponsor to withdraw from their position.\r\n     * @dev The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.\r\n     * @param collateralAmount the amount of collateral requested to withdraw\r\n     */\r\n    function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\r\n        public\r\n        notEmergencyShutdown()\r\n        noPendingWithdrawal(msg.sender)\r\n        nonReentrant()\r\n    {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(\r\n            collateralAmount.isGreaterThan(0) &&\r\n                collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral))\r\n        );\r\n\r\n        // Update the position object for the user.\r\n        positionData.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);\r\n        positionData.withdrawalRequestAmount = collateralAmount;\r\n\r\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting\r\n     * `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.\r\n     * @dev Might not withdraw the full requested amount in order to account for precision loss or if the full requested\r\n     * amount exceeds the collateral in the position (due to paying fees).\r\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\r\n     */\r\n    function withdrawPassedRequest()\r\n        external\r\n        notEmergencyShutdown()\r\n        fees()\r\n        nonReentrant()\r\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\r\n    {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(\r\n            positionData.withdrawalRequestPassTimestamp != 0 &&\r\n                positionData.withdrawalRequestPassTimestamp <= getCurrentTime()\r\n        );\r\n\r\n        // If withdrawal request amount is > position collateral, then withdraw the full collateral amount.\r\n        // This situation is possible due to fees charged since the withdrawal was originally requested.\r\n        FixedPoint.Unsigned memory amountToWithdraw = positionData.withdrawalRequestAmount;\r\n        if (positionData.withdrawalRequestAmount.isGreaterThan(_getFeeAdjustedCollateral(positionData.rawCollateral))) {\r\n            amountToWithdraw = _getFeeAdjustedCollateral(positionData.rawCollateral);\r\n        }\r\n\r\n        // Decrement the sponsor's collateral and global collateral amounts.\r\n        amountWithdrawn = _decrementCollateralBalances(positionData, amountToWithdraw);\r\n\r\n        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\r\n        _resetWithdrawalRequest(positionData);\r\n\r\n        // Transfer approved withdrawal amount from the contract to the caller.\r\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\r\n\r\n        emit RequestWithdrawalExecuted(msg.sender, amountWithdrawn.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Cancels a pending withdrawal request.\r\n     */\r\n    function cancelWithdrawal() external notEmergencyShutdown() nonReentrant() {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        // No pending withdrawal require message removed to save bytecode.\r\n        require(positionData.withdrawalRequestPassTimestamp != 0);\r\n\r\n        emit RequestWithdrawalCanceled(msg.sender, positionData.withdrawalRequestAmount.rawValue);\r\n\r\n        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\r\n        _resetWithdrawalRequest(positionData);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates tokens by creating a new position or by augmenting an existing position. Pulls `collateralAmount\r\n     * ` into the sponsor's position and mints `numTokens` of `tokenCurrency`.\r\n     * @dev This contract must have the Minter role for the `tokenCurrency`.\r\n     * @dev Reverts if minting these tokens would put the position's collateralization ratio below the\r\n     * global collateralization ratio. This contract must be approved to spend at least `collateralAmount` of\r\n     * `collateralCurrency`.\r\n     * @param collateralAmount is the number of collateral tokens to collateralize the position with\r\n     * @param numTokens is the number of tokens to mint from the position.\r\n     */\r\n    function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\r\n        public\r\n        notEmergencyShutdown()\r\n        fees()\r\n        nonReentrant()\r\n    {\r\n        PositionData storage positionData = positions[msg.sender];\r\n\r\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\r\n        require(\r\n            (_checkCollateralization(\r\n                _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\r\n                positionData.tokensOutstanding.add(numTokens)\r\n            ) || _checkCollateralization(collateralAmount, numTokens))\r\n        );\r\n\r\n        require(positionData.withdrawalRequestPassTimestamp == 0);\r\n        if (positionData.tokensOutstanding.isEqual(0)) {\r\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens));\r\n            emit NewSponsor(msg.sender);\r\n        }\r\n\r\n        // Increase the position and global collateral balance by collateral amount.\r\n        _incrementCollateralBalances(positionData, collateralAmount);\r\n\r\n        // Add the number of tokens created to the position's outstanding tokens.\r\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\r\n\r\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\r\n\r\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\r\n\r\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\r\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\r\n\r\n        // Note: revert reason removed to save bytecode.\r\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.\r\n     * @dev Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral\r\n     * in order to account for precision loss. This contract must be approved to spend at least `numTokens` of\r\n     * `tokenCurrency`.\r\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\r\n     * @param numTokens is the number of tokens to be burnt for a commensurate amount of collateral.\r\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\r\n     */\r\n    function redeem(FixedPoint.Unsigned memory numTokens)\r\n        public\r\n        notEmergencyShutdown()\r\n        noPendingWithdrawal(msg.sender)\r\n        fees()\r\n        nonReentrant()\r\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\r\n    {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\r\n\r\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\r\n        FixedPoint.Unsigned memory collateralRedeemed =\r\n            fractionRedeemed.mul(_getFeeAdjustedCollateral(positionData.rawCollateral));\r\n\r\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\r\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\r\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\r\n        } else {\r\n            // Decrement the sponsor's collateral and global collateral amounts.\r\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\r\n\r\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\r\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\r\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\r\n            positionData.tokensOutstanding = newTokenCount;\r\n\r\n            // Update the totalTokensOutstanding after redemption.\r\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\r\n        }\r\n\r\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\r\n\r\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\r\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\r\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\r\n        tokenCurrency.burn(numTokens.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Burns `numTokens` of `tokenCurrency` to decrease sponsors position size, without sending back `collateralCurrency`.\r\n     * This is done by a sponsor to increase position CR. Resulting size is bounded by minSponsorTokens.\r\n     * @dev Can only be called by token sponsor. This contract must be approved to spend `numTokens` of `tokenCurrency`.\r\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\r\n     * @param numTokens is the number of tokens to be burnt from the sponsor's debt position.\r\n     */\r\n    function repay(FixedPoint.Unsigned memory numTokens)\r\n        public\r\n        notEmergencyShutdown()\r\n        noPendingWithdrawal(msg.sender)\r\n        fees()\r\n        nonReentrant()\r\n    {\r\n        PositionData storage positionData = _getPositionData(msg.sender);\r\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\r\n\r\n        // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\r\n        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\r\n        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\r\n        positionData.tokensOutstanding = newTokenCount;\r\n\r\n        // Update the totalTokensOutstanding after redemption.\r\n        totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\r\n\r\n        emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\r\n\r\n        // Transfer the tokens back from the sponsor and burn them.\r\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\r\n        tokenCurrency.burn(numTokens.rawValue);\r\n    }\r\n\r\n    /**\r\n     * @notice If the contract is emergency shutdown then all token holders and sponsors can redeem their tokens or\r\n     * remaining collateral for underlying at the prevailing price defined by a DVM vote.\r\n     * @dev This burns all tokens from the caller of `tokenCurrency` and sends back the resolved settlement value of\r\n     * `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for\r\n     * precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.\r\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\r\n     * @dev Note that this function does not call the updateFundingRate modifier to update the funding rate as this\r\n     * function is only called after an emergency shutdown & there should be no funding rate updates after the shutdown.\r\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\r\n     */\r\n    function settleEmergencyShutdown()\r\n        external\r\n        isEmergencyShutdown()\r\n        fees()\r\n        nonReentrant()\r\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\r\n    {\r\n        // Set the emergency shutdown price as resolved from the DVM. If DVM has not resolved will revert.\r\n        if (emergencyShutdownPrice.isEqual(FixedPoint.fromUnscaledUint(0))) {\r\n            emergencyShutdownPrice = _getOracleEmergencyShutdownPrice();\r\n        }\r\n\r\n        // Get caller's tokens balance and calculate amount of underlying entitled to them.\r\n        FixedPoint.Unsigned memory tokensToRedeem = FixedPoint.Unsigned(tokenCurrency.balanceOf(msg.sender));\r\n        FixedPoint.Unsigned memory totalRedeemableCollateral =\r\n            _getFundingRateAppliedTokenDebt(tokensToRedeem).mul(emergencyShutdownPrice);\r\n\r\n        // If the caller is a sponsor with outstanding collateral they are also entitled to their excess collateral after their debt.\r\n        PositionData storage positionData = positions[msg.sender];\r\n        if (_getFeeAdjustedCollateral(positionData.rawCollateral).isGreaterThan(0)) {\r\n            // Calculate the underlying entitled to a token sponsor. This is collateral - debt in underlying with\r\n            // the funding rate applied to the outstanding token debt.\r\n\r\n            FixedPoint.Unsigned memory tokenDebtValueInCollateral =\r\n                _getFundingRateAppliedTokenDebt(positionData.tokensOutstanding).mul(emergencyShutdownPrice);\r\n            FixedPoint.Unsigned memory positionCollateral = _getFeeAdjustedCollateral(positionData.rawCollateral);\r\n\r\n            // If the debt is greater than the remaining collateral, they cannot redeem anything.\r\n            FixedPoint.Unsigned memory positionRedeemableCollateral =\r\n                tokenDebtValueInCollateral.isLessThan(positionCollateral)\r\n                    ? positionCollateral.sub(tokenDebtValueInCollateral)\r\n                    : FixedPoint.Unsigned(0);\r\n\r\n            // Add the number of redeemable tokens for the sponsor to their total redeemable collateral.\r\n            totalRedeemableCollateral = totalRedeemableCollateral.add(positionRedeemableCollateral);\r\n\r\n            // Reset the position state as all the value has been removed after settlement.\r\n            delete positions[msg.sender];\r\n            emit EndedSponsorPosition(msg.sender);\r\n        }\r\n\r\n        // Take the min of the remaining collateral and the collateral \"owed\". If the contract is undercapitalized,\r\n        // the caller will get as much collateral as the contract can pay out.\r\n        FixedPoint.Unsigned memory payout =\r\n            FixedPoint.min(_getFeeAdjustedCollateral(rawTotalPositionCollateral), totalRedeemableCollateral);\r\n\r\n        // Decrement total contract collateral and outstanding debt.\r\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, payout);\r\n        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRedeem);\r\n\r\n        emit SettleEmergencyShutdown(msg.sender, amountWithdrawn.rawValue, tokensToRedeem.rawValue);\r\n\r\n        // Transfer tokens & collateral and burn the redeemed tokens.\r\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\r\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensToRedeem.rawValue);\r\n        tokenCurrency.burn(tokensToRedeem.rawValue);\r\n    }\r\n\r\n    /****************************************\r\n     *        GLOBAL STATE FUNCTIONS        *\r\n     ****************************************/\r\n\r\n    /**\r\n     * @notice Premature contract settlement under emergency circumstances.\r\n     * @dev Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`.\r\n     * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal\r\n     * to occur via the `settleEmergencyShutdown` function.\r\n     */\r\n    function emergencyShutdown() external override notEmergencyShutdown() fees() nonReentrant() {\r\n        // Note: revert reason removed to save bytecode.\r\n        require(msg.sender == _getFinancialContractsAdminAddress());\r\n\r\n        emergencyShutdownTimestamp = getCurrentTime();\r\n        _requestOraclePrice(emergencyShutdownTimestamp);\r\n\r\n        emit EmergencyShutdown(msg.sender, emergencyShutdownTimestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Theoretically supposed to pay fees and move money between margin accounts to make sure they\r\n     * reflect the NAV of the contract. However, this functionality doesn't apply to this contract.\r\n     * @dev This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable\r\n     * only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.\r\n     */\r\n    function remargin() external pure override {\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @notice Accessor method for a sponsor's collateral.\r\n     * @dev This is necessary because the struct returned by the positions() method shows\r\n     * rawCollateral, which isn't a user-readable value.\r\n     * @dev This method accounts for pending regular fees that have not yet been withdrawn from this contract, for\r\n     * example if the `lastPaymentTime != currentTime`.\r\n     * @param sponsor address whose collateral amount is retrieved.\r\n     * @return collateralAmount amount of collateral within a sponsors position.\r\n     */\r\n    function getCollateral(address sponsor)\r\n        external\r\n        view\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory collateralAmount)\r\n    {\r\n        // Note: do a direct access to avoid the validity check.\r\n        return _getPendingRegularFeeAdjustedCollateral(_getFeeAdjustedCollateral(positions[sponsor].rawCollateral));\r\n    }\r\n\r\n    /**\r\n     * @notice Accessor method for the total collateral stored within the PerpetualPositionManager.\r\n     * @return totalCollateral amount of all collateral within the position manager.\r\n     */\r\n    function totalPositionCollateral()\r\n        external\r\n        view\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory totalCollateral)\r\n    {\r\n        return _getPendingRegularFeeAdjustedCollateral(_getFeeAdjustedCollateral(rawTotalPositionCollateral));\r\n    }\r\n\r\n    function getFundingRateAppliedTokenDebt(FixedPoint.Unsigned memory rawTokenDebt)\r\n        external\r\n        view\r\n        nonReentrantView()\r\n        returns (FixedPoint.Unsigned memory totalCollateral)\r\n    {\r\n        return _getFundingRateAppliedTokenDebt(rawTokenDebt);\r\n    }\r\n\r\n    /****************************************\r\n     *          INTERNAL FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    // Reduces a sponsor's position and global counters by the specified parameters. Handles deleting the entire\r\n    // position if the entire position is being removed. Does not make any external transfers.\r\n    function _reduceSponsorPosition(\r\n        address sponsor,\r\n        FixedPoint.Unsigned memory tokensToRemove,\r\n        FixedPoint.Unsigned memory collateralToRemove,\r\n        FixedPoint.Unsigned memory withdrawalAmountToRemove\r\n    ) internal {\r\n        PositionData storage positionData = _getPositionData(sponsor);\r\n\r\n        // If the entire position is being removed, delete it instead.\r\n        if (\r\n            tokensToRemove.isEqual(positionData.tokensOutstanding) &&\r\n            _getFeeAdjustedCollateral(positionData.rawCollateral).isEqual(collateralToRemove)\r\n        ) {\r\n            _deleteSponsorPosition(sponsor);\r\n            return;\r\n        }\r\n\r\n        // Decrement the sponsor's collateral and global collateral amounts.\r\n        _decrementCollateralBalances(positionData, collateralToRemove);\r\n\r\n        // Ensure that the sponsor will meet the min position size after the reduction.\r\n        positionData.tokensOutstanding = positionData.tokensOutstanding.sub(tokensToRemove);\r\n        require(positionData.tokensOutstanding.isGreaterThanOrEqual(minSponsorTokens));\r\n\r\n        // Decrement the position's withdrawal amount.\r\n        positionData.withdrawalRequestAmount = positionData.withdrawalRequestAmount.sub(withdrawalAmountToRemove);\r\n\r\n        // Decrement the total outstanding tokens in the overall contract.\r\n        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRemove);\r\n    }\r\n\r\n    // Deletes a sponsor's position and updates global counters. Does not make any external transfers.\r\n    function _deleteSponsorPosition(address sponsor) internal returns (FixedPoint.Unsigned memory) {\r\n        PositionData storage positionToLiquidate = _getPositionData(sponsor);\r\n\r\n        FixedPoint.Unsigned memory startingGlobalCollateral = _getFeeAdjustedCollateral(rawTotalPositionCollateral);\r\n\r\n        // Remove the collateral and outstanding from the overall total position.\r\n        rawTotalPositionCollateral = rawTotalPositionCollateral.sub(positionToLiquidate.rawCollateral);\r\n        totalTokensOutstanding = totalTokensOutstanding.sub(positionToLiquidate.tokensOutstanding);\r\n\r\n        // Reset the sponsors position to have zero outstanding and collateral.\r\n        delete positions[sponsor];\r\n\r\n        emit EndedSponsorPosition(sponsor);\r\n\r\n        // Return fee-adjusted amount of collateral deleted from position.\r\n        return startingGlobalCollateral.sub(_getFeeAdjustedCollateral(rawTotalPositionCollateral));\r\n    }\r\n\r\n    function _pfc() internal view virtual override returns (FixedPoint.Unsigned memory) {\r\n        return _getFeeAdjustedCollateral(rawTotalPositionCollateral);\r\n    }\r\n\r\n    function _getPositionData(address sponsor)\r\n        internal\r\n        view\r\n        onlyCollateralizedPosition(sponsor)\r\n        returns (PositionData storage)\r\n    {\r\n        return positions[sponsor];\r\n    }\r\n\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    function _getOracle() internal view returns (OracleInterface) {\r\n        return OracleInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n\r\n    function _getFinancialContractsAdminAddress() internal view returns (address) {\r\n        return finder.getImplementationAddress(OracleInterfaces.FinancialContractsAdmin);\r\n    }\r\n\r\n    // Requests a price for `priceIdentifier` at `requestedTime` from the Oracle.\r\n    function _requestOraclePrice(uint256 requestedTime) internal {\r\n        _getOracle().requestPrice(priceIdentifier, requestedTime);\r\n    }\r\n\r\n    // Fetches a resolved Oracle price from the Oracle. Reverts if the Oracle hasn't resolved for this request.\r\n    function _getOraclePrice(uint256 requestedTime) internal view returns (FixedPoint.Unsigned memory price) {\r\n        // Create an instance of the oracle and get the price. If the price is not resolved revert.\r\n        int256 oraclePrice = _getOracle().getPrice(priceIdentifier, requestedTime);\r\n\r\n        // For now we don't want to deal with negative prices in positions.\r\n        if (oraclePrice < 0) {\r\n            oraclePrice = 0;\r\n        }\r\n        return FixedPoint.Unsigned(uint256(oraclePrice));\r\n    }\r\n\r\n    // Fetches a resolved Oracle price from the Oracle. Reverts if the Oracle hasn't resolved for this request.\r\n    function _getOracleEmergencyShutdownPrice() internal view returns (FixedPoint.Unsigned memory) {\r\n        return _getOraclePrice(emergencyShutdownTimestamp);\r\n    }\r\n\r\n    // Reset withdrawal request by setting the withdrawal request and withdrawal timestamp to 0.\r\n    function _resetWithdrawalRequest(PositionData storage positionData) internal {\r\n        positionData.withdrawalRequestAmount = FixedPoint.fromUnscaledUint(0);\r\n        positionData.withdrawalRequestPassTimestamp = 0;\r\n    }\r\n\r\n    // Ensure individual and global consistency when increasing collateral balances. Returns the change to the position.\r\n    function _incrementCollateralBalances(\r\n        PositionData storage positionData,\r\n        FixedPoint.Unsigned memory collateralAmount\r\n    ) internal returns (FixedPoint.Unsigned memory) {\r\n        _addCollateral(positionData.rawCollateral, collateralAmount);\r\n        return _addCollateral(rawTotalPositionCollateral, collateralAmount);\r\n    }\r\n\r\n    // Ensure individual and global consistency when decrementing collateral balances. Returns the change to the\r\n    // position. We elect to return the amount that the global collateral is decreased by, rather than the individual\r\n    // position's collateral, because we need to maintain the invariant that the global collateral is always\r\n    // <= the collateral owned by the contract to avoid reverts on withdrawals. The amount returned = amount withdrawn.\r\n    function _decrementCollateralBalances(\r\n        PositionData storage positionData,\r\n        FixedPoint.Unsigned memory collateralAmount\r\n    ) internal returns (FixedPoint.Unsigned memory) {\r\n        _removeCollateral(positionData.rawCollateral, collateralAmount);\r\n        return _removeCollateral(rawTotalPositionCollateral, collateralAmount);\r\n    }\r\n\r\n    // Ensure individual and global consistency when decrementing collateral balances. Returns the change to the position.\r\n    // This function is similar to the _decrementCollateralBalances function except this function checks position GCR\r\n    // between the decrements. This ensures that collateral removal will not leave the position undercollateralized.\r\n    function _decrementCollateralBalancesCheckGCR(\r\n        PositionData storage positionData,\r\n        FixedPoint.Unsigned memory collateralAmount\r\n    ) internal returns (FixedPoint.Unsigned memory) {\r\n        _removeCollateral(positionData.rawCollateral, collateralAmount);\r\n        require(_checkPositionCollateralization(positionData));\r\n        return _removeCollateral(rawTotalPositionCollateral, collateralAmount);\r\n    }\r\n\r\n    // These internal functions are supposed to act identically to modifiers, but re-used modifiers\r\n    // unnecessarily increase contract bytecode size.\r\n    // source: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6\r\n    function _onlyCollateralizedPosition(address sponsor) internal view {\r\n        require(_getFeeAdjustedCollateral(positions[sponsor].rawCollateral).isGreaterThan(0));\r\n    }\r\n\r\n    // Note: This checks whether an already existing position has a pending withdrawal. This cannot be used on the\r\n    // `create` method because it is possible that `create` is called on a new position (i.e. one without any collateral\r\n    // or tokens outstanding) which would fail the `onlyCollateralizedPosition` modifier on `_getPositionData`.\r\n    function _positionHasNoPendingWithdrawal(address sponsor) internal view {\r\n        require(_getPositionData(sponsor).withdrawalRequestPassTimestamp == 0);\r\n    }\r\n\r\n    /****************************************\r\n     *          PRIVATE FUNCTIONS          *\r\n     ****************************************/\r\n\r\n    function _checkPositionCollateralization(PositionData storage positionData) private view returns (bool) {\r\n        return\r\n            _checkCollateralization(\r\n                _getFeeAdjustedCollateral(positionData.rawCollateral),\r\n                positionData.tokensOutstanding\r\n            );\r\n    }\r\n\r\n    // Checks whether the provided `collateral` and `numTokens` have a collateralization ratio above the global\r\n    // collateralization ratio.\r\n    function _checkCollateralization(FixedPoint.Unsigned memory collateral, FixedPoint.Unsigned memory numTokens)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        FixedPoint.Unsigned memory global =\r\n            _getCollateralizationRatio(_getFeeAdjustedCollateral(rawTotalPositionCollateral), totalTokensOutstanding);\r\n        FixedPoint.Unsigned memory thisChange = _getCollateralizationRatio(collateral, numTokens);\r\n        return !global.isGreaterThan(thisChange);\r\n    }\r\n\r\n    function _getCollateralizationRatio(FixedPoint.Unsigned memory collateral, FixedPoint.Unsigned memory numTokens)\r\n        private\r\n        pure\r\n        returns (FixedPoint.Unsigned memory ratio)\r\n    {\r\n        return numTokens.isLessThanOrEqual(0) ? FixedPoint.fromUnscaledUint(0) : collateral.div(numTokens);\r\n    }\r\n\r\n    function _getTokenAddress() internal view override returns (address) {\r\n        return address(tokenCurrency);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/test/ExpiringMultiPartyMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../common/financial-product-libraries/expiring-multiparty-libraries/FinancialProductLibrary.sol\";\r\n\r\ncontract ExpiringMultiPartyMock is Testable {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    FinancialProductLibrary public financialProductLibrary;\r\n    uint256 public expirationTimestamp;\r\n    FixedPoint.Unsigned public collateralRequirement;\r\n    bytes32 public priceIdentifier;\r\n\r\n    constructor(\r\n        address _financialProductLibraryAddress,\r\n        uint256 _expirationTimestamp,\r\n        FixedPoint.Unsigned memory _collateralRequirement,\r\n        bytes32 _priceIdentifier,\r\n        address _timerAddress\r\n    ) Testable(_timerAddress) {\r\n        expirationTimestamp = _expirationTimestamp;\r\n        collateralRequirement = _collateralRequirement;\r\n        financialProductLibrary = FinancialProductLibrary(_financialProductLibraryAddress);\r\n        priceIdentifier = _priceIdentifier;\r\n    }\r\n\r\n    function transformPrice(FixedPoint.Unsigned memory price, uint256 requestTime)\r\n        public\r\n        view\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        if (address(financialProductLibrary) == address(0)) return price;\r\n        try financialProductLibrary.transformPrice(price, requestTime) returns (\r\n            FixedPoint.Unsigned memory transformedPrice\r\n        ) {\r\n            return transformedPrice;\r\n        } catch {\r\n            return price;\r\n        }\r\n    }\r\n\r\n    function transformCollateralRequirement(FixedPoint.Unsigned memory price)\r\n        public\r\n        view\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        if (address(financialProductLibrary) == address(0)) return collateralRequirement;\r\n        try financialProductLibrary.transformCollateralRequirement(price, collateralRequirement) returns (\r\n            FixedPoint.Unsigned memory transformedCollateralRequirement\r\n        ) {\r\n            return transformedCollateralRequirement;\r\n        } catch {\r\n            return collateralRequirement;\r\n        }\r\n    }\r\n\r\n    function transformPriceIdentifier(uint256 requestTime) public view returns (bytes32) {\r\n        if (address(financialProductLibrary) == address(0)) return priceIdentifier;\r\n        try financialProductLibrary.transformPriceIdentifier(priceIdentifier, requestTime) returns (\r\n            bytes32 transformedIdentifier\r\n        ) {\r\n            return transformedIdentifier;\r\n        } catch {\r\n            return priceIdentifier;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/test/FinancialProductLibraryTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\nimport \"../common/financial-product-libraries/expiring-multiparty-libraries/FinancialProductLibrary.sol\";\r\n\r\n// Implements a simple FinancialProductLibrary to test price and collateral requirement transoformations.\r\ncontract FinancialProductLibraryTest is FinancialProductLibrary {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    FixedPoint.Unsigned public priceTransformationScalar;\r\n    FixedPoint.Unsigned public collateralRequirementTransformationScalar;\r\n    bytes32 public transformedPriceIdentifier;\r\n    bool public shouldRevert;\r\n\r\n    constructor(\r\n        FixedPoint.Unsigned memory _priceTransformationScalar,\r\n        FixedPoint.Unsigned memory _collateralRequirementTransformationScalar,\r\n        bytes32 _transformedPriceIdentifier\r\n    ) {\r\n        priceTransformationScalar = _priceTransformationScalar;\r\n        collateralRequirementTransformationScalar = _collateralRequirementTransformationScalar;\r\n        transformedPriceIdentifier = _transformedPriceIdentifier;\r\n    }\r\n\r\n    // Set the mocked methods to revert to test failed library computation.\r\n    function setShouldRevert(bool _shouldRevert) public {\r\n        shouldRevert = _shouldRevert;\r\n    }\r\n\r\n    // Create a simple price transformation function that scales the input price by the scalar for testing.\r\n    function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256)\r\n        public\r\n        view\r\n        override\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        require(!shouldRevert, \"set to always reverts\");\r\n        return oraclePrice.mul(priceTransformationScalar);\r\n    }\r\n\r\n    // Create a simple collateral requirement transformation that doubles the input collateralRequirement.\r\n    function transformCollateralRequirement(\r\n        FixedPoint.Unsigned memory,\r\n        FixedPoint.Unsigned memory collateralRequirement\r\n    ) public view override returns (FixedPoint.Unsigned memory) {\r\n        require(!shouldRevert, \"set to always reverts\");\r\n        return collateralRequirement.mul(collateralRequirementTransformationScalar);\r\n    }\r\n\r\n    // Create a simple transformPriceIdentifier function that returns the transformed price identifier.\r\n    function transformPriceIdentifier(bytes32, uint256) public view override returns (bytes32) {\r\n        require(!shouldRevert, \"set to always reverts\");\r\n        return transformedPriceIdentifier;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/test/FundingRateApplierTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../common/FundingRateApplier.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n// Implements FundingRateApplier internal methods to enable unit testing.\r\ncontract FundingRateApplierTest is FundingRateApplier {\r\n    constructor(\r\n        bytes32 _fundingRateIdentifier,\r\n        address _collateralAddress,\r\n        address _finderAddress,\r\n        address _configStoreAddress,\r\n        FixedPoint.Unsigned memory _tokenScaling,\r\n        address _timerAddress\r\n    )\r\n        FundingRateApplier(\r\n            _fundingRateIdentifier,\r\n            _collateralAddress,\r\n            _finderAddress,\r\n            _configStoreAddress,\r\n            _tokenScaling,\r\n            _timerAddress\r\n        )\r\n    {}\r\n\r\n    function calculateEffectiveFundingRate(\r\n        uint256 paymentPeriodSeconds,\r\n        FixedPoint.Signed memory fundingRatePerSecond,\r\n        FixedPoint.Unsigned memory currentCumulativeFundingRateMultiplier\r\n    ) public pure returns (FixedPoint.Unsigned memory) {\r\n        return\r\n            _calculateEffectiveFundingRate(\r\n                paymentPeriodSeconds,\r\n                fundingRatePerSecond,\r\n                currentCumulativeFundingRateMultiplier\r\n            );\r\n    }\r\n\r\n    // Required overrides.\r\n    function _pfc() internal view virtual override returns (FixedPoint.Unsigned memory currentPfc) {\r\n        return FixedPoint.Unsigned(collateralCurrency.balanceOf(address(this)));\r\n    }\r\n\r\n    function emergencyShutdown() external override {}\r\n\r\n    function remargin() external override {}\r\n\r\n    function _getTokenAddress() internal view override returns (address) {\r\n        return address(collateralCurrency);\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/test/LongShortPairFinancialProjectLibraryTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\nimport \"../common/financial-product-libraries/long-short-pair-libraries/LongShortPairFinancialProductLibrary.sol\";\r\n\r\n// Implements a simple FinancialProductLibrary to test price and collateral requirement transoformations.\r\ncontract LongShortPairFinancialProjectLibraryTest is LongShortPairFinancialProductLibrary {\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    uint256 public valueToReturn;\r\n\r\n    function setValueToReturn(uint256 value) public {\r\n        valueToReturn = value;\r\n    }\r\n\r\n    function percentageLongCollateralAtExpiry(\r\n        int256 /*expiryPrice*/\r\n    ) public view override returns (uint256) {\r\n        return valueToReturn;\r\n    }\r\n}\r\n"
    },
    "contracts/financial-templates/test/LongShortPairMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\ncontract LongShortPairMock {\r\n    uint256 public expirationTimestamp;\r\n    uint256 public collateralPerPair;\r\n\r\n    constructor(uint256 _expirationTimestamp, uint256 _collateralPerPair) {\r\n        expirationTimestamp = _expirationTimestamp;\r\n        collateralPerPair = _collateralPerPair;\r\n    }\r\n}\r\n"
    },
    "contracts/merkle-distributor/implementation/MerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./MerkleDistributorInterface.sol\";\r\n\r\n/**\r\n * Inspired by:\r\n * - https://github.com/pie-dao/vested-token-migration-app\r\n * - https://github.com/Uniswap/merkle-distributor\r\n * - https://github.com/balancer-labs/erc20-redeemable\r\n *\r\n * @title  MerkleDistributor contract.\r\n * @notice Allows an owner to distribute any reward ERC20 to claimants according to Merkle roots. The owner can specify\r\n *         multiple Merkle roots distributions with customized reward currencies.\r\n * @dev    The Merkle trees are not validated in any way, so the system assumes the contract owner behaves honestly.\r\n */\r\ncontract MerkleDistributor is MerkleDistributorInterface, Ownable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Windows are mapped to arbitrary indices.\r\n    mapping(uint256 => Window) public merkleWindows;\r\n\r\n    // Index of next created Merkle root.\r\n    uint256 public nextCreatedIndex;\r\n\r\n    // Track which accounts have claimed for each window index.\r\n    // Note: uses a packed array of bools for gas optimization on tracking certain claims. Copied from Uniswap's contract.\r\n    mapping(uint256 => mapping(uint256 => uint256)) private claimedBitMap;\r\n\r\n    /****************************************\r\n     *                EVENTS\r\n     ****************************************/\r\n    event Claimed(\r\n        address indexed caller,\r\n        uint256 windowIndex,\r\n        address indexed account,\r\n        uint256 accountIndex,\r\n        uint256 amount,\r\n        address indexed rewardToken\r\n    );\r\n    event CreatedWindow(\r\n        uint256 indexed windowIndex,\r\n        uint256 rewardsDeposited,\r\n        address indexed rewardToken,\r\n        address owner\r\n    );\r\n    event WithdrawRewards(address indexed owner, uint256 amount, address indexed currency);\r\n    event DeleteWindow(uint256 indexed windowIndex, address owner);\r\n\r\n    /****************************\r\n     *      ADMIN FUNCTIONS\r\n     ****************************/\r\n\r\n    /**\r\n     * @notice Set merkle root for the next available window index and seed allocations.\r\n     * @notice Callable only by owner of this contract. Caller must have approved this contract to transfer\r\n     *      `rewardsToDeposit` amount of `rewardToken` or this call will fail. Importantly, we assume that the\r\n     *      owner of this contract correctly chooses an amount `rewardsToDeposit` that is sufficient to cover all\r\n     *      claims within the `merkleRoot`.\r\n     * @param rewardsToDeposit amount of rewards to deposit to seed this allocation.\r\n     * @param rewardToken ERC20 reward token.\r\n     * @param merkleRoot merkle root describing allocation.\r\n     * @param ipfsHash hash of IPFS object, conveniently stored for clients\r\n     */\r\n    function setWindow(\r\n        uint256 rewardsToDeposit,\r\n        address rewardToken,\r\n        bytes32 merkleRoot,\r\n        string calldata ipfsHash\r\n    ) external onlyOwner {\r\n        uint256 indexToSet = nextCreatedIndex;\r\n        nextCreatedIndex = indexToSet + 1;\r\n\r\n        _setWindow(indexToSet, rewardsToDeposit, rewardToken, merkleRoot, ipfsHash);\r\n    }\r\n\r\n    /**\r\n     * @notice Delete merkle root at window index.\r\n     * @dev Callable only by owner. Likely to be followed by a withdrawRewards call to clear contract state.\r\n     * @param windowIndex merkle root index to delete.\r\n     */\r\n    function deleteWindow(uint256 windowIndex) external onlyOwner {\r\n        delete merkleWindows[windowIndex];\r\n        emit DeleteWindow(windowIndex, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Emergency method that transfers rewards out of the contract if the contract was configured improperly.\r\n     * @dev Callable only by owner.\r\n     * @param rewardCurrency rewards to withdraw from contract.\r\n     * @param amount amount of rewards to withdraw.\r\n     */\r\n    function withdrawRewards(IERC20 rewardCurrency, uint256 amount) external onlyOwner {\r\n        rewardCurrency.safeTransfer(msg.sender, amount);\r\n        emit WithdrawRewards(msg.sender, amount, address(rewardCurrency));\r\n    }\r\n\r\n    /****************************\r\n     *    NON-ADMIN FUNCTIONS\r\n     ****************************/\r\n\r\n    /**\r\n     * @notice Batch claims to reduce gas versus individual submitting all claims. Method will fail\r\n     *         if any individual claims within the batch would fail.\r\n     * @dev    Optimistically tries to batch together consecutive claims for the same account and same\r\n     *         reward token to reduce gas. Therefore, the most gas-cost-optimal way to use this method\r\n     *         is to pass in an array of claims sorted by account and reward currency. It also reverts\r\n     *         when any of individual `_claim`'s `amount` exceeds `remainingAmount` for its window.\r\n     * @param claims array of claims to claim.\r\n     */\r\n    function claimMulti(Claim[] memory claims) public virtual override {\r\n        uint256 batchedAmount;\r\n        uint256 claimCount = claims.length;\r\n        for (uint256 i = 0; i < claimCount; i++) {\r\n            Claim memory _claim = claims[i];\r\n            _verifyAndMarkClaimed(_claim);\r\n            batchedAmount += _claim.amount;\r\n\r\n            // If the next claim is NOT the same account or the same token (or this claim is the last one),\r\n            // then disburse the `batchedAmount` to the current claim's account for the current claim's reward token.\r\n            uint256 nextI = i + 1;\r\n            IERC20 currentRewardToken = merkleWindows[_claim.windowIndex].rewardToken;\r\n            if (\r\n                nextI == claimCount ||\r\n                // This claim is last claim.\r\n                claims[nextI].account != _claim.account ||\r\n                // Next claim account is different than current one.\r\n                merkleWindows[claims[nextI].windowIndex].rewardToken != currentRewardToken\r\n                // Next claim reward token is different than current one.\r\n            ) {\r\n                currentRewardToken.safeTransfer(_claim.account, batchedAmount);\r\n                batchedAmount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim amount of reward tokens for account, as described by Claim input object.\r\n     * @dev    If the `_claim`'s `amount`, `accountIndex`, and `account` do not exactly match the\r\n     *         values stored in the merkle root for the `_claim`'s `windowIndex` this method\r\n     *         will revert. It also reverts when `_claim`'s `amount` exceeds `remainingAmount` for the window.\r\n     * @param _claim claim object describing amount, accountIndex, account, window index, and merkle proof.\r\n     */\r\n    function claim(Claim memory _claim) public virtual override {\r\n        _verifyAndMarkClaimed(_claim);\r\n        merkleWindows[_claim.windowIndex].rewardToken.safeTransfer(_claim.account, _claim.amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns True if the claim for `accountIndex` has already been completed for the Merkle root at\r\n     *         `windowIndex`.\r\n     * @dev    This method will only work as intended if all `accountIndex`'s are unique for a given `windowIndex`.\r\n     *         The onus is on the Owner of this contract to submit only valid Merkle roots.\r\n     * @param windowIndex merkle root to check.\r\n     * @param accountIndex account index to check within window index.\r\n     * @return True if claim has been executed already, False otherwise.\r\n     */\r\n    function isClaimed(uint256 windowIndex, uint256 accountIndex) public view returns (bool) {\r\n        uint256 claimedWordIndex = accountIndex / 256;\r\n        uint256 claimedBitIndex = accountIndex % 256;\r\n        uint256 claimedWord = claimedBitMap[windowIndex][claimedWordIndex];\r\n        uint256 mask = (1 << claimedBitIndex);\r\n        return claimedWord & mask == mask;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns rewardToken set by admin for windowIndex.\r\n     * @param windowIndex merkle root to check.\r\n     * @return address Reward token address\r\n     */\r\n    function getRewardTokenForWindow(uint256 windowIndex) public view override returns (address) {\r\n        return address(merkleWindows[windowIndex].rewardToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns True if leaf described by {account, amount, accountIndex} is stored in Merkle root at given\r\n     *         window index.\r\n     * @param _claim claim object describing amount, accountIndex, account, window index, and merkle proof.\r\n     * @return valid True if leaf exists.\r\n     */\r\n    function verifyClaim(Claim memory _claim) public view returns (bool valid) {\r\n        bytes32 leaf = keccak256(abi.encodePacked(_claim.account, _claim.amount, _claim.accountIndex));\r\n        return MerkleProof.verify(_claim.merkleProof, merkleWindows[_claim.windowIndex].merkleRoot, leaf);\r\n    }\r\n\r\n    /****************************\r\n     *     PRIVATE FUNCTIONS\r\n     ****************************/\r\n\r\n    // Mark claim as completed for `accountIndex` for Merkle root at `windowIndex`.\r\n    function _setClaimed(uint256 windowIndex, uint256 accountIndex) private {\r\n        uint256 claimedWordIndex = accountIndex / 256;\r\n        uint256 claimedBitIndex = accountIndex % 256;\r\n        claimedBitMap[windowIndex][claimedWordIndex] =\r\n            claimedBitMap[windowIndex][claimedWordIndex] |\r\n            (1 << claimedBitIndex);\r\n    }\r\n\r\n    // Store new Merkle root at `windowindex`. Pull `rewardsDeposited` from caller to seed distribution for this root.\r\n    function _setWindow(\r\n        uint256 windowIndex,\r\n        uint256 rewardsDeposited,\r\n        address rewardToken,\r\n        bytes32 merkleRoot,\r\n        string memory ipfsHash\r\n    ) private {\r\n        Window storage window = merkleWindows[windowIndex];\r\n        window.merkleRoot = merkleRoot;\r\n        window.remainingAmount = rewardsDeposited;\r\n        window.rewardToken = IERC20(rewardToken);\r\n        window.ipfsHash = ipfsHash;\r\n\r\n        emit CreatedWindow(windowIndex, rewardsDeposited, rewardToken, msg.sender);\r\n\r\n        window.rewardToken.safeTransferFrom(msg.sender, address(this), rewardsDeposited);\r\n    }\r\n\r\n    // Verify claim is valid and mark it as completed in this contract.\r\n    function _verifyAndMarkClaimed(Claim memory _claim) internal {\r\n        // Check claimed proof against merkle window at given index.\r\n        require(verifyClaim(_claim), \"Incorrect merkle proof\");\r\n        // Check the account has not yet claimed for this window.\r\n        require(!isClaimed(_claim.windowIndex, _claim.accountIndex), \"Account has already claimed for this window\");\r\n\r\n        // Proof is correct and claim has not occurred yet, mark claimed complete.\r\n        _setClaimed(_claim.windowIndex, _claim.accountIndex);\r\n        merkleWindows[_claim.windowIndex].remainingAmount -= _claim.amount;\r\n        emit Claimed(\r\n            msg.sender,\r\n            _claim.windowIndex,\r\n            _claim.account,\r\n            _claim.accountIndex,\r\n            _claim.amount,\r\n            address(merkleWindows[_claim.windowIndex].rewardToken)\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/merkle-distributor/implementation/MerkleDistributorInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @notice Concise list of functions in MerkleDistributor implementation that would be called by\r\n * a consuming external contract (such as the Across Protocol's AcceleratingDistributor).\r\n */\r\ninterface MerkleDistributorInterface {\r\n    // A Window maps a Merkle root to a reward token address.\r\n    struct Window {\r\n        // Merkle root describing the distribution.\r\n        bytes32 merkleRoot;\r\n        // Remaining amount of deposited rewards that have not yet been claimed.\r\n        uint256 remainingAmount;\r\n        // Currency in which reward is processed.\r\n        IERC20 rewardToken;\r\n        // IPFS hash of the merkle tree. Can be used to independently fetch recipient proofs and tree. Note that the canonical\r\n        // data type for storing an IPFS hash is a multihash which is the concatenation of  <varint hash function code>\r\n        // <varint digest size in bytes><hash function output>. We opted to store this in a string type to make it easier\r\n        // for users to query the ipfs data without needing to reconstruct the multihash. to view the IPFS data simply\r\n        // go to https://cloudflare-ipfs.com/ipfs/<IPFS-HASH>.\r\n        string ipfsHash;\r\n    }\r\n\r\n    // Represents an account's claim for `amount` within the Merkle root located at the `windowIndex`.\r\n    struct Claim {\r\n        uint256 windowIndex;\r\n        uint256 amount;\r\n        uint256 accountIndex; // Used only for bitmap. Assumed to be unique for each claim.\r\n        address account;\r\n        bytes32[] merkleProof;\r\n    }\r\n\r\n    function claim(Claim memory _claim) external;\r\n\r\n    function claimMulti(Claim[] memory claims) external;\r\n\r\n    function getRewardTokenForWindow(uint256 windowIndex) external view returns (address);\r\n}\r\n"
    },
    "contracts/optimistic-governor/implementation/OptimisticGovernor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.6;\r\n\r\n// https://github.com/gnosis/zodiac/blob/master/contracts/core/Module.sol\r\nimport \"@gnosis.pm/zodiac/contracts/core/Module.sol\";\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\r\n\r\nimport \"../../optimistic-oracle-v3/implementation/ClaimData.sol\";\r\nimport \"../../optimistic-oracle-v3/interfaces/OptimisticOracleV3Interface.sol\";\r\nimport \"../../optimistic-oracle-v3/interfaces/OptimisticOracleV3CallbackRecipientInterface.sol\";\r\n\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/interfaces/AddressWhitelistInterface.sol\";\r\n\r\n/**\r\n * @title Optimistic Governor\r\n * @notice A contract that allows optimistic governance of a set of transactions. The contract can be used to propose\r\n * transactions that can be challenged by anyone. If the challenge is not resolved within a certain liveness period, the\r\n * transactions can be executed.\r\n */\r\ncontract OptimisticGovernor is OptimisticOracleV3CallbackRecipientInterface, Module, Lockable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    event OptimisticGovernorDeployed(address indexed owner, address indexed avatar, address target);\r\n\r\n    event TransactionsProposed(\r\n        address indexed proposer,\r\n        uint256 indexed proposalTime,\r\n        bytes32 indexed assertionId,\r\n        Proposal proposal,\r\n        bytes32 proposalHash,\r\n        bytes explanation,\r\n        string rules,\r\n        uint256 challengeWindowEnds\r\n    );\r\n\r\n    event TransactionExecuted(\r\n        bytes32 indexed proposalHash,\r\n        bytes32 indexed assertionId,\r\n        uint256 indexed transactionIndex\r\n    );\r\n\r\n    event ProposalExecuted(bytes32 indexed proposalHash, bytes32 indexed assertionId);\r\n\r\n    event ProposalDeleted(bytes32 indexed proposalHash, bytes32 indexed assertionId);\r\n\r\n    event SetCollateralAndBond(IERC20 indexed collateral, uint256 indexed bondAmount);\r\n\r\n    event SetRules(string rules);\r\n\r\n    event SetLiveness(uint64 indexed liveness);\r\n\r\n    event SetIdentifier(bytes32 indexed identifier);\r\n\r\n    event SetEscalationManager(address indexed escalationManager);\r\n\r\n    event OptimisticOracleChanged(address indexed newOptimisticOracleV3);\r\n\r\n    FinderInterface public immutable finder; // Finder used to discover other UMA ecosystem contracts.\r\n\r\n    IERC20 public collateral; // Collateral currency used to assert proposed transactions.\r\n    uint64 public liveness; // The amount of time to dispute proposed transactions before they can be executed.\r\n    uint256 public bondAmount; // Configured amount of collateral currency to make assertions for proposed transactions.\r\n    string public rules; // Rules for the Optimistic Governor.\r\n    bytes32 public identifier; // Identifier used to request price from the DVM, compatible with Optimistic Oracle V3.\r\n    OptimisticOracleV3Interface public optimisticOracleV3; // Optimistic Oracle V3 contract used to assert proposed transactions.\r\n    address public escalationManager; // Optional Escalation Manager contract to whitelist proposers / disputers.\r\n\r\n    // Keys for assertion claim data.\r\n    bytes public constant PROPOSAL_HASH_KEY = \"proposalHash\";\r\n    bytes public constant EXPLANATION_KEY = \"explanation\";\r\n    bytes public constant RULES_KEY = \"rules\";\r\n\r\n    // Struct for a proposed transaction.\r\n    struct Transaction {\r\n        address to; // The address to which the transaction is being sent.\r\n        Enum.Operation operation; // Operation type of transaction: 0 == call, 1 == delegate call.\r\n        uint256 value; // The value, in wei, to be sent with the transaction.\r\n        bytes data; // The data payload to be sent in the transaction.\r\n    }\r\n\r\n    // Struct for a proposed set of transactions, used only for off-chain infrastructure.\r\n    struct Proposal {\r\n        Transaction[] transactions;\r\n        uint256 requestTime;\r\n    }\r\n\r\n    mapping(bytes32 => bytes32) public assertionIds; // Maps proposal hashes to assertionIds.\r\n    mapping(bytes32 => bytes32) public proposalHashes; // Maps assertionIds to proposal hashes.\r\n\r\n    /**\r\n     * @notice Construct Optimistic Governor module.\r\n     * @param _finder Finder address.\r\n     * @param _owner Address of the owner.\r\n     * @param _collateral Address of the ERC20 collateral used for bonds.\r\n     * @param _bondAmount Amount of collateral currency to make assertions for proposed transactions\r\n     * @param _rules Reference to the rules for the Optimistic Governor.\r\n     * @param _identifier The approved identifier to be used with the contract, compatible with Optimistic Oracle V3.\r\n     * @param _liveness The period, in seconds, in which a proposal can be disputed.\r\n     */\r\n    constructor(\r\n        address _finder,\r\n        address _owner,\r\n        address _collateral,\r\n        uint256 _bondAmount,\r\n        string memory _rules,\r\n        bytes32 _identifier,\r\n        uint64 _liveness\r\n    ) {\r\n        bytes memory initializeParams = abi.encode(_owner, _collateral, _bondAmount, _rules, _identifier, _liveness);\r\n        require(_finder != address(0), \"Finder address can not be empty\");\r\n        finder = FinderInterface(_finder);\r\n        setUp(initializeParams);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets up the Optimistic Governor module.\r\n     * @param initializeParams ABI encoded parameters to initialize the module with.\r\n     * @dev This method can be called only either by the constructor or as part of first time initialization when\r\n     * cloning the module.\r\n     */\r\n    function setUp(bytes memory initializeParams) public override initializer {\r\n        _startReentrantGuardDisabled();\r\n        __Ownable_init();\r\n        (\r\n            address _owner,\r\n            address _collateral,\r\n            uint256 _bondAmount,\r\n            string memory _rules,\r\n            bytes32 _identifier,\r\n            uint64 _liveness\r\n        ) = abi.decode(initializeParams, (address, address, uint256, string, bytes32, uint64));\r\n        setCollateralAndBond(IERC20(_collateral), _bondAmount);\r\n        setRules(_rules);\r\n        setIdentifier(_identifier);\r\n        setLiveness(_liveness);\r\n        setAvatar(_owner);\r\n        setTarget(_owner);\r\n        transferOwnership(_owner);\r\n        _sync();\r\n\r\n        emit OptimisticGovernorDeployed(_owner, avatar, target);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the collateral and bond amount for proposals.\r\n     * @param _collateral token that will be used for all bonds for the contract.\r\n     * @param _bondAmount amount of the bond token that will need to be paid for future proposals.\r\n     */\r\n    function setCollateralAndBond(IERC20 _collateral, uint256 _bondAmount) public onlyOwner {\r\n        // ERC20 token to be used as collateral (must be approved by UMA governance).\r\n        require(_getCollateralWhitelist().isOnWhitelist(address(_collateral)), \"Bond token not supported\");\r\n        collateral = _collateral;\r\n\r\n        // Value of the bond posted for asserting the proposed transactions. If the minimum amount required by\r\n        // Optimistic Oracle V3 is higher this contract will attempt to pull the required bond amount.\r\n        bondAmount = _bondAmount;\r\n\r\n        emit SetCollateralAndBond(_collateral, _bondAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the rules that will be used to evaluate future proposals.\r\n     * @param _rules string that outlines or references the location where the rules can be found.\r\n     */\r\n    function setRules(string memory _rules) public onlyOwner {\r\n        // Set reference to the rules for the Optimistic Governor\r\n        require(bytes(_rules).length > 0, \"Rules can not be empty\");\r\n        rules = _rules;\r\n        emit SetRules(_rules);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the liveness for future proposals. This is the amount of delay before a proposal is approved by\r\n     * default.\r\n     * @param _liveness liveness to set in seconds.\r\n     */\r\n    function setLiveness(uint64 _liveness) public onlyOwner {\r\n        // Set liveness for disputing proposed transactions.\r\n        require(_liveness > 0, \"Liveness can't be 0\");\r\n        require(_liveness < 5200 weeks, \"Liveness must be less than 5200 weeks\");\r\n        liveness = _liveness;\r\n        emit SetLiveness(_liveness);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the identifier for future proposals.\r\n     * @param _identifier identifier to set.\r\n     */\r\n    function setIdentifier(bytes32 _identifier) public onlyOwner {\r\n        // Set identifier which is used along with the rules to determine if transactions are valid.\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(_identifier), \"Identifier not supported\");\r\n        identifier = _identifier;\r\n        emit SetIdentifier(_identifier);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the Escalation Manager for future proposals.\r\n     * @param _escalationManager address of the Escalation Manager, can be zero to disable this functionality.\r\n     * @dev Only the owner can call this method. The provided address must conform to the Escalation Manager interface.\r\n     * FullPolicyEscalationManager can be used, but within the context of this contract it should be used only for\r\n     * whitelisting of proposers and disputers since Optimistic Governor is deleting disputed proposals.\r\n     */\r\n    function setEscalationManager(address _escalationManager) external onlyOwner {\r\n        require(_isContract(_escalationManager) || _escalationManager == address(0), \"EM is not a contract\");\r\n        escalationManager = _escalationManager;\r\n        emit SetEscalationManager(_escalationManager);\r\n    }\r\n\r\n    /**\r\n     * @notice This caches the most up-to-date Optimistic Oracle V3.\r\n     * @dev If a new Optimistic Oracle V3 is added and this is run between a proposal's introduction and execution, the\r\n     * proposal will become unexecutable.\r\n     */\r\n    function sync() external nonReentrant {\r\n        _sync();\r\n    }\r\n\r\n    /**\r\n     * @notice Makes a new proposal for transactions to be executed with an explanation argument.\r\n     * @param transactions the transactions being proposed.\r\n     * @param explanation Auxillary information that can be referenced to validate the proposal.\r\n     * @dev Proposer must grant the contract collateral allowance at least to the bondAmount or result of getMinimumBond\r\n     * from the Optimistic Oracle V3, whichever is greater.\r\n     */\r\n    function proposeTransactions(Transaction[] memory transactions, bytes memory explanation) external nonReentrant {\r\n        // note: Optional explanation explains the intent of the transactions to make comprehension easier.\r\n        uint256 time = getCurrentTime();\r\n        address proposer = msg.sender;\r\n\r\n        // Create proposal in memory to emit in an event.\r\n        Proposal memory proposal;\r\n        proposal.requestTime = time;\r\n\r\n        // Add transactions to proposal in memory.\r\n        for (uint256 i = 0; i < transactions.length; i++) {\r\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\r\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\r\n            if (transactions[i].data.length > 0) {\r\n                require(_isContract(transactions[i].to), \"EOA can't accept tx with data\");\r\n            }\r\n        }\r\n        proposal.transactions = transactions;\r\n\r\n        // Create the proposal hash.\r\n        bytes32 proposalHash = keccak256(abi.encode(transactions));\r\n\r\n        // Add the proposal hash, explanation and rules to ancillary data.\r\n        bytes memory claim = _constructClaim(proposalHash, explanation);\r\n\r\n        // Check that the proposal is not already mapped to an assertionId, i.e., is not a duplicate.\r\n        require(assertionIds[proposalHash] == bytes32(0), \"Duplicate proposals not allowed\");\r\n\r\n        // Get the bond from the proposer and approve the required bond to be used by the Optimistic Oracle V3.\r\n        // This will fail if the proposer has not granted the Optimistic Governor contract an allowance\r\n        // of the collateral token equal to or greater than the totalBond.\r\n        uint256 totalBond = getProposalBond();\r\n        collateral.safeTransferFrom(proposer, address(this), totalBond);\r\n        collateral.safeIncreaseAllowance(address(optimisticOracleV3), totalBond);\r\n\r\n        // Assert that the proposal is correct at the Optimistic Oracle V3.\r\n        bytes32 assertionId =\r\n            optimisticOracleV3.assertTruth(\r\n                claim, // claim containing proposalHash, explanation and rules.\r\n                proposer, // asserter will receive back bond if the assertion is correct.\r\n                address(this), // callbackRecipient is set to this contract for automated proposal deletion on disputes.\r\n                escalationManager, // escalationManager (if set) used for whitelisting proposers / disputers.\r\n                liveness, // liveness in seconds.\r\n                collateral, // currency in which the bond is denominated.\r\n                totalBond, // bond amount used to assert proposal.\r\n                identifier, // identifier used to determine if the claim is correct at DVM.\r\n                bytes32(0) // domainId is not set.\r\n            );\r\n\r\n        // Maps the proposal hash to the returned assertionId and vice versa.\r\n        assertionIds[proposalHash] = assertionId;\r\n        proposalHashes[assertionId] = proposalHash;\r\n\r\n        emit TransactionsProposed(\r\n            proposer,\r\n            time,\r\n            assertionId,\r\n            proposal,\r\n            proposalHash,\r\n            explanation,\r\n            rules,\r\n            time + liveness\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Executes an approved proposal.\r\n     * @param transactions the transactions being executed. These must exactly match those that were proposed.\r\n     */\r\n    function executeProposal(Transaction[] memory transactions) external nonReentrant {\r\n        // Recreate the proposal hash from the inputs and check that it matches the stored proposal hash.\r\n        bytes32 proposalHash = keccak256(abi.encode(transactions));\r\n\r\n        // Get the original proposal assertionId.\r\n        bytes32 assertionId = assertionIds[proposalHash];\r\n\r\n        // This will reject the transaction if the proposal hash generated from the inputs does not have the associated\r\n        // assertionId stored. This is possible when a) the transactions have not been proposed, b) transactions have\r\n        // already been executed, c) the proposal was disputed or d) the proposal was deleted after Optimistic Oracle V3\r\n        // upgrade.\r\n        require(assertionId != bytes32(0), \"Proposal hash does not exist\");\r\n\r\n        // Remove proposal hash and assertionId so transactions can not be executed again.\r\n        delete assertionIds[proposalHash];\r\n        delete proposalHashes[assertionId];\r\n\r\n        // There is no need to check the assertion result as this point can be reached only for non-disputed assertions.\r\n        // This will revert if the assertion has not been settled and can not currently be settled.\r\n        optimisticOracleV3.settleAndGetAssertionResult(assertionId);\r\n\r\n        // Execute the transactions.\r\n        for (uint256 i = 0; i < transactions.length; i++) {\r\n            Transaction memory transaction = transactions[i];\r\n\r\n            require(\r\n                exec(transaction.to, transaction.value, transaction.data, transaction.operation),\r\n                \"Failed to execute transaction\"\r\n            );\r\n            emit TransactionExecuted(proposalHash, assertionId, i);\r\n        }\r\n\r\n        emit ProposalExecuted(proposalHash, assertionId);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to delete a proposal on an Optimistic Oracle V3 upgrade.\r\n     * @param proposalHash the hash of the proposal to delete.\r\n     * @dev In case of an Optimistic Oracle V3 upgrade, the proposal execution would be blocked as its related\r\n     * assertionId would not be recognized by the new Optimistic Oracle V3. This function allows the proposal to be\r\n     * deleted if detecting an Optimistic Oracle V3 upgrade so that transactions can be re-proposed if needed.\r\n     */\r\n    function deleteProposalOnUpgrade(bytes32 proposalHash) public nonReentrant {\r\n        require(proposalHash != bytes32(0), \"Invalid proposal hash\");\r\n        bytes32 assertionId = assertionIds[proposalHash];\r\n        require(assertionId != bytes32(0), \"Proposal hash does not exist\");\r\n\r\n        // Detect Optimistic Oracle V3 upgrade by checking if it has the matching assertionId.\r\n        require(optimisticOracleV3.getAssertion(assertionId).asserter == address(0), \"OOv3 upgrade not detected\");\r\n\r\n        // Remove proposal hash and assertionId so that transactions can be re-proposed if needed.\r\n        delete assertionIds[proposalHash];\r\n        delete proposalHashes[assertionId];\r\n\r\n        emit ProposalDeleted(proposalHash, assertionId);\r\n    }\r\n\r\n    /**\r\n     * @notice Callback to automatically delete a proposal that was disputed.\r\n     * @param assertionId the identifier of the disputed assertion.\r\n     */\r\n    function assertionDisputedCallback(bytes32 assertionId) external {\r\n        bytes32 proposalHash = proposalHashes[assertionId];\r\n\r\n        // Callback should only be called by the Optimistic Oracle V3. Address would not match in case of contract\r\n        // upgrade, thus try deleting the proposal through deleteProposalOnUpgrade function that should revert if\r\n        // address mismatch was not caused by an Optimistic Oracle V3 upgrade.\r\n        if (msg.sender == address(optimisticOracleV3)) {\r\n            // Validate the assertionId through existence of non-zero proposalHash. This is the same check as in\r\n            // deleteProposalOnUpgrade method that is called in the else branch.\r\n            require(proposalHash != bytes32(0), \"Invalid proposal hash\");\r\n\r\n            // Delete the disputed proposal and associated assertionId.\r\n            delete assertionIds[proposalHash];\r\n            delete proposalHashes[assertionId];\r\n\r\n            emit ProposalDeleted(proposalHash, assertionId);\r\n        } else deleteProposalOnUpgrade(proposalHash);\r\n    }\r\n\r\n    /**\r\n     * @notice Callback function that is called by Optimistic Oracle V3 when an assertion is resolved.\r\n     * @dev This function does nothing and is only here to satisfy the callback recipient interface.\r\n     * @param assertionId The identifier of the assertion that was resolved.\r\n     * @param assertedTruthfully Whether the assertion was resolved as truthful or not.\r\n     */\r\n    function assertionResolvedCallback(bytes32 assertionId, bool assertedTruthfully) external {}\r\n\r\n    /**\r\n     * @notice Gets the current time for this contract.\r\n     * @dev This only exists so it can be overridden for testing.\r\n     */\r\n    function getCurrentTime() public view virtual returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Getter function to check required collateral currency approval.\r\n     * @return The amount of bond required to propose a transaction.\r\n     */\r\n    function getProposalBond() public view returns (uint256) {\r\n        uint256 minimumBond = optimisticOracleV3.getMinimumBond(address(collateral));\r\n        return minimumBond > bondAmount ? minimumBond : bondAmount;\r\n    }\r\n\r\n    // Gets the address of Collateral Whitelist from the Finder.\r\n    function _getCollateralWhitelist() internal view returns (AddressWhitelistInterface) {\r\n        return AddressWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n    }\r\n\r\n    // Gets the address of Identifier Whitelist from the Finder.\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    // Gets the address of Store contract from the Finder.\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n\r\n    // Caches the address of the Optimistic Oracle V3 from the Finder.\r\n    function _sync() internal {\r\n        address newOptimisticOracleV3 = finder.getImplementationAddress(OracleInterfaces.OptimisticOracleV3);\r\n        if (newOptimisticOracleV3 != address(optimisticOracleV3)) {\r\n            optimisticOracleV3 = OptimisticOracleV3Interface(newOptimisticOracleV3);\r\n            emit OptimisticOracleChanged(newOptimisticOracleV3);\r\n        }\r\n    }\r\n\r\n    // Checks if the address is a contract.\r\n    function _isContract(address addr) internal view returns (bool) {\r\n        return addr.code.length > 0;\r\n    }\r\n\r\n    // Constructs the claim that will be asserted at the Optimistic Oracle V3.\r\n    function _constructClaim(bytes32 proposalHash, bytes memory explanation) internal view returns (bytes memory) {\r\n        return\r\n            abi.encodePacked(\r\n                ClaimData.appendKeyValueBytes32(\"\", PROPOSAL_HASH_KEY, proposalHash),\r\n                \",\",\r\n                EXPLANATION_KEY,\r\n                ':\"',\r\n                explanation,\r\n                '\",',\r\n                RULES_KEY,\r\n                ':\"',\r\n                rules,\r\n                '\"'\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-governor/test/OptimisticGovernorTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../implementation/OptimisticGovernor.sol\";\r\nimport \"../../common/implementation/Testable.sol\";\r\n\r\n// Test contract to add controllable timing to the OptimisticGovernor.\r\ncontract OptimisticGovernorTest is OptimisticGovernor, Testable {\r\n    constructor(\r\n        address _finder,\r\n        address _owner,\r\n        address _collateral,\r\n        uint256 _bond,\r\n        string memory _rules,\r\n        bytes32 _identifier,\r\n        uint64 _liveness,\r\n        address _timerAddress\r\n    ) Testable(_timerAddress) OptimisticGovernor(_finder, _owner, _collateral, _bond, _rules, _identifier, _liveness) {}\r\n\r\n    function getCurrentTime() public view override(OptimisticGovernor, Testable) returns (uint256) {\r\n        return Testable.getCurrentTime();\r\n    }\r\n\r\n    // When deployed as minimal proxy timer address is not initialized.\r\n    function setTimer(address _timerAddress) public {\r\n        timerAddress = _timerAddress;\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-governor/test/TestAvatar.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\ncontract TestAvatar {\r\n    address public module;\r\n\r\n    receive() external payable {}\r\n\r\n    function setModule(address _module) external {\r\n        module = _module;\r\n    }\r\n\r\n    function exec(\r\n        address payable to,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external {\r\n        bool success;\r\n        bytes memory response;\r\n        (success, response) = to.call{ value: value }(data);\r\n        if (!success) {\r\n            assembly {\r\n                revert(add(response, 0x20), mload(response))\r\n            }\r\n        }\r\n    }\r\n\r\n    function execTransactionFromModule(\r\n        address payable to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        uint8 operation\r\n    ) external returns (bool success) {\r\n        require(msg.sender == module, \"Not authorized\");\r\n        if (operation == 1) (success, ) = to.delegatecall(data);\r\n        else (success, ) = to.call{ value: value }(data);\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-governor/test/TestModuleProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.6;\r\n\r\nimport \"@gnosis.pm/zodiac/contracts/factory/ModuleProxyFactory.sol\";\r\n\r\ncontract TestModuleProxyFactory is ModuleProxyFactory {}\r\n"
    },
    "contracts/optimistic-oracle-v2/implementation/OptimisticOracleV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\n\r\nimport \"../interfaces/OptimisticOracleV2Interface.sol\";\r\n\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/implementation/AncillaryData.sol\";\r\nimport \"../../common/implementation/AddressWhitelist.sol\";\r\n\r\n/**\r\n * @title Optimistic Requester.\r\n * @notice Optional interface that requesters can implement to receive callbacks.\r\n * @dev this contract does _not_ work with ERC777 collateral currencies or any others that call into the receiver on\r\n * transfer(). Using an ERC777 token would allow a user to maliciously grief other participants (while also losing\r\n * money themselves).\r\n */\r\ninterface OptimisticRequester {\r\n    /**\r\n     * @notice Callback for proposals.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function priceProposed(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Callback for disputes.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param refund refund received in the case that refundOnDispute was enabled.\r\n     */\r\n    function priceDisputed(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 refund\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Callback for settlement.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param price price that was resolved by the escalation process.\r\n     */\r\n    function priceSettled(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title Optimistic Oracle.\r\n * @notice Pre-DVM escalation contract that allows faster settlement.\r\n */\r\ncontract OptimisticOracleV2 is OptimisticOracleV2Interface, Testable, Lockable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    // Finder to provide addresses for DVM contracts.\r\n    FinderInterface public override finder;\r\n\r\n    // Default liveness value for all price requests.\r\n    uint256 public override defaultLiveness;\r\n\r\n    // This is effectively the extra ancillary data to add \",ooRequester:0000000000000000000000000000000000000000\".\r\n    uint256 private constant MAX_ADDED_ANCILLARY_DATA = 53;\r\n    uint256 public constant OO_ANCILLARY_DATA_LIMIT = ancillaryBytesLimit - MAX_ADDED_ANCILLARY_DATA;\r\n    int256 public constant TOO_EARLY_RESPONSE = type(int256).min;\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _liveness default liveness applied to each price request.\r\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\r\n     * @param _timerAddress address of the timer contract. Should be 0x0 in prod.\r\n     */\r\n    constructor(\r\n        uint256 _liveness,\r\n        address _finderAddress,\r\n        address _timerAddress\r\n    ) Testable(_timerAddress) {\r\n        finder = FinderInterface(_finderAddress);\r\n        _validateLiveness(_liveness);\r\n        defaultLiveness = _liveness;\r\n    }\r\n\r\n    /**\r\n     * @notice Requests a new price.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\r\n     * This can be changed with a subsequent call to setBond().\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward\r\n    ) external override nonReentrant() returns (uint256 totalBond) {\r\n        require(_getState(msg.sender, identifier, timestamp, ancillaryData) == State.Invalid, \"requestPrice: Invalid\");\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\r\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\r\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\r\n\r\n        // This ensures that the ancillary data is <= the OO limit, which is lower than the DVM limit because the\r\n        // OO adds some data before sending to the DVM.\r\n        require(ancillaryData.length <= OO_ANCILLARY_DATA_LIMIT, \"Ancillary Data too long\");\r\n\r\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\r\n        requests[_getId(msg.sender, identifier, timestamp, ancillaryData)] = Request({\r\n            proposer: address(0),\r\n            disputer: address(0),\r\n            currency: currency,\r\n            settled: false,\r\n            requestSettings: RequestSettings({\r\n                eventBased: false,\r\n                refundOnDispute: false,\r\n                callbackOnPriceProposed: false,\r\n                callbackOnPriceDisputed: false,\r\n                callbackOnPriceSettled: false,\r\n                bond: finalFee,\r\n                customLiveness: 0\r\n            }),\r\n            proposedPrice: 0,\r\n            resolvedPrice: 0,\r\n            expirationTime: 0,\r\n            reward: reward,\r\n            finalFee: finalFee\r\n        });\r\n\r\n        if (reward > 0) {\r\n            currency.safeTransferFrom(msg.sender, address(this), reward);\r\n        }\r\n\r\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, address(currency), reward, finalFee);\r\n\r\n        // This function returns the initial proposal bond for this request, which can be customized by calling\r\n        // setBond() with the same identifier and timestamp.\r\n        return finalFee.mul(2);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the proposal bond associated with a price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param bond custom bond amount to set.\r\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\r\n     * changed again with a subsequent call to setBond().\r\n     */\r\n    function setBond(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 bond\r\n    ) external override nonReentrant() returns (uint256 totalBond) {\r\n        require(_getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested, \"setBond: Requested\");\r\n        Request storage request = _getRequest(msg.sender, identifier, timestamp, ancillaryData);\r\n        request.requestSettings.bond = bond;\r\n\r\n        // Total bond is the final fee + the newly set bond.\r\n        return bond.add(request.finalFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\r\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\r\n     * bond, so there is still profit to be made even if the reward is refunded.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function setRefundOnDispute(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override nonReentrant() {\r\n        require(\r\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\r\n            \"setRefundOnDispute: Requested\"\r\n        );\r\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).requestSettings.refundOnDispute = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\r\n     * being auto-resolved.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param customLiveness new custom liveness.\r\n     */\r\n    function setCustomLiveness(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 customLiveness\r\n    ) external override nonReentrant() {\r\n        require(\r\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\r\n            \"setCustomLiveness: Requested\"\r\n        );\r\n        _validateLiveness(customLiveness);\r\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).requestSettings.customLiveness = customLiveness;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the request to be an \"event-based\" request.\r\n     * @dev Calling this method has a few impacts on the request:\r\n     *\r\n     * 1. The timestamp at which the request is evaluated is the time of the proposal, not the timestamp associated\r\n     *    with the request.\r\n     *\r\n     * 2. The proposer cannot propose the \"too early\" value (TOO_EARLY_RESPONSE). This is to ensure that a proposer who\r\n     *    prematurely proposes a response loses their bond.\r\n     *\r\n     * 3. RefundoOnDispute is automatically set, meaning disputes trigger the reward to be automatically refunded to\r\n     *    the requesting contract.\r\n     *\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function setEventBased(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override nonReentrant() {\r\n        require(\r\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\r\n            \"setEventBased: Requested\"\r\n        );\r\n        Request storage request = _getRequest(msg.sender, identifier, timestamp, ancillaryData);\r\n        request.requestSettings.eventBased = true;\r\n        request.requestSettings.refundOnDispute = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets which callbacks should be enabled for the request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param callbackOnPriceProposed whether to enable the callback onPriceProposed.\r\n     * @param callbackOnPriceDisputed whether to enable the callback onPriceDisputed.\r\n     * @param callbackOnPriceSettled whether to enable the callback onPriceSettled.\r\n     */\r\n    function setCallbacks(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        bool callbackOnPriceProposed,\r\n        bool callbackOnPriceDisputed,\r\n        bool callbackOnPriceSettled\r\n    ) external override nonReentrant() {\r\n        require(\r\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\r\n            \"setCallbacks: Requested\"\r\n        );\r\n        Request storage request = _getRequest(msg.sender, identifier, timestamp, ancillaryData);\r\n        request.requestSettings.callbackOnPriceProposed = callbackOnPriceProposed;\r\n        request.requestSettings.callbackOnPriceDisputed = callbackOnPriceDisputed;\r\n        request.requestSettings.callbackOnPriceSettled = callbackOnPriceSettled;\r\n    }\r\n\r\n    /**\r\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\r\n     * from this proposal. However, any bonds are pulled from the caller.\r\n     * @param proposer address to set as the proposer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePriceFor(\r\n        address proposer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) public override nonReentrant() returns (uint256 totalBond) {\r\n        require(proposer != address(0), \"proposer address must be non 0\");\r\n        require(\r\n            _getState(requester, identifier, timestamp, ancillaryData) == State.Requested,\r\n            \"proposePriceFor: Requested\"\r\n        );\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n        if (request.requestSettings.eventBased)\r\n            require(proposedPrice != TOO_EARLY_RESPONSE, \"Cannot propose 'too early'\");\r\n        request.proposer = proposer;\r\n        request.proposedPrice = proposedPrice;\r\n\r\n        // If a custom liveness has been set, use it instead of the default.\r\n        request.expirationTime = getCurrentTime().add(\r\n            request.requestSettings.customLiveness != 0 ? request.requestSettings.customLiveness : defaultLiveness\r\n        );\r\n\r\n        totalBond = request.requestSettings.bond.add(request.finalFee);\r\n        if (totalBond > 0) request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n\r\n        emit ProposePrice(\r\n            requester,\r\n            proposer,\r\n            identifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            proposedPrice,\r\n            request.expirationTime,\r\n            address(request.currency)\r\n        );\r\n\r\n        // End the re-entrancy guard early to allow the caller to potentially take OO-related actions inside this callback.\r\n        _startReentrantGuardDisabled();\r\n        // Callback.\r\n        if (address(requester).isContract() && request.requestSettings.callbackOnPriceProposed)\r\n            OptimisticRequester(requester).priceProposed(identifier, timestamp, ancillaryData);\r\n        _endReentrantGuardDisabled();\r\n    }\r\n\r\n    /**\r\n     * @notice Proposes a price value for an existing price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) external override returns (uint256 totalBond) {\r\n        // Note: re-entrancy guard is done in the inner call.\r\n        return proposePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData, proposedPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\r\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\r\n     * @param disputer address to set as the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePriceFor(\r\n        address disputer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public override nonReentrant() returns (uint256 totalBond) {\r\n        require(disputer != address(0), \"disputer address must be non 0\");\r\n        require(\r\n            _getState(requester, identifier, timestamp, ancillaryData) == State.Proposed,\r\n            \"disputePriceFor: Proposed\"\r\n        );\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n        request.disputer = disputer;\r\n\r\n        uint256 finalFee = request.finalFee;\r\n        uint256 bond = request.requestSettings.bond;\r\n        totalBond = bond.add(finalFee);\r\n        if (totalBond > 0) {\r\n            request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n        }\r\n\r\n        StoreInterface store = _getStore();\r\n\r\n        // Along with the final fee, \"burn\" part of the loser's bond to ensure that a larger bond always makes it\r\n        // proportionally more expensive to delay the resolution even if the proposer and disputer are the same\r\n        // party.\r\n\r\n        // The total fee is the burned bond and the final fee added together.\r\n        uint256 totalFee = finalFee.add(_computeBurnedBond(request));\r\n        if (totalFee > 0) {\r\n            request.currency.safeIncreaseAllowance(address(store), totalFee);\r\n            _getStore().payOracleFeesErc20(address(request.currency), FixedPoint.Unsigned(totalFee));\r\n        }\r\n\r\n        _getOracle().requestPrice(\r\n            identifier,\r\n            _getTimestampForDvmRequest(request, timestamp),\r\n            _stampAncillaryData(ancillaryData, requester)\r\n        );\r\n\r\n        // Compute refund.\r\n        uint256 refund = 0;\r\n        if (request.reward > 0 && request.requestSettings.refundOnDispute) {\r\n            refund = request.reward;\r\n            request.reward = 0;\r\n            request.currency.safeTransfer(requester, refund);\r\n        }\r\n\r\n        emit DisputePrice(\r\n            requester,\r\n            request.proposer,\r\n            disputer,\r\n            identifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            request.proposedPrice\r\n        );\r\n\r\n        // End the re-entrancy guard early to allow the caller to potentially re-request inside this callback.\r\n        _startReentrantGuardDisabled();\r\n        // Callback.\r\n        if (address(requester).isContract() && request.requestSettings.callbackOnPriceDisputed)\r\n            OptimisticRequester(requester).priceDisputed(identifier, timestamp, ancillaryData, refund);\r\n        _endReentrantGuardDisabled();\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a price value for an existing price request with an active proposal.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override returns (uint256 totalBond) {\r\n        // Note: re-entrancy guard is done in the inner call.\r\n        return disputePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\r\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\r\n     * hasn't been settled.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return resolved price.\r\n     */\r\n    function settleAndGetPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override nonReentrant() returns (int256) {\r\n        if (_getState(msg.sender, identifier, timestamp, ancillaryData) != State.Settled) {\r\n            _settle(msg.sender, identifier, timestamp, ancillaryData);\r\n        }\r\n\r\n        return _getRequest(msg.sender, identifier, timestamp, ancillaryData).resolvedPrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\r\n     * the returned bonds as well as additional rewards.\r\n     */\r\n    function settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override nonReentrant() returns (uint256 payout) {\r\n        return _settle(requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current data structure containing all information about a price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the Request data structure.\r\n     */\r\n    function getRequest(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() returns (Request memory) {\r\n        return _getRequest(requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the current state of a price request. See the State enum for more details.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the State.\r\n     */\r\n    function getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() returns (State) {\r\n        return _getState(requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return boolean indicating true if price exists and false if not.\r\n     */\r\n    function hasPrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() returns (bool) {\r\n        State state = _getState(requester, identifier, timestamp, ancillaryData);\r\n        return state == State.Settled || state == State.Resolved || state == State.Expired;\r\n    }\r\n\r\n    /**\r\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param requester sender of the initial price request.\r\n     * @return the stamped ancillary bytes.\r\n     */\r\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\r\n        public\r\n        pure\r\n        override\r\n        returns (bytes memory)\r\n    {\r\n        return _stampAncillaryData(ancillaryData, requester);\r\n    }\r\n\r\n    function _getId(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) private pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(requester, identifier, timestamp, ancillaryData));\r\n    }\r\n\r\n    function _settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) private returns (uint256 payout) {\r\n        State state = _getState(requester, identifier, timestamp, ancillaryData);\r\n\r\n        // Set it to settled so this function can never be entered again.\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n        request.settled = true;\r\n\r\n        if (state == State.Expired) {\r\n            // In the expiry case, just pay back the proposer's bond and final fee along with the reward.\r\n            request.resolvedPrice = request.proposedPrice;\r\n            payout = request.requestSettings.bond.add(request.finalFee).add(request.reward);\r\n            request.currency.safeTransfer(request.proposer, payout);\r\n        } else if (state == State.Resolved) {\r\n            // In the Resolved case, pay either the disputer or the proposer the entire payout (+ bond and reward).\r\n            request.resolvedPrice = _getOracle().getPrice(\r\n                identifier,\r\n                _getTimestampForDvmRequest(request, timestamp),\r\n                _stampAncillaryData(ancillaryData, requester)\r\n            );\r\n            bool disputeSuccess = request.resolvedPrice != request.proposedPrice;\r\n            uint256 bond = request.requestSettings.bond;\r\n\r\n            // Unburned portion of the loser's bond = 1 - burned bond.\r\n            uint256 unburnedBond = bond.sub(_computeBurnedBond(request));\r\n\r\n            // Winner gets:\r\n            // - Their bond back.\r\n            // - The unburned portion of the loser's bond.\r\n            // - Their final fee back.\r\n            // - The request reward (if not already refunded -- if refunded, it will be set to 0).\r\n            payout = bond.add(unburnedBond).add(request.finalFee).add(request.reward);\r\n            request.currency.safeTransfer(disputeSuccess ? request.disputer : request.proposer, payout);\r\n        } else revert(\"_settle: not settleable\");\r\n\r\n        emit Settle(\r\n            requester,\r\n            request.proposer,\r\n            request.disputer,\r\n            identifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            request.resolvedPrice,\r\n            payout\r\n        );\r\n\r\n        // Temporarily disable the re-entrancy guard early to allow the caller to take an OO-related action inside this callback.\r\n        _startReentrantGuardDisabled();\r\n        // Callback.\r\n        if (address(requester).isContract() && request.requestSettings.callbackOnPriceSettled)\r\n            OptimisticRequester(requester).priceSettled(identifier, timestamp, ancillaryData, request.resolvedPrice);\r\n        _endReentrantGuardDisabled();\r\n    }\r\n\r\n    function _getRequest(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) private view returns (Request storage) {\r\n        return requests[_getId(requester, identifier, timestamp, ancillaryData)];\r\n    }\r\n\r\n    function _computeBurnedBond(Request storage request) private view returns (uint256) {\r\n        // burnedBond = floor(bond / 2)\r\n        return request.requestSettings.bond.div(2);\r\n    }\r\n\r\n    function _validateLiveness(uint256 _liveness) private pure {\r\n        require(_liveness < 5200 weeks, \"Liveness too large\");\r\n        require(_liveness > 0, \"Liveness cannot be 0\");\r\n    }\r\n\r\n    function _getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) internal view returns (State) {\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n\r\n        if (address(request.currency) == address(0)) return State.Invalid;\r\n\r\n        if (request.proposer == address(0)) return State.Requested;\r\n\r\n        if (request.settled) return State.Settled;\r\n\r\n        if (request.disputer == address(0))\r\n            return request.expirationTime <= getCurrentTime() ? State.Expired : State.Proposed;\r\n\r\n        return\r\n            _getOracle().hasPrice(\r\n                identifier,\r\n                _getTimestampForDvmRequest(request, timestamp),\r\n                _stampAncillaryData(ancillaryData, requester)\r\n            )\r\n                ? State.Resolved\r\n                : State.Disputed;\r\n    }\r\n\r\n    function _getOracle() internal view returns (OracleAncillaryInterface) {\r\n        return OracleAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n\r\n    function _getCollateralWhitelist() internal view returns (AddressWhitelist) {\r\n        return AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n    }\r\n\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    function _getTimestampForDvmRequest(Request storage request, uint256 requestTimestamp)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (request.requestSettings.eventBased) {\r\n            uint256 liveness =\r\n                request.requestSettings.customLiveness != 0 ? request.requestSettings.customLiveness : defaultLiveness;\r\n            return request.expirationTime.sub(liveness);\r\n        } else {\r\n            return requestTimestamp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev We don't handle specifically the case where `ancillaryData` is not already readily translateable in utf8.\r\n     * For those cases, we assume that the client will be able to strip out the utf8-translateable part of the\r\n     * ancillary data that this contract stamps.\r\n     */\r\n    function _stampAncillaryData(bytes memory ancillaryData, address requester) internal pure returns (bytes memory) {\r\n        // Since this contract will be the one to formally submit DVM price requests, its useful for voters to know who\r\n        // the original requester was.\r\n        return AncillaryData.appendKeyValueAddress(ancillaryData, \"ooRequester\", requester);\r\n    }\r\n\r\n    function getCurrentTime() public view override(Testable, OptimisticOracleV2Interface) returns (uint256) {\r\n        return Testable.getCurrentTime();\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v2/implementation/SkinnyOptimisticOracleV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../interfaces/OptimisticOracleInterface.sol\";\r\nimport \"../interfaces/SkinnyOptimisticOracleV2Interface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\n\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/implementation/AncillaryData.sol\";\r\nimport \"../../common/implementation/AddressWhitelist.sol\";\r\n\r\n/**\r\n * @title Optimistic Requester.\r\n * @notice Optional interface that requesters can implement to receive callbacks.\r\n * @dev This contract does _not_ work with ERC777 collateral currencies or any others that call into the receiver on\r\n * transfer(). Using an ERC777 token would allow a user to maliciously grief other participants (while also losing\r\n * money themselves).\r\n */\r\ninterface OptimisticRequesterV2 {\r\n    /**\r\n     * @notice Callback for proposals.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request request params after proposal.\r\n     */\r\n    function priceProposed(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        SkinnyOptimisticOracleV2Interface.Request memory request\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Callback for disputes.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request request params after dispute.\r\n     */\r\n    function priceDisputed(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        SkinnyOptimisticOracleV2Interface.Request memory request\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Callback for settlement.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request request params after settlement.\r\n     */\r\n    function priceSettled(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        SkinnyOptimisticOracleV2Interface.Request memory request\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title Optimistic Oracle with a different interface and fewer features that emphasizes gas cost reductions.\r\n * @notice Pre-DVM escalation contract that allows faster settlement.\r\n */\r\ncontract SkinnyOptimisticOracleV2 is SkinnyOptimisticOracleV2Interface, Testable, Lockable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    event RequestPrice(\r\n        address indexed requester,\r\n        bytes32 indexed identifier,\r\n        uint32 timestamp,\r\n        bytes ancillaryData,\r\n        Request request\r\n    );\r\n    event ProposePrice(\r\n        address indexed requester,\r\n        bytes32 indexed identifier,\r\n        uint32 timestamp,\r\n        bytes ancillaryData,\r\n        Request request\r\n    );\r\n    event DisputePrice(\r\n        address indexed requester,\r\n        bytes32 indexed identifier,\r\n        uint32 timestamp,\r\n        bytes ancillaryData,\r\n        Request request\r\n    );\r\n    event Settle(\r\n        address indexed requester,\r\n        bytes32 indexed identifier,\r\n        uint32 timestamp,\r\n        bytes ancillaryData,\r\n        Request request\r\n    );\r\n\r\n    // Maps hash of unique request params {identifier, timestamp, ancillary data} to customizable variables such as\r\n    // reward and bond amounts.\r\n    mapping(bytes32 => bytes32) public requests;\r\n\r\n    // Finder to provide addresses for DVM contracts.\r\n    FinderInterface public finder;\r\n\r\n    // Default liveness value for all price requests.\r\n    uint256 public defaultLiveness;\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _liveness default liveness applied to each price request.\r\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\r\n     * @param _timerAddress address of the timer contract. Should be 0x0 in prod.\r\n     */\r\n    constructor(\r\n        uint256 _liveness,\r\n        address _finderAddress,\r\n        address _timerAddress\r\n    ) Testable(_timerAddress) {\r\n        finder = FinderInterface(_finderAddress);\r\n        _validateLiveness(_liveness);\r\n        defaultLiveness = _liveness;\r\n    }\r\n\r\n    /**\r\n     * @notice Requests a new price.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @param requestSettings settings for the request.\r\n     * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        RequestSettings memory requestSettings\r\n    ) external override nonReentrant() returns (uint256 totalBond) {\r\n        bytes32 requestId = _getId(msg.sender, identifier, timestamp, ancillaryData);\r\n        require(requests[requestId] == bytes32(0), \"Request already initialized\");\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\r\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\r\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\r\n        require(\r\n            _stampAncillaryData(ancillaryData, msg.sender).length <= ancillaryBytesLimit,\r\n            \"Ancillary Data too long\"\r\n        );\r\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\r\n\r\n        // Associate new request with ID\r\n        Request memory request;\r\n        request.currency = currency;\r\n        request.reward = reward;\r\n        request.finalFee = finalFee;\r\n        request.requestSettings = requestSettings;\r\n        request.requestSettings.bond = requestSettings.bond != 0 ? requestSettings.bond : finalFee;\r\n        _storeRequestHash(requestId, request);\r\n\r\n        if (reward > 0) currency.safeTransferFrom(msg.sender, address(this), reward);\r\n\r\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, request);\r\n\r\n        return request.requestSettings.bond.add(finalFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\r\n     * from this proposal. However, any bonds are pulled from the caller.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * propose a price for.\r\n     * @param proposer address to set as the proposer.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePriceFor(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        address proposer,\r\n        int256 proposedPrice\r\n    ) public override nonReentrant() returns (uint256 totalBond) {\r\n        require(proposer != address(0), \"Proposer address must be non 0\");\r\n        require(\r\n            _getState(requester, identifier, timestamp, ancillaryData, request) ==\r\n                OptimisticOracleInterface.State.Requested,\r\n            \"Must be requested\"\r\n        );\r\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\r\n        _validateRequestHash(requestId, request);\r\n\r\n        // Associate newly proposed request params with ID\r\n        Request memory proposedRequest =\r\n            Request({\r\n                proposer: proposer, // Modified\r\n                disputer: request.disputer,\r\n                currency: request.currency,\r\n                settled: request.settled,\r\n                proposedPrice: proposedPrice, // Modified\r\n                resolvedPrice: request.resolvedPrice,\r\n                expirationTime: getCurrentTime().add(\r\n                    request.requestSettings.customLiveness != 0\r\n                        ? request.requestSettings.customLiveness\r\n                        : defaultLiveness\r\n                ), // Modified\r\n                reward: request.reward,\r\n                finalFee: request.finalFee,\r\n                requestSettings: request.requestSettings\r\n            });\r\n        _storeRequestHash(requestId, proposedRequest);\r\n\r\n        totalBond = request.requestSettings.bond.add(request.finalFee);\r\n        if (totalBond > 0) request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n\r\n        emit ProposePrice(requester, identifier, timestamp, ancillaryData, proposedRequest);\r\n\r\n        // Callback.\r\n        if (address(requester).isContract() && request.requestSettings.callbackOnPriceProposed)\r\n            OptimisticRequesterV2(requester).priceProposed(identifier, timestamp, ancillaryData, proposedRequest);\r\n    }\r\n\r\n    /**\r\n     * @notice Proposes a price value where caller is the proposer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * propose a price for.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        int256 proposedPrice\r\n    ) external override returns (uint256 totalBond) {\r\n        // Note: re-entrancy guard is done in the inner call.\r\n        return proposePriceFor(requester, identifier, timestamp, ancillaryData, request, msg.sender, proposedPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\r\n     * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\r\n     * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\r\n     * @dev The caller is the requester, but the proposer can be customized.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @param requestSettings settings for the request.\r\n     * @param proposer address to set as the proposer.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function requestAndProposePriceFor(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        RequestSettings memory requestSettings,\r\n        address proposer,\r\n        int256 proposedPrice\r\n    ) external override nonReentrant() returns (uint256 totalBond) {\r\n        bytes32 requestId = _getId(msg.sender, identifier, timestamp, ancillaryData);\r\n        require(requests[requestId] == bytes32(0), \"Request already initialized\");\r\n        require(proposer != address(0), \"proposer address must be non 0\");\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\r\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\r\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\r\n        require(\r\n            _stampAncillaryData(ancillaryData, msg.sender).length <= ancillaryBytesLimit,\r\n            \"Ancillary Data too long\"\r\n        );\r\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\r\n\r\n        // Associate new request with ID\r\n        Request memory request;\r\n        request.currency = currency;\r\n        request.reward = reward;\r\n        request.finalFee = finalFee;\r\n        request.requestSettings = requestSettings;\r\n        request.requestSettings.bond = requestSettings.bond != 0 ? requestSettings.bond : finalFee;\r\n        request.proposer = proposer;\r\n        request.proposedPrice = proposedPrice;\r\n        request.expirationTime = getCurrentTime().add(\r\n            requestSettings.customLiveness != 0 ? requestSettings.customLiveness : defaultLiveness\r\n        );\r\n        _storeRequestHash(requestId, request);\r\n\r\n        // Pull reward from requester, who is the caller.\r\n        if (reward > 0) currency.safeTransferFrom(msg.sender, address(this), reward);\r\n        // Pull proposal bond from caller.\r\n        totalBond = request.requestSettings.bond.add(request.finalFee);\r\n        if (totalBond > 0) currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n\r\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, request);\r\n        emit ProposePrice(msg.sender, identifier, timestamp, ancillaryData, request);\r\n\r\n        // Callback.\r\n        if (address(msg.sender).isContract() && requestSettings.callbackOnPriceProposed)\r\n            OptimisticRequesterV2(msg.sender).priceProposed(identifier, timestamp, ancillaryData, request);\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\r\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     *              dispute.\r\n     * @param disputer address to set as the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePriceFor(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        address disputer,\r\n        address requester\r\n    ) public override nonReentrant() returns (uint256 totalBond) {\r\n        require(disputer != address(0), \"disputer address must be non 0\");\r\n        require(\r\n            _getState(requester, identifier, timestamp, ancillaryData, request) ==\r\n                OptimisticOracleInterface.State.Proposed,\r\n            \"Must be proposed\"\r\n        );\r\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\r\n        _validateRequestHash(requestId, request);\r\n\r\n        // Associate newly disputed request params with ID\r\n        Request memory disputedRequest =\r\n            Request({\r\n                proposer: request.proposer,\r\n                disputer: disputer, // Modified\r\n                currency: request.currency,\r\n                settled: request.settled,\r\n                proposedPrice: request.proposedPrice,\r\n                resolvedPrice: request.resolvedPrice,\r\n                expirationTime: request.expirationTime,\r\n                reward: request.reward,\r\n                finalFee: request.finalFee,\r\n                requestSettings: request.requestSettings\r\n            });\r\n        _storeRequestHash(requestId, disputedRequest);\r\n\r\n        totalBond = request.requestSettings.bond.add(request.finalFee);\r\n        if (totalBond > 0) request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n\r\n        StoreInterface store = _getStore();\r\n\r\n        // Avoids stack too deep compilation error.\r\n        {\r\n            // Along with the final fee, \"burn\" part of the loser's bond to ensure that a larger bond always makes it\r\n            // proportionally more expensive to delay the resolution even if the proposer and disputer are the same\r\n            // party.\r\n            uint256 burnedBond = _computeBurnedBond(disputedRequest);\r\n\r\n            // The total fee is the burned bond and the final fee added together.\r\n            uint256 totalFee = request.finalFee.add(burnedBond);\r\n\r\n            if (totalFee > 0) {\r\n                request.currency.safeIncreaseAllowance(address(store), totalFee);\r\n                _getStore().payOracleFeesErc20(address(request.currency), FixedPoint.Unsigned(totalFee));\r\n            }\r\n        }\r\n\r\n        _getOracle().requestPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester));\r\n\r\n        emit DisputePrice(requester, identifier, timestamp, ancillaryData, disputedRequest);\r\n\r\n        // Callback.\r\n        if (address(requester).isContract() && request.requestSettings.callbackOnPriceDisputed)\r\n            OptimisticRequesterV2(requester).priceDisputed(identifier, timestamp, ancillaryData, disputedRequest);\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal where caller is the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     *             dispute.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external override returns (uint256 totalBond) {\r\n        // Note: re-entrancy guard is done in the inner call.\r\n        return disputePriceFor(identifier, timestamp, ancillaryData, request, msg.sender, requester);\r\n    }\r\n\r\n    /**\r\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     *              settle.\r\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\r\n     * the returned bonds as well as additional rewards.\r\n     * @return resolvedPrice the price that the request settled to.\r\n     */\r\n    function settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external override nonReentrant() returns (uint256 payout, int256 resolvedPrice) {\r\n        return _settle(requester, identifier, timestamp, ancillaryData, request);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the current state of a price request. See the State enum for more details.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters.\r\n     * @return the State.\r\n     */\r\n    function getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external override nonReentrant() returns (OptimisticOracleInterface.State) {\r\n        return _getState(requester, identifier, timestamp, ancillaryData, request);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters. The hash of these parameters must match with the request hash that is\r\n     * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\r\n     * will revert.\r\n     * @return boolean indicating true if price exists and false if not.\r\n     */\r\n    function hasPrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) public override nonReentrant() returns (bool) {\r\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\r\n        _validateRequestHash(requestId, request);\r\n        OptimisticOracleInterface.State state = _getState(requester, identifier, timestamp, ancillaryData, request);\r\n        return\r\n            state == OptimisticOracleInterface.State.Settled ||\r\n            state == OptimisticOracleInterface.State.Resolved ||\r\n            state == OptimisticOracleInterface.State.Expired;\r\n    }\r\n\r\n    /**\r\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param requester sender of the initial price request.\r\n     * @return the stamped ancillary bytes.\r\n     */\r\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\r\n        public\r\n        pure\r\n        override\r\n        returns (bytes memory)\r\n    {\r\n        return _stampAncillaryData(ancillaryData, requester);\r\n    }\r\n\r\n    /****************************************\r\n     *    PRIVATE AND INTERNAL FUNCTIONS    *\r\n     ****************************************/\r\n    // Returns hash of unique request identifiers. This contract maps request ID hashes to hashes of the request's\r\n    // parameters.\r\n    function _getId(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData\r\n    ) private pure returns (bytes32) {\r\n        return keccak256(abi.encode(requester, identifier, timestamp, ancillaryData));\r\n    }\r\n\r\n    // Returns hash of request parameters. These are mapped to the unique request ID to track a request's lifecycle.\r\n    function _getRequestHash(Request memory request) private pure returns (bytes32) {\r\n        return keccak256(abi.encode(request));\r\n    }\r\n\r\n    // Resolves a price request that has expired or been disputed and a price is available from the DVM. This will\r\n    // revert if the unique request ID does not match the hashed request parameters. This also marks the request\r\n    // as settled, therefore this method can only be triggered once per eligible request.\r\n    function _settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) private returns (uint256 payout, int256 resolvedPrice) {\r\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\r\n        _validateRequestHash(requestId, request);\r\n\r\n        // Associate settled request params with ID.\r\n        Request memory settledRequest =\r\n            Request({\r\n                proposer: request.proposer,\r\n                disputer: request.disputer,\r\n                currency: request.currency,\r\n                settled: true, // Modified\r\n                proposedPrice: request.proposedPrice,\r\n                resolvedPrice: request.resolvedPrice,\r\n                expirationTime: request.expirationTime,\r\n                reward: request.reward,\r\n                finalFee: request.finalFee,\r\n                requestSettings: request.requestSettings\r\n            });\r\n\r\n        OptimisticOracleInterface.State state = _getState(requester, identifier, timestamp, ancillaryData, request);\r\n        if (state == OptimisticOracleInterface.State.Expired) {\r\n            // In the expiry case, just pay back the proposer's bond and final fee along with the reward.\r\n            resolvedPrice = request.proposedPrice;\r\n            settledRequest.resolvedPrice = resolvedPrice;\r\n            payout = request.requestSettings.bond.add(request.finalFee).add(request.reward);\r\n            request.currency.safeTransfer(request.proposer, payout);\r\n        } else if (state == OptimisticOracleInterface.State.Resolved) {\r\n            // In the Resolved case, pay either the disputer or the proposer the entire payout (+ bond and reward).\r\n            resolvedPrice = _getOracle().getPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester));\r\n            settledRequest.resolvedPrice = resolvedPrice;\r\n            bool disputeSuccess = settledRequest.resolvedPrice != request.proposedPrice;\r\n\r\n            // Winner gets:\r\n            // - Their bond back.\r\n            // - The unburned portion of the loser's bond: proposal bond (not including final fee) - burned bond.\r\n            // - Their final fee back.\r\n            // - The request reward (if not already refunded -- if refunded, it will be set to 0).\r\n            payout = request\r\n                .requestSettings\r\n                .bond\r\n                .add(request.requestSettings.bond.sub(_computeBurnedBond(settledRequest)))\r\n                .add(request.finalFee)\r\n                .add(request.reward);\r\n            request.currency.safeTransfer(disputeSuccess ? request.disputer : request.proposer, payout);\r\n        } else {\r\n            revert(\"Already settled or not settleable\");\r\n        }\r\n\r\n        _storeRequestHash(requestId, settledRequest);\r\n        emit Settle(requester, identifier, timestamp, ancillaryData, settledRequest);\r\n\r\n        // Callback.\r\n        if (address(requester).isContract() && request.requestSettings.callbackOnPriceSettled)\r\n            OptimisticRequesterV2(requester).priceSettled(identifier, timestamp, ancillaryData, settledRequest);\r\n    }\r\n\r\n    function _computeBurnedBond(Request memory request) private pure returns (uint256) {\r\n        // burnedBond = floor(bond / 2)\r\n        return request.requestSettings.bond.div(2);\r\n    }\r\n\r\n    function _validateLiveness(uint256 liveness) private pure {\r\n        require(liveness < 5200 weeks, \"Liveness too large\");\r\n        require(liveness > 0, \"Liveness cannot be 0\");\r\n    }\r\n\r\n    function _validateRequestHash(bytes32 requestId, Request memory request) private view {\r\n        require(\r\n            requests[requestId] == _getRequestHash(request),\r\n            \"Hashed request params do not match existing request hash\"\r\n        );\r\n    }\r\n\r\n    function _storeRequestHash(bytes32 requestId, Request memory request) internal {\r\n        requests[requestId] = _getRequestHash(request);\r\n    }\r\n\r\n    function _getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) internal view returns (OptimisticOracleInterface.State) {\r\n        // Note: This function does not check whether all of the _request parameter values are correct. For example,\r\n        // the request.reward could be any value and it would not impact this function's return value. Therefore, it\r\n        // is the caller's responsibility to check that _request matches with the expected ID corresponding to\r\n        // {requester, identifier, timestamp, ancillaryData} via _validateRequestHash().\r\n        if (address(request.currency) == address(0)) return OptimisticOracleInterface.State.Invalid;\r\n\r\n        if (request.proposer == address(0)) return OptimisticOracleInterface.State.Requested;\r\n\r\n        if (request.settled) return OptimisticOracleInterface.State.Settled;\r\n\r\n        if (request.disputer == address(0))\r\n            return\r\n                request.expirationTime <= getCurrentTime()\r\n                    ? OptimisticOracleInterface.State.Expired\r\n                    : OptimisticOracleInterface.State.Proposed;\r\n\r\n        return\r\n            _getOracle().hasPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester))\r\n                ? OptimisticOracleInterface.State.Resolved\r\n                : OptimisticOracleInterface.State.Disputed;\r\n    }\r\n\r\n    function _getOracle() internal view returns (OracleAncillaryInterface) {\r\n        return OracleAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n\r\n    function _getCollateralWhitelist() internal view returns (AddressWhitelist) {\r\n        return AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n    }\r\n\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    /**\r\n     * @dev We don't handle specifically the case where `ancillaryData` is not already readily translateable in utf8.\r\n     * For those cases, we assume that the client will be able to strip out the utf8-translateable part of the\r\n     * ancillary data that this contract stamps.\r\n     */\r\n    function _stampAncillaryData(bytes memory ancillaryData, address requester) internal pure returns (bytes memory) {\r\n        // Since this contract will be the one to formally submit DVM price requests, its useful for voters to know who\r\n        // the original requester was.\r\n        return AncillaryData.appendKeyValueAddress(ancillaryData, \"ooRequester\", requester);\r\n    }\r\n}\r\n\r\n/**\r\n * @notice This is the SkinnyOptimisticOracle contract that should be deployed on live networks. It is exactly the same\r\n * as the regular SkinnyOptimisticOracle contract, but it overrides getCurrentTime to make the call a simply return\r\n * block.timestamp with no branching or storage queries.\r\n */\r\ncontract SkinnyOptimisticOracleV2Prod is SkinnyOptimisticOracleV2 {\r\n    constructor(\r\n        uint256 _liveness,\r\n        address _finderAddress,\r\n        address _timerAddress\r\n    ) SkinnyOptimisticOracleV2(_liveness, _finderAddress, _timerAddress) {}\r\n\r\n    function getCurrentTime() public view virtual override returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v2/interfaces/OptimisticOracleInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\n\r\n/**\r\n * @title Financial contract facing Oracle interface.\r\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\r\n */\r\nabstract contract OptimisticOracleInterface {\r\n    event RequestPrice(\r\n        address indexed requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        address currency,\r\n        uint256 reward,\r\n        uint256 finalFee\r\n    );\r\n    event ProposePrice(\r\n        address indexed requester,\r\n        address indexed proposer,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        int256 proposedPrice,\r\n        uint256 expirationTimestamp,\r\n        address currency\r\n    );\r\n    event DisputePrice(\r\n        address indexed requester,\r\n        address indexed proposer,\r\n        address indexed disputer,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        int256 proposedPrice\r\n    );\r\n    event Settle(\r\n        address indexed requester,\r\n        address indexed proposer,\r\n        address indexed disputer,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        int256 price,\r\n        uint256 payout\r\n    );\r\n\r\n    // Struct representing the state of a price request.\r\n    enum State {\r\n        Invalid, // Never requested.\r\n        Requested, // Requested, no other actions taken.\r\n        Proposed, // Proposed, but not expired or disputed yet.\r\n        Expired, // Proposed, not disputed, past liveness.\r\n        Disputed, // Disputed, but no DVM price returned yet.\r\n        Resolved, // Disputed and DVM price is available.\r\n        Settled // Final price has been set in the contract (can get here from Expired or Resolved).\r\n    }\r\n\r\n    // Struct representing a price request.\r\n    struct Request {\r\n        address proposer; // Address of the proposer.\r\n        address disputer; // Address of the disputer.\r\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\r\n        bool settled; // True if the request is settled.\r\n        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\r\n        int256 proposedPrice; // Price that the proposer submitted.\r\n        int256 resolvedPrice; // Price resolved once the request is settled.\r\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\r\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\r\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\r\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\r\n        uint256 customLiveness; // Custom liveness value set by the requester.\r\n    }\r\n\r\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\r\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\r\n    // to accept a price request made with ancillary data length over a certain size.\r\n    uint256 public constant ancillaryBytesLimit = 8192;\r\n\r\n    function defaultLiveness() external view virtual returns (uint256);\r\n\r\n    function finder() external view virtual returns (FinderInterface);\r\n\r\n    function getCurrentTime() external view virtual returns (uint256);\r\n\r\n    // Note: this is required so that typechain generates a return value with named fields.\r\n    mapping(bytes32 => Request) public requests;\r\n\r\n    /**\r\n     * @notice Requests a new price.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\r\n     * This can be changed with a subsequent call to setBond().\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Set the proposal bond associated with a price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param bond custom bond amount to set.\r\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\r\n     * changed again with a subsequent call to setBond().\r\n     */\r\n    function setBond(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 bond\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\r\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\r\n     * bond, so there is still profit to be made even if the reward is refunded.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function setRefundOnDispute(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual;\r\n\r\n    /**\r\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\r\n     * being auto-resolved.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param customLiveness new custom liveness.\r\n     */\r\n    function setCustomLiveness(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 customLiveness\r\n    ) external virtual;\r\n\r\n    /**\r\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\r\n     * from this proposal. However, any bonds are pulled from the caller.\r\n     * @param proposer address to set as the proposer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePriceFor(\r\n        address proposer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) public virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Proposes a price value for an existing price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\r\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\r\n     * @param disputer address to set as the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was value (the proposal was incorrect).\r\n     */\r\n    function disputePriceFor(\r\n        address disputer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Disputes a price value for an existing price request with an active proposal.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\r\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\r\n     * hasn't been settled.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return resolved price.\r\n     */\r\n    function settleAndGetPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual returns (int256);\r\n\r\n    /**\r\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\r\n     * the returned bonds as well as additional rewards.\r\n     */\r\n    function settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual returns (uint256 payout);\r\n\r\n    /**\r\n     * @notice Gets the current data structure containing all information about a price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the Request data structure.\r\n     */\r\n    function getRequest(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (Request memory);\r\n\r\n    /**\r\n     * @notice Returns the state of a price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the State enum value.\r\n     */\r\n    function getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (State);\r\n\r\n    /**\r\n     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return true if price has resolved or settled, false otherwise.\r\n     */\r\n    function hasPrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (bool);\r\n\r\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes memory);\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v2/interfaces/OptimisticOracleV2Interface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\n\r\n/**\r\n * @title Financial contract facing Oracle interface.\r\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\r\n */\r\nabstract contract OptimisticOracleV2Interface {\r\n    event RequestPrice(\r\n        address indexed requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        address currency,\r\n        uint256 reward,\r\n        uint256 finalFee\r\n    );\r\n    event ProposePrice(\r\n        address indexed requester,\r\n        address indexed proposer,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        int256 proposedPrice,\r\n        uint256 expirationTimestamp,\r\n        address currency\r\n    );\r\n    event DisputePrice(\r\n        address indexed requester,\r\n        address indexed proposer,\r\n        address indexed disputer,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        int256 proposedPrice\r\n    );\r\n    event Settle(\r\n        address indexed requester,\r\n        address indexed proposer,\r\n        address indexed disputer,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        int256 price,\r\n        uint256 payout\r\n    );\r\n    // Struct representing the state of a price request.\r\n    enum State {\r\n        Invalid, // Never requested.\r\n        Requested, // Requested, no other actions taken.\r\n        Proposed, // Proposed, but not expired or disputed yet.\r\n        Expired, // Proposed, not disputed, past liveness.\r\n        Disputed, // Disputed, but no DVM price returned yet.\r\n        Resolved, // Disputed and DVM price is available.\r\n        Settled // Final price has been set in the contract (can get here from Expired or Resolved).\r\n    }\r\n\r\n    struct RequestSettings {\r\n        bool eventBased; // True if the request is set to be event-based.\r\n        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\r\n        bool callbackOnPriceProposed; // True if callbackOnPriceProposed callback is required.\r\n        bool callbackOnPriceDisputed; // True if callbackOnPriceDisputed callback is required.\r\n        bool callbackOnPriceSettled; // True if callbackOnPriceSettled callback is required.\r\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\r\n        uint256 customLiveness; // Custom liveness value set by the requester.\r\n    }\r\n\r\n    // Struct representing a price request.\r\n    struct Request {\r\n        address proposer; // Address of the proposer.\r\n        address disputer; // Address of the disputer.\r\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\r\n        bool settled; // True if the request is settled.\r\n        RequestSettings requestSettings; // Custom settings associated with a request.\r\n        int256 proposedPrice; // Price that the proposer submitted.\r\n        int256 resolvedPrice; // Price resolved once the request is settled.\r\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\r\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\r\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\r\n    }\r\n\r\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\r\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\r\n    // to accept a price request made with ancillary data length over a certain size.\r\n    uint256 public constant ancillaryBytesLimit = 8192;\r\n\r\n    function defaultLiveness() external view virtual returns (uint256);\r\n\r\n    function finder() external view virtual returns (FinderInterface);\r\n\r\n    function getCurrentTime() external view virtual returns (uint256);\r\n\r\n    // Note: this is required so that typechain generates a return value with named fields.\r\n    mapping(bytes32 => Request) public requests;\r\n\r\n    /**\r\n     * @notice Requests a new price.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\r\n     * This can be changed with a subsequent call to setBond().\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Set the proposal bond associated with a price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param bond custom bond amount to set.\r\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\r\n     * changed again with a subsequent call to setBond().\r\n     */\r\n    function setBond(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 bond\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\r\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\r\n     * bond, so there is still profit to be made even if the reward is refunded.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function setRefundOnDispute(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual;\r\n\r\n    /**\r\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\r\n     * being auto-resolved.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param customLiveness new custom liveness.\r\n     */\r\n    function setCustomLiveness(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 customLiveness\r\n    ) external virtual;\r\n\r\n    /**\r\n     * @notice Sets the request to be an \"event-based\" request.\r\n     * @dev Calling this method has a few impacts on the request:\r\n     *\r\n     * 1. The timestamp at which the request is evaluated is the time of the proposal, not the timestamp associated\r\n     *    with the request.\r\n     *\r\n     * 2. The proposer cannot propose the \"too early\" value (TOO_EARLY_RESPONSE). This is to ensure that a proposer who\r\n     *    prematurely proposes a response loses their bond.\r\n     *\r\n     * 3. RefundoOnDispute is automatically set, meaning disputes trigger the reward to be automatically refunded to\r\n     *    the requesting contract.\r\n     *\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function setEventBased(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual;\r\n\r\n    /**\r\n     * @notice Sets which callbacks should be enabled for the request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param callbackOnPriceProposed whether to enable the callback onPriceProposed.\r\n     * @param callbackOnPriceDisputed whether to enable the callback onPriceDisputed.\r\n     * @param callbackOnPriceSettled whether to enable the callback onPriceSettled.\r\n     */\r\n    function setCallbacks(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        bool callbackOnPriceProposed,\r\n        bool callbackOnPriceDisputed,\r\n        bool callbackOnPriceSettled\r\n    ) external virtual;\r\n\r\n    /**\r\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\r\n     * from this proposal. However, any bonds are pulled from the caller.\r\n     * @param proposer address to set as the proposer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePriceFor(\r\n        address proposer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) public virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Proposes a price value for an existing price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\r\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\r\n     * @param disputer address to set as the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was value (the proposal was incorrect).\r\n     */\r\n    function disputePriceFor(\r\n        address disputer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Disputes a price value for an existing price request with an active proposal.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\r\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\r\n     * hasn't been settled.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return resolved price.\r\n     */\r\n    function settleAndGetPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual returns (int256);\r\n\r\n    /**\r\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\r\n     * the returned bonds as well as additional rewards.\r\n     */\r\n    function settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual returns (uint256 payout);\r\n\r\n    /**\r\n     * @notice Gets the current data structure containing all information about a price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the Request data structure.\r\n     */\r\n    function getRequest(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (Request memory);\r\n\r\n    /**\r\n     * @notice Returns the state of a price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the State enum value.\r\n     */\r\n    function getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (State);\r\n\r\n    /**\r\n     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return true if price has resolved or settled, false otherwise.\r\n     */\r\n    function hasPrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (bool);\r\n\r\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes memory);\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v2/interfaces/SkinnyOptimisticOracleInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../interfaces/OptimisticOracleInterface.sol\";\r\n\r\n/**\r\n * @title Interface for the gas-cost-reduced version of the OptimisticOracle.\r\n * @notice Differences from normal OptimisticOracle:\r\n * - refundOnDispute: flag is removed, by default there are no refunds on disputes.\r\n * - customizing request parameters: In the OptimisticOracle, parameters like `bond` and `customLiveness` can be reset\r\n *   after a request is already made via `requestPrice`. In the SkinnyOptimisticOracle, these parameters can only be\r\n *   set in `requestPrice`, which has an expanded input set.\r\n * - settleAndGetPrice: Replaced by `settle`, which can only be called once per settleable request. The resolved price\r\n *   can be fetched via the `Settle` event or the return value of `settle`.\r\n * - general changes to interface: Functions that interact with existing requests all require the parameters of the\r\n *   request to modify to be passed as input. These parameters must match with the existing request parameters or the\r\n *   function will revert. This change reflects the internal refactor to store hashed request parameters instead of the\r\n *   full request struct.\r\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\r\n */\r\nabstract contract SkinnyOptimisticOracleInterface {\r\n    // Struct representing a price request. Note that this differs from the OptimisticOracleInterface's Request struct\r\n    // in that refundOnDispute is removed.\r\n    struct Request {\r\n        address proposer; // Address of the proposer.\r\n        address disputer; // Address of the disputer.\r\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\r\n        bool settled; // True if the request is settled.\r\n        int256 proposedPrice; // Price that the proposer submitted.\r\n        int256 resolvedPrice; // Price resolved once the request is settled.\r\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\r\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\r\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\r\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\r\n        uint256 customLiveness; // Custom liveness value set by the requester.\r\n    }\r\n\r\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\r\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\r\n    // to accept a price request made with ancillary data length over a certain size.\r\n    uint256 public constant ancillaryBytesLimit = 8192;\r\n\r\n    /**\r\n     * @notice Requests a new price.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\r\n     * @param customLiveness custom proposal liveness to set for request.\r\n     * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        uint256 bond,\r\n        uint256 customLiveness\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\r\n     * from this proposal. However, any bonds are pulled from the caller.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * propose a price for.\r\n     * @param proposer address to set as the proposer.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePriceFor(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        address proposer,\r\n        int256 proposedPrice\r\n    ) public virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Proposes a price value where caller is the proposer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * propose a price for.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        int256 proposedPrice\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\r\n     * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\r\n     * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\r\n     * @dev The caller is the requester, but the proposer can be customized.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\r\n     * @param customLiveness custom proposal liveness to set for request.\r\n     * @param proposer address to set as the proposer.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function requestAndProposePriceFor(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        uint256 bond,\r\n        uint256 customLiveness,\r\n        address proposer,\r\n        int256 proposedPrice\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\r\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * dispute.\r\n     * @param disputer address to set as the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePriceFor(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        address disputer,\r\n        address requester\r\n    ) public virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal where caller is the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * dispute.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * settle.\r\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\r\n     * the returned bonds as well as additional rewards.\r\n     * @return resolvedPrice the price that the request settled to.\r\n     */\r\n    function settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external virtual returns (uint256 payout, int256 resolvedPrice);\r\n\r\n    /**\r\n     * @notice Computes the current state of a price request. See the State enum for more details.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters.\r\n     * @return the State.\r\n     */\r\n    function getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external virtual returns (OptimisticOracleInterface.State);\r\n\r\n    /**\r\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters. The hash of these parameters must match with the request hash that is\r\n     * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\r\n     * will revert.\r\n     * @return boolean indicating true if price exists and false if not.\r\n     */\r\n    function hasPrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) public virtual returns (bool);\r\n\r\n    /**\r\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param requester sender of the initial price request.\r\n     * @return the stamped ancillary bytes.\r\n     */\r\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\r\n        public\r\n        pure\r\n        virtual\r\n        returns (bytes memory);\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v2/interfaces/SkinnyOptimisticOracleV2Interface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../interfaces/OptimisticOracleInterface.sol\";\r\n\r\n/**\r\n * @title Interface for the gas-cost-reduced version of the OptimisticOracle.\r\n * @notice Differences from normal OptimisticOracle:\r\n * - refundOnDispute: flag is removed, by default there are no refunds on disputes.\r\n * - customizing request parameters: In the OptimisticOracle, parameters like `bond` and `customLiveness` can be reset\r\n *   after a request is already made via `requestPrice`. In the SkinnyOptimisticOracle, these parameters can only be\r\n *   set in `requestPrice`, which has an expanded input set.\r\n * - settleAndGetPrice: Replaced by `settle`, which can only be called once per settleable request. The resolved price\r\n *   can be fetched via the `Settle` event or the return value of `settle`.\r\n * - general changes to interface: Functions that interact with existing requests all require the parameters of the\r\n *   request to modify to be passed as input. These parameters must match with the existing request parameters or the\r\n *   function will revert. This change reflects the internal refactor to store hashed request parameters instead of the\r\n *   full request struct.\r\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\r\n */\r\nabstract contract SkinnyOptimisticOracleV2Interface {\r\n    struct RequestSettings {\r\n        bool callbackOnPriceProposed; // True if callbackOnPriceProposed callback is required.\r\n        bool callbackOnPriceDisputed; // True if callbackOnPriceDisputed callback is required.\r\n        bool callbackOnPriceSettled; // True if callbackOnPriceSettled callback is required.\r\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\r\n        uint256 customLiveness; // Custom liveness value set by the requester.\r\n    }\r\n\r\n    // Struct representing a price request. Note that this differs from the OptimisticOracleInterface's Request struct\r\n    // in that refundOnDispute is removed.\r\n    struct Request {\r\n        address proposer; // Address of the proposer.\r\n        address disputer; // Address of the disputer.\r\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\r\n        bool settled; // True if the request is settled.\r\n        RequestSettings requestSettings; // Custom settings associated with a request.\r\n        int256 proposedPrice; // Price that the proposer submitted.\r\n        int256 resolvedPrice; // Price resolved once the request is settled.\r\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\r\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\r\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\r\n    }\r\n\r\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\r\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\r\n    // to accept a price request made with ancillary data length over a certain size.\r\n    uint256 public constant ancillaryBytesLimit = 8192;\r\n\r\n    /**\r\n     * @notice Requests a new price.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @param requestSettings settings for the request.\r\n     * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        RequestSettings memory requestSettings\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\r\n     * from this proposal. However, any bonds are pulled from the caller.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * propose a price for.\r\n     * @param proposer address to set as the proposer.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePriceFor(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        address proposer,\r\n        int256 proposedPrice\r\n    ) public virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Proposes a price value where caller is the proposer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * propose a price for.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        int256 proposedPrice\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\r\n     * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\r\n     * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\r\n     * @dev The caller is the requester, but the proposer can be customized.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @param requestSettings settings for the request.\r\n     * @param proposer address to set as the proposer.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function requestAndProposePriceFor(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        RequestSettings memory requestSettings,\r\n        address proposer,\r\n        int256 proposedPrice\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\r\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * dispute.\r\n     * @param disputer address to set as the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePriceFor(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        address disputer,\r\n        address requester\r\n    ) public virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal where caller is the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * dispute.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * settle.\r\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\r\n     * the returned bonds as well as additional rewards.\r\n     * @return resolvedPrice the price that the request settled to.\r\n     */\r\n    function settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external virtual returns (uint256 payout, int256 resolvedPrice);\r\n\r\n    /**\r\n     * @notice Computes the current state of a price request. See the State enum for more details.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters.\r\n     * @return the State.\r\n     */\r\n    function getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external virtual returns (OptimisticOracleInterface.State);\r\n\r\n    /**\r\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters. The hash of these parameters must match with the request hash that is\r\n     * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\r\n     * will revert.\r\n     * @return boolean indicating true if price exists and false if not.\r\n     */\r\n    function hasPrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) public virtual returns (bool);\r\n\r\n    /**\r\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param requester sender of the initial price request.\r\n     * @return the stamped ancillary bytes.\r\n     */\r\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\r\n        public\r\n        pure\r\n        virtual\r\n        returns (bytes memory);\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v2/previous-versions/OptimisticOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\n// WARNING: This contract has been deprecated! It is left in the UMA Protocol repo for backwards compatibility reasons.\r\n// You should refer to the latest implementation of the Optimistic Oracle which is named OptimisticOracleV2 and can\r\n// be found in the UMA Finder under the same name.\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../interfaces/OptimisticOracleInterface.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\n\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/implementation/AncillaryData.sol\";\r\nimport \"../../common/implementation/AddressWhitelist.sol\";\r\n\r\n/**\r\n * @title Optimistic Requester.\r\n * @notice Optional interface that requesters can implement to receive callbacks.\r\n * @dev this contract does _not_ work with ERC777 collateral currencies or any others that call into the receiver on\r\n * transfer(). Using an ERC777 token would allow a user to maliciously grief other participants (while also losing\r\n * money themselves).\r\n */\r\ninterface OptimisticRequester {\r\n    /**\r\n     * @notice Callback for proposals.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function priceProposed(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Callback for disputes.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param refund refund received in the case that refundOnDispute was enabled.\r\n     */\r\n    function priceDisputed(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 refund\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Callback for settlement.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param price price that was resolved by the escalation process.\r\n     */\r\n    function priceSettled(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title Optimistic Oracle.\r\n * @notice Pre-DVM escalation contract that allows faster settlement.\r\n */\r\ncontract OptimisticOracle is OptimisticOracleInterface, Testable, Lockable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    // Finder to provide addresses for DVM contracts.\r\n    FinderInterface public override finder;\r\n\r\n    // Default liveness value for all price requests.\r\n    uint256 public override defaultLiveness;\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _liveness default liveness applied to each price request.\r\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\r\n     * @param _timerAddress address of the timer contract. Should be 0x0 in prod.\r\n     */\r\n    constructor(\r\n        uint256 _liveness,\r\n        address _finderAddress,\r\n        address _timerAddress\r\n    ) Testable(_timerAddress) {\r\n        finder = FinderInterface(_finderAddress);\r\n        _validateLiveness(_liveness);\r\n        defaultLiveness = _liveness;\r\n    }\r\n\r\n    /**\r\n     * @notice Requests a new price.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\r\n     * This can be changed with a subsequent call to setBond().\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward\r\n    ) external override nonReentrant() returns (uint256 totalBond) {\r\n        require(_getState(msg.sender, identifier, timestamp, ancillaryData) == State.Invalid, \"requestPrice: Invalid\");\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\r\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\r\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\r\n        require(\r\n            _stampAncillaryData(ancillaryData, msg.sender).length <= ancillaryBytesLimit,\r\n            \"Ancillary Data too long\"\r\n        );\r\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\r\n        requests[_getId(msg.sender, identifier, timestamp, ancillaryData)] = Request({\r\n            proposer: address(0),\r\n            disputer: address(0),\r\n            currency: currency,\r\n            settled: false,\r\n            refundOnDispute: false,\r\n            proposedPrice: 0,\r\n            resolvedPrice: 0,\r\n            expirationTime: 0,\r\n            reward: reward,\r\n            finalFee: finalFee,\r\n            bond: finalFee,\r\n            customLiveness: 0\r\n        });\r\n\r\n        if (reward > 0) {\r\n            currency.safeTransferFrom(msg.sender, address(this), reward);\r\n        }\r\n\r\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, address(currency), reward, finalFee);\r\n\r\n        // This function returns the initial proposal bond for this request, which can be customized by calling\r\n        // setBond() with the same identifier and timestamp.\r\n        return finalFee.mul(2);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the proposal bond associated with a price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param bond custom bond amount to set.\r\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\r\n     * changed again with a subsequent call to setBond().\r\n     */\r\n    function setBond(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 bond\r\n    ) external override nonReentrant() returns (uint256 totalBond) {\r\n        require(_getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested, \"setBond: Requested\");\r\n        Request storage request = _getRequest(msg.sender, identifier, timestamp, ancillaryData);\r\n        request.bond = bond;\r\n\r\n        // Total bond is the final fee + the newly set bond.\r\n        return bond.add(request.finalFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\r\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\r\n     * bond, so there is still profit to be made even if the reward is refunded.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function setRefundOnDispute(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override nonReentrant() {\r\n        require(\r\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\r\n            \"setRefundOnDispute: Requested\"\r\n        );\r\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).refundOnDispute = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\r\n     * being auto-resolved.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param customLiveness new custom liveness.\r\n     */\r\n    function setCustomLiveness(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 customLiveness\r\n    ) external override nonReentrant() {\r\n        require(\r\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\r\n            \"setCustomLiveness: Requested\"\r\n        );\r\n        _validateLiveness(customLiveness);\r\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).customLiveness = customLiveness;\r\n    }\r\n\r\n    /**\r\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\r\n     * from this proposal. However, any bonds are pulled from the caller.\r\n     * @param proposer address to set as the proposer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePriceFor(\r\n        address proposer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) public override nonReentrant() returns (uint256 totalBond) {\r\n        require(proposer != address(0), \"proposer address must be non 0\");\r\n        require(\r\n            _getState(requester, identifier, timestamp, ancillaryData) == State.Requested,\r\n            \"proposePriceFor: Requested\"\r\n        );\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n        request.proposer = proposer;\r\n        request.proposedPrice = proposedPrice;\r\n\r\n        // If a custom liveness has been set, use it instead of the default.\r\n        request.expirationTime = getCurrentTime().add(\r\n            request.customLiveness != 0 ? request.customLiveness : defaultLiveness\r\n        );\r\n\r\n        totalBond = request.bond.add(request.finalFee);\r\n        if (totalBond > 0) {\r\n            request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n        }\r\n\r\n        emit ProposePrice(\r\n            requester,\r\n            proposer,\r\n            identifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            proposedPrice,\r\n            request.expirationTime,\r\n            address(request.currency)\r\n        );\r\n\r\n        // Callback.\r\n        if (address(requester).isContract())\r\n            try OptimisticRequester(requester).priceProposed(identifier, timestamp, ancillaryData) {} catch {}\r\n    }\r\n\r\n    /**\r\n     * @notice Proposes a price value for an existing price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) external override returns (uint256 totalBond) {\r\n        // Note: re-entrancy guard is done in the inner call.\r\n        return proposePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData, proposedPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\r\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\r\n     * @param disputer address to set as the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePriceFor(\r\n        address disputer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public override nonReentrant() returns (uint256 totalBond) {\r\n        require(disputer != address(0), \"disputer address must be non 0\");\r\n        require(\r\n            _getState(requester, identifier, timestamp, ancillaryData) == State.Proposed,\r\n            \"disputePriceFor: Proposed\"\r\n        );\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n        request.disputer = disputer;\r\n\r\n        uint256 finalFee = request.finalFee;\r\n        uint256 bond = request.bond;\r\n        totalBond = bond.add(finalFee);\r\n        if (totalBond > 0) {\r\n            request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n        }\r\n\r\n        StoreInterface store = _getStore();\r\n\r\n        // Avoids stack too deep compilation error.\r\n        {\r\n            // Along with the final fee, \"burn\" part of the loser's bond to ensure that a larger bond always makes it\r\n            // proportionally more expensive to delay the resolution even if the proposer and disputer are the same\r\n            // party.\r\n            uint256 burnedBond = _computeBurnedBond(request);\r\n\r\n            // The total fee is the burned bond and the final fee added together.\r\n            uint256 totalFee = finalFee.add(burnedBond);\r\n\r\n            if (totalFee > 0) {\r\n                request.currency.safeIncreaseAllowance(address(store), totalFee);\r\n                _getStore().payOracleFeesErc20(address(request.currency), FixedPoint.Unsigned(totalFee));\r\n            }\r\n        }\r\n\r\n        _getOracle().requestPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester));\r\n\r\n        // Compute refund.\r\n        uint256 refund = 0;\r\n        if (request.reward > 0 && request.refundOnDispute) {\r\n            refund = request.reward;\r\n            request.reward = 0;\r\n            request.currency.safeTransfer(requester, refund);\r\n        }\r\n\r\n        emit DisputePrice(\r\n            requester,\r\n            request.proposer,\r\n            disputer,\r\n            identifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            request.proposedPrice\r\n        );\r\n\r\n        // Callback.\r\n        if (address(requester).isContract())\r\n            try OptimisticRequester(requester).priceDisputed(identifier, timestamp, ancillaryData, refund) {} catch {}\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a price value for an existing price request with an active proposal.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override returns (uint256 totalBond) {\r\n        // Note: re-entrancy guard is done in the inner call.\r\n        return disputePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\r\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\r\n     * hasn't been settled.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return resolved price.\r\n     */\r\n    function settleAndGetPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override nonReentrant() returns (int256) {\r\n        if (_getState(msg.sender, identifier, timestamp, ancillaryData) != State.Settled) {\r\n            _settle(msg.sender, identifier, timestamp, ancillaryData);\r\n        }\r\n\r\n        return _getRequest(msg.sender, identifier, timestamp, ancillaryData).resolvedPrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\r\n     * the returned bonds as well as additional rewards.\r\n     */\r\n    function settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override nonReentrant() returns (uint256 payout) {\r\n        return _settle(requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current data structure containing all information about a price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the Request data structure.\r\n     */\r\n    function getRequest(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() returns (Request memory) {\r\n        return _getRequest(requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the current state of a price request. See the State enum for more details.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the State.\r\n     */\r\n    function getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() returns (State) {\r\n        return _getState(requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return boolean indicating true if price exists and false if not.\r\n     */\r\n    function hasPrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() returns (bool) {\r\n        State state = _getState(requester, identifier, timestamp, ancillaryData);\r\n        return state == State.Settled || state == State.Resolved || state == State.Expired;\r\n    }\r\n\r\n    /**\r\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param requester sender of the initial price request.\r\n     * @return the stamped ancillary bytes.\r\n     */\r\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\r\n        public\r\n        pure\r\n        override\r\n        returns (bytes memory)\r\n    {\r\n        return _stampAncillaryData(ancillaryData, requester);\r\n    }\r\n\r\n    function _getId(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) private pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(requester, identifier, timestamp, ancillaryData));\r\n    }\r\n\r\n    function _settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) private returns (uint256 payout) {\r\n        State state = _getState(requester, identifier, timestamp, ancillaryData);\r\n\r\n        // Set it to settled so this function can never be entered again.\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n        request.settled = true;\r\n\r\n        if (state == State.Expired) {\r\n            // In the expiry case, just pay back the proposer's bond and final fee along with the reward.\r\n            request.resolvedPrice = request.proposedPrice;\r\n            payout = request.bond.add(request.finalFee).add(request.reward);\r\n            request.currency.safeTransfer(request.proposer, payout);\r\n        } else if (state == State.Resolved) {\r\n            // In the Resolved case, pay either the disputer or the proposer the entire payout (+ bond and reward).\r\n            request.resolvedPrice = _getOracle().getPrice(\r\n                identifier,\r\n                timestamp,\r\n                _stampAncillaryData(ancillaryData, requester)\r\n            );\r\n            bool disputeSuccess = request.resolvedPrice != request.proposedPrice;\r\n            uint256 bond = request.bond;\r\n\r\n            // Unburned portion of the loser's bond = 1 - burned bond.\r\n            uint256 unburnedBond = bond.sub(_computeBurnedBond(request));\r\n\r\n            // Winner gets:\r\n            // - Their bond back.\r\n            // - The unburned portion of the loser's bond.\r\n            // - Their final fee back.\r\n            // - The request reward (if not already refunded -- if refunded, it will be set to 0).\r\n            payout = bond.add(unburnedBond).add(request.finalFee).add(request.reward);\r\n            request.currency.safeTransfer(disputeSuccess ? request.disputer : request.proposer, payout);\r\n        } else {\r\n            revert(\"_settle: not settleable\");\r\n        }\r\n\r\n        emit Settle(\r\n            requester,\r\n            request.proposer,\r\n            request.disputer,\r\n            identifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            request.resolvedPrice,\r\n            payout\r\n        );\r\n\r\n        // Callback.\r\n        if (address(requester).isContract())\r\n            try\r\n                OptimisticRequester(requester).priceSettled(identifier, timestamp, ancillaryData, request.resolvedPrice)\r\n            {} catch {}\r\n    }\r\n\r\n    function _getRequest(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) private view returns (Request storage) {\r\n        return requests[_getId(requester, identifier, timestamp, ancillaryData)];\r\n    }\r\n\r\n    function _computeBurnedBond(Request storage request) private view returns (uint256) {\r\n        // burnedBond = floor(bond / 2)\r\n        return request.bond.div(2);\r\n    }\r\n\r\n    function _validateLiveness(uint256 _liveness) private pure {\r\n        require(_liveness < 5200 weeks, \"Liveness too large\");\r\n        require(_liveness > 0, \"Liveness cannot be 0\");\r\n    }\r\n\r\n    function _getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) internal view returns (State) {\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n\r\n        if (address(request.currency) == address(0)) {\r\n            return State.Invalid;\r\n        }\r\n\r\n        if (request.proposer == address(0)) {\r\n            return State.Requested;\r\n        }\r\n\r\n        if (request.settled) {\r\n            return State.Settled;\r\n        }\r\n\r\n        if (request.disputer == address(0)) {\r\n            return request.expirationTime <= getCurrentTime() ? State.Expired : State.Proposed;\r\n        }\r\n\r\n        return\r\n            _getOracle().hasPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester))\r\n                ? State.Resolved\r\n                : State.Disputed;\r\n    }\r\n\r\n    function _getOracle() internal view returns (OracleAncillaryInterface) {\r\n        return OracleAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n\r\n    function _getCollateralWhitelist() internal view returns (AddressWhitelist) {\r\n        return AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n    }\r\n\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    /**\r\n     * @dev We don't handle specifically the case where `ancillaryData` is not already readily translateable in utf8.\r\n     * For those cases, we assume that the client will be able to strip out the utf8-translateable part of the\r\n     * ancillary data that this contract stamps.\r\n     */\r\n    function _stampAncillaryData(bytes memory ancillaryData, address requester) internal pure returns (bytes memory) {\r\n        // Since this contract will be the one to formally submit DVM price requests, its useful for voters to know who\r\n        // the original requester was.\r\n        return AncillaryData.appendKeyValueAddress(ancillaryData, \"ooRequester\", requester);\r\n    }\r\n\r\n    function getCurrentTime() public view override(Testable, OptimisticOracleInterface) returns (uint256) {\r\n        return Testable.getCurrentTime();\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v2/previous-versions/SkinnyOptimisticOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\nimport \"../interfaces/OptimisticOracleInterface.sol\";\r\nimport \"../interfaces/SkinnyOptimisticOracleInterface.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\n\r\nimport \"../../common/implementation/Testable.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"../../common/implementation/AncillaryData.sol\";\r\nimport \"../../common/implementation/AddressWhitelist.sol\";\r\n\r\n/**\r\n * @title Optimistic Requester.\r\n * @notice Optional interface that requesters can implement to receive callbacks.\r\n * @dev This contract does _not_ work with ERC777 collateral currencies or any others that call into the receiver on\r\n * transfer(). Using an ERC777 token would allow a user to maliciously grief other participants (while also losing\r\n * money themselves).\r\n */\r\ninterface OptimisticRequester {\r\n    /**\r\n     * @notice Callback for proposals.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request request params after proposal.\r\n     */\r\n    function priceProposed(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        SkinnyOptimisticOracleInterface.Request memory request\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Callback for disputes.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request request params after dispute.\r\n     */\r\n    function priceDisputed(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        SkinnyOptimisticOracleInterface.Request memory request\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Callback for settlement.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request request params after settlement.\r\n     */\r\n    function priceSettled(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        SkinnyOptimisticOracleInterface.Request memory request\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title Optimistic Oracle with a different interface and fewer features that emphasizes gas cost reductions.\r\n * @notice Pre-DVM escalation contract that allows faster settlement.\r\n */\r\ncontract SkinnyOptimisticOracle is SkinnyOptimisticOracleInterface, Testable, Lockable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    event RequestPrice(\r\n        address indexed requester,\r\n        bytes32 indexed identifier,\r\n        uint32 timestamp,\r\n        bytes ancillaryData,\r\n        Request request\r\n    );\r\n    event ProposePrice(\r\n        address indexed requester,\r\n        bytes32 indexed identifier,\r\n        uint32 timestamp,\r\n        bytes ancillaryData,\r\n        Request request\r\n    );\r\n    event DisputePrice(\r\n        address indexed requester,\r\n        bytes32 indexed identifier,\r\n        uint32 timestamp,\r\n        bytes ancillaryData,\r\n        Request request\r\n    );\r\n    event Settle(\r\n        address indexed requester,\r\n        bytes32 indexed identifier,\r\n        uint32 timestamp,\r\n        bytes ancillaryData,\r\n        Request request\r\n    );\r\n\r\n    // Maps hash of unique request params {identifier, timestamp, ancillary data} to customizable variables such as\r\n    // reward and bond amounts.\r\n    mapping(bytes32 => bytes32) public requests;\r\n\r\n    // Finder to provide addresses for DVM contracts.\r\n    FinderInterface public finder;\r\n\r\n    // Default liveness value for all price requests.\r\n    uint256 public defaultLiveness;\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _liveness default liveness applied to each price request.\r\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\r\n     * @param _timerAddress address of the timer contract. Should be 0x0 in prod.\r\n     */\r\n    constructor(\r\n        uint256 _liveness,\r\n        address _finderAddress,\r\n        address _timerAddress\r\n    ) Testable(_timerAddress) {\r\n        finder = FinderInterface(_finderAddress);\r\n        _validateLiveness(_liveness);\r\n        defaultLiveness = _liveness;\r\n    }\r\n\r\n    /**\r\n     * @notice Requests a new price.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\r\n     * @param customLiveness custom proposal liveness to set for request.\r\n     * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        uint256 bond,\r\n        uint256 customLiveness\r\n    ) external override nonReentrant() returns (uint256 totalBond) {\r\n        bytes32 requestId = _getId(msg.sender, identifier, timestamp, ancillaryData);\r\n        require(requests[requestId] == bytes32(0), \"Request already initialized\");\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\r\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\r\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\r\n        require(\r\n            _stampAncillaryData(ancillaryData, msg.sender).length <= ancillaryBytesLimit,\r\n            \"Ancillary Data too long\"\r\n        );\r\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\r\n\r\n        // Associate new request with ID\r\n        Request memory request;\r\n        request.currency = currency;\r\n        request.reward = reward;\r\n        request.finalFee = finalFee;\r\n        request.bond = bond != 0 ? bond : finalFee;\r\n        request.customLiveness = customLiveness;\r\n        _storeRequestHash(requestId, request);\r\n\r\n        if (reward > 0) currency.safeTransferFrom(msg.sender, address(this), reward);\r\n\r\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, request);\r\n\r\n        return request.bond.add(finalFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\r\n     * from this proposal. However, any bonds are pulled from the caller.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * propose a price for.\r\n     * @param proposer address to set as the proposer.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePriceFor(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        address proposer,\r\n        int256 proposedPrice\r\n    ) public override nonReentrant() returns (uint256 totalBond) {\r\n        require(proposer != address(0), \"Proposer address must be non 0\");\r\n        require(\r\n            _getState(requester, identifier, timestamp, ancillaryData, request) ==\r\n                OptimisticOracleInterface.State.Requested,\r\n            \"Must be requested\"\r\n        );\r\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\r\n        _validateRequestHash(requestId, request);\r\n\r\n        // Associate newly proposed request params with ID\r\n        Request memory proposedRequest =\r\n            Request({\r\n                proposer: proposer, // Modified\r\n                disputer: request.disputer,\r\n                currency: request.currency,\r\n                settled: request.settled,\r\n                proposedPrice: proposedPrice, // Modified\r\n                resolvedPrice: request.resolvedPrice,\r\n                expirationTime: getCurrentTime().add(\r\n                    request.customLiveness != 0 ? request.customLiveness : defaultLiveness\r\n                ), // Modified\r\n                reward: request.reward,\r\n                finalFee: request.finalFee,\r\n                bond: request.bond,\r\n                customLiveness: request.customLiveness\r\n            });\r\n        _storeRequestHash(requestId, proposedRequest);\r\n\r\n        totalBond = request.bond.add(request.finalFee);\r\n        if (totalBond > 0) request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n\r\n        emit ProposePrice(requester, identifier, timestamp, ancillaryData, proposedRequest);\r\n\r\n        // Callback.\r\n        if (address(requester).isContract())\r\n            try\r\n                OptimisticRequester(requester).priceProposed(identifier, timestamp, ancillaryData, proposedRequest)\r\n            {} catch {}\r\n    }\r\n\r\n    /**\r\n     * @notice Proposes a price value where caller is the proposer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     * propose a price for.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        int256 proposedPrice\r\n    ) external override returns (uint256 totalBond) {\r\n        // Note: re-entrancy guard is done in the inner call.\r\n        return proposePriceFor(requester, identifier, timestamp, ancillaryData, request, msg.sender, proposedPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\r\n     * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\r\n     * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\r\n     * @dev The caller is the requester, but the proposer can be customized.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\r\n     * @param customLiveness custom proposal liveness to set for request.\r\n     * @param proposer address to set as the proposer.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function requestAndProposePriceFor(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        uint256 bond,\r\n        uint256 customLiveness,\r\n        address proposer,\r\n        int256 proposedPrice\r\n    ) external override nonReentrant() returns (uint256 totalBond) {\r\n        bytes32 requestId = _getId(msg.sender, identifier, timestamp, ancillaryData);\r\n        require(requests[requestId] == bytes32(0), \"Request already initialized\");\r\n        require(proposer != address(0), \"proposer address must be non 0\");\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\r\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\r\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\r\n        require(\r\n            _stampAncillaryData(ancillaryData, msg.sender).length <= ancillaryBytesLimit,\r\n            \"Ancillary Data too long\"\r\n        );\r\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\r\n\r\n        // Associate new request with ID\r\n        Request memory request;\r\n        request.currency = currency;\r\n        request.reward = reward;\r\n        request.finalFee = finalFee;\r\n        request.bond = bond != 0 ? bond : finalFee;\r\n        request.customLiveness = customLiveness;\r\n        request.proposer = proposer;\r\n        request.proposedPrice = proposedPrice;\r\n        request.expirationTime = getCurrentTime().add(customLiveness != 0 ? customLiveness : defaultLiveness);\r\n        _storeRequestHash(requestId, request);\r\n\r\n        // Pull reward from requester, who is the caller.\r\n        if (reward > 0) currency.safeTransferFrom(msg.sender, address(this), reward);\r\n        // Pull proposal bond from caller.\r\n        totalBond = request.bond.add(request.finalFee);\r\n        if (totalBond > 0) currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n\r\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, request);\r\n        emit ProposePrice(msg.sender, identifier, timestamp, ancillaryData, request);\r\n\r\n        // Callback.\r\n        if (address(msg.sender).isContract())\r\n            try OptimisticRequester(msg.sender).priceProposed(identifier, timestamp, ancillaryData, request) {} catch {}\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\r\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     *              dispute.\r\n     * @param disputer address to set as the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePriceFor(\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request,\r\n        address disputer,\r\n        address requester\r\n    ) public override nonReentrant() returns (uint256 totalBond) {\r\n        require(disputer != address(0), \"disputer address must be non 0\");\r\n        require(\r\n            _getState(requester, identifier, timestamp, ancillaryData, request) ==\r\n                OptimisticOracleInterface.State.Proposed,\r\n            \"Must be proposed\"\r\n        );\r\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\r\n        _validateRequestHash(requestId, request);\r\n\r\n        // Associate newly disputed request params with ID\r\n        Request memory disputedRequest =\r\n            Request({\r\n                proposer: request.proposer,\r\n                disputer: disputer, // Modified\r\n                currency: request.currency,\r\n                settled: request.settled,\r\n                proposedPrice: request.proposedPrice,\r\n                resolvedPrice: request.resolvedPrice,\r\n                expirationTime: request.expirationTime,\r\n                reward: request.reward,\r\n                finalFee: request.finalFee,\r\n                bond: request.bond,\r\n                customLiveness: request.customLiveness\r\n            });\r\n        _storeRequestHash(requestId, disputedRequest);\r\n\r\n        totalBond = request.bond.add(request.finalFee);\r\n        if (totalBond > 0) request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n\r\n        StoreInterface store = _getStore();\r\n\r\n        // Avoids stack too deep compilation error.\r\n        {\r\n            // Along with the final fee, \"burn\" part of the loser's bond to ensure that a larger bond always makes it\r\n            // proportionally more expensive to delay the resolution even if the proposer and disputer are the same\r\n            // party.\r\n            uint256 burnedBond = _computeBurnedBond(disputedRequest);\r\n\r\n            // The total fee is the burned bond and the final fee added together.\r\n            uint256 totalFee = request.finalFee.add(burnedBond);\r\n\r\n            if (totalFee > 0) {\r\n                request.currency.safeIncreaseAllowance(address(store), totalFee);\r\n                _getStore().payOracleFeesErc20(address(request.currency), FixedPoint.Unsigned(totalFee));\r\n            }\r\n        }\r\n\r\n        _getOracle().requestPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester));\r\n\r\n        emit DisputePrice(requester, identifier, timestamp, ancillaryData, disputedRequest);\r\n\r\n        // Callback.\r\n        if (address(requester).isContract())\r\n            try\r\n                OptimisticRequester(requester).priceDisputed(identifier, timestamp, ancillaryData, disputedRequest)\r\n            {} catch {}\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal where caller is the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     *             dispute.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external override returns (uint256 totalBond) {\r\n        // Note: re-entrancy guard is done in the inner call.\r\n        return disputePriceFor(identifier, timestamp, ancillaryData, request, msg.sender, requester);\r\n    }\r\n\r\n    /**\r\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters whose hash must match the request that the caller wants to\r\n     *              settle.\r\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\r\n     * the returned bonds as well as additional rewards.\r\n     * @return resolvedPrice the price that the request settled to.\r\n     */\r\n    function settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external override nonReentrant() returns (uint256 payout, int256 resolvedPrice) {\r\n        return _settle(requester, identifier, timestamp, ancillaryData, request);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the current state of a price request. See the State enum for more details.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters.\r\n     * @return the State.\r\n     */\r\n    function getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) external override nonReentrant() returns (OptimisticOracleInterface.State) {\r\n        return _getState(requester, identifier, timestamp, ancillaryData, request);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param request price request parameters. The hash of these parameters must match with the request hash that is\r\n     * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\r\n     * will revert.\r\n     * @return boolean indicating true if price exists and false if not.\r\n     */\r\n    function hasPrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) public override nonReentrant() returns (bool) {\r\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\r\n        _validateRequestHash(requestId, request);\r\n        OptimisticOracleInterface.State state = _getState(requester, identifier, timestamp, ancillaryData, request);\r\n        return\r\n            state == OptimisticOracleInterface.State.Settled ||\r\n            state == OptimisticOracleInterface.State.Resolved ||\r\n            state == OptimisticOracleInterface.State.Expired;\r\n    }\r\n\r\n    /**\r\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param requester sender of the initial price request.\r\n     * @return the stamped ancillary bytes.\r\n     */\r\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\r\n        public\r\n        pure\r\n        override\r\n        returns (bytes memory)\r\n    {\r\n        return _stampAncillaryData(ancillaryData, requester);\r\n    }\r\n\r\n    /****************************************\r\n     *    PRIVATE AND INTERNAL FUNCTIONS    *\r\n     ****************************************/\r\n    // Returns hash of unique request identifiers. This contract maps request ID hashes to hashes of the request's\r\n    // parameters.\r\n    function _getId(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData\r\n    ) private pure returns (bytes32) {\r\n        return keccak256(abi.encode(requester, identifier, timestamp, ancillaryData));\r\n    }\r\n\r\n    // Returns hash of request parameters. These are mapped to the unique request ID to track a request's lifecycle.\r\n    function _getRequestHash(Request memory request) private pure returns (bytes32) {\r\n        return keccak256(abi.encode(request));\r\n    }\r\n\r\n    // Resolves a price request that has expired or been disputed and a price is available from the DVM. This will\r\n    // revert if the unique request ID does not match the hashed request parameters. This also marks the request\r\n    // as settled, therefore this method can only be triggered once per eligible request.\r\n    function _settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) private returns (uint256 payout, int256 resolvedPrice) {\r\n        bytes32 requestId = _getId(requester, identifier, timestamp, ancillaryData);\r\n        _validateRequestHash(requestId, request);\r\n\r\n        // Associate settled request params with ID.\r\n        Request memory settledRequest =\r\n            Request({\r\n                proposer: request.proposer,\r\n                disputer: request.disputer,\r\n                currency: request.currency,\r\n                settled: true, // Modified\r\n                proposedPrice: request.proposedPrice,\r\n                resolvedPrice: request.resolvedPrice,\r\n                expirationTime: request.expirationTime,\r\n                reward: request.reward,\r\n                finalFee: request.finalFee,\r\n                bond: request.bond,\r\n                customLiveness: request.customLiveness\r\n            });\r\n\r\n        OptimisticOracleInterface.State state = _getState(requester, identifier, timestamp, ancillaryData, request);\r\n        if (state == OptimisticOracleInterface.State.Expired) {\r\n            // In the expiry case, just pay back the proposer's bond and final fee along with the reward.\r\n            resolvedPrice = request.proposedPrice;\r\n            settledRequest.resolvedPrice = resolvedPrice;\r\n            payout = request.bond.add(request.finalFee).add(request.reward);\r\n            request.currency.safeTransfer(request.proposer, payout);\r\n        } else if (state == OptimisticOracleInterface.State.Resolved) {\r\n            // In the Resolved case, pay either the disputer or the proposer the entire payout (+ bond and reward).\r\n            resolvedPrice = _getOracle().getPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester));\r\n            settledRequest.resolvedPrice = resolvedPrice;\r\n            bool disputeSuccess = settledRequest.resolvedPrice != request.proposedPrice;\r\n\r\n            // Winner gets:\r\n            // - Their bond back.\r\n            // - The unburned portion of the loser's bond: proposal bond (not including final fee) - burned bond.\r\n            // - Their final fee back.\r\n            // - The request reward (if not already refunded -- if refunded, it will be set to 0).\r\n            payout = request.bond.add(request.bond.sub(_computeBurnedBond(settledRequest))).add(request.finalFee).add(\r\n                request.reward\r\n            );\r\n            request.currency.safeTransfer(disputeSuccess ? request.disputer : request.proposer, payout);\r\n        } else {\r\n            revert(\"Already settled or not settleable\");\r\n        }\r\n\r\n        _storeRequestHash(requestId, settledRequest);\r\n        emit Settle(requester, identifier, timestamp, ancillaryData, settledRequest);\r\n\r\n        // Callback.\r\n        if (address(requester).isContract())\r\n            try\r\n                OptimisticRequester(requester).priceSettled(identifier, timestamp, ancillaryData, settledRequest)\r\n            {} catch {}\r\n    }\r\n\r\n    function _computeBurnedBond(Request memory request) private pure returns (uint256) {\r\n        // burnedBond = floor(bond / 2)\r\n        return request.bond.div(2);\r\n    }\r\n\r\n    function _validateLiveness(uint256 liveness) private pure {\r\n        require(liveness < 5200 weeks, \"Liveness too large\");\r\n        require(liveness > 0, \"Liveness cannot be 0\");\r\n    }\r\n\r\n    function _validateRequestHash(bytes32 requestId, Request memory request) private view {\r\n        require(\r\n            requests[requestId] == _getRequestHash(request),\r\n            \"Hashed request params do not match existing request hash\"\r\n        );\r\n    }\r\n\r\n    function _storeRequestHash(bytes32 requestId, Request memory request) internal {\r\n        requests[requestId] = _getRequestHash(request);\r\n    }\r\n\r\n    function _getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint32 timestamp,\r\n        bytes memory ancillaryData,\r\n        Request memory request\r\n    ) internal view returns (OptimisticOracleInterface.State) {\r\n        // Note: This function does not check whether all of the _request parameter values are correct. For example,\r\n        // the request.reward could be any value and it would not impact this function's return value. Therefore, it\r\n        // is the caller's responsibility to check that _request matches with the expected ID corresponding to\r\n        // {requester, identifier, timestamp, ancillaryData} via _validateRequestHash().\r\n        if (address(request.currency) == address(0)) return OptimisticOracleInterface.State.Invalid;\r\n\r\n        if (request.proposer == address(0)) return OptimisticOracleInterface.State.Requested;\r\n\r\n        if (request.settled) return OptimisticOracleInterface.State.Settled;\r\n\r\n        if (request.disputer == address(0))\r\n            return\r\n                request.expirationTime <= getCurrentTime()\r\n                    ? OptimisticOracleInterface.State.Expired\r\n                    : OptimisticOracleInterface.State.Proposed;\r\n\r\n        return\r\n            _getOracle().hasPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester))\r\n                ? OptimisticOracleInterface.State.Resolved\r\n                : OptimisticOracleInterface.State.Disputed;\r\n    }\r\n\r\n    function _getOracle() internal view returns (OracleAncillaryInterface) {\r\n        return OracleAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n\r\n    function _getCollateralWhitelist() internal view returns (AddressWhitelist) {\r\n        return AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n    }\r\n\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    /**\r\n     * @dev We don't handle specifically the case where `ancillaryData` is not already readily translateable in utf8.\r\n     * For those cases, we assume that the client will be able to strip out the utf8-translateable part of the\r\n     * ancillary data that this contract stamps.\r\n     */\r\n    function _stampAncillaryData(bytes memory ancillaryData, address requester) internal pure returns (bytes memory) {\r\n        // Since this contract will be the one to formally submit DVM price requests, its useful for voters to know who\r\n        // the original requester was.\r\n        return AncillaryData.appendKeyValueAddress(ancillaryData, \"ooRequester\", requester);\r\n    }\r\n}\r\n\r\n/**\r\n * @notice This is the SkinnyOptimisticOracle contract that should be deployed on live networks. It is exactly the same\r\n * as the regular SkinnyOptimisticOracle contract, but it overrides getCurrentTime to make the call a simply return\r\n * block.timestamp with no branching or storage queries.\r\n */\r\ncontract SkinnyOptimisticOracleProd is SkinnyOptimisticOracle {\r\n    constructor(\r\n        uint256 _liveness,\r\n        address _finderAddress,\r\n        address _timerAddress\r\n    ) SkinnyOptimisticOracle(_liveness, _finderAddress, _timerAddress) {}\r\n\r\n    function getCurrentTime() public view virtual override returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v2/test/OptimisticRequesterTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport \"../implementation/OptimisticOracleV2.sol\";\r\n\r\n// This is just a test contract to make requests to the optimistic oracle.\r\ncontract OptimisticRequesterTest is OptimisticRequester {\r\n    OptimisticOracleV2 optimisticOracle;\r\n    bool public shouldRevert = false;\r\n\r\n    // State variables to track incoming calls.\r\n    bytes32 public identifier;\r\n    uint256 public timestamp;\r\n    bytes public ancillaryData;\r\n    uint256 public refund;\r\n    int256 public price;\r\n\r\n    // Implement collateralCurrency so that this contract simulates a financial contract whose collateral\r\n    // token can be fetched by off-chain clients.\r\n    IERC20 public collateralCurrency;\r\n\r\n    // Manually set an expiration timestamp to simulate expiry price requests\r\n    uint256 public expirationTimestamp;\r\n\r\n    constructor(OptimisticOracleV2 _optimisticOracle) {\r\n        optimisticOracle = _optimisticOracle;\r\n    }\r\n\r\n    function requestPrice(\r\n        bytes32 _identifier,\r\n        uint256 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward\r\n    ) external {\r\n        // Set collateral currency to last requested currency:\r\n        collateralCurrency = currency;\r\n\r\n        currency.approve(address(optimisticOracle), reward);\r\n        optimisticOracle.requestPrice(_identifier, _timestamp, _ancillaryData, currency, reward);\r\n    }\r\n\r\n    function settleAndGetPrice(\r\n        bytes32 _identifier,\r\n        uint256 _timestamp,\r\n        bytes memory _ancillaryData\r\n    ) external returns (int256) {\r\n        return optimisticOracle.settleAndGetPrice(_identifier, _timestamp, _ancillaryData);\r\n    }\r\n\r\n    function setBond(\r\n        bytes32 _identifier,\r\n        uint256 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        uint256 bond\r\n    ) external {\r\n        optimisticOracle.setBond(_identifier, _timestamp, _ancillaryData, bond);\r\n    }\r\n\r\n    function setRefundOnDispute(\r\n        bytes32 _identifier,\r\n        uint256 _timestamp,\r\n        bytes memory _ancillaryData\r\n    ) external {\r\n        optimisticOracle.setRefundOnDispute(_identifier, _timestamp, _ancillaryData);\r\n    }\r\n\r\n    function setCustomLiveness(\r\n        bytes32 _identifier,\r\n        uint256 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        uint256 customLiveness\r\n    ) external {\r\n        optimisticOracle.setCustomLiveness(_identifier, _timestamp, _ancillaryData, customLiveness);\r\n    }\r\n\r\n    function setEventBased(\r\n        bytes32 _identifier,\r\n        uint256 _timestamp,\r\n        bytes memory _ancillaryData\r\n    ) external {\r\n        optimisticOracle.setEventBased(_identifier, _timestamp, _ancillaryData);\r\n    }\r\n\r\n    function setCallbacks(\r\n        bytes32 _identifier,\r\n        uint256 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        bool _callbackOnPriceProposed,\r\n        bool _callbackOnPriceDisputed,\r\n        bool _callbackOnPriceSettled\r\n    ) external {\r\n        optimisticOracle.setCallbacks(\r\n            _identifier,\r\n            _timestamp,\r\n            _ancillaryData,\r\n            _callbackOnPriceProposed,\r\n            _callbackOnPriceDisputed,\r\n            _callbackOnPriceSettled\r\n        );\r\n    }\r\n\r\n    function setRevert(bool _shouldRevert) external {\r\n        shouldRevert = _shouldRevert;\r\n    }\r\n\r\n    function setExpirationTimestamp(uint256 _expirationTimestamp) external {\r\n        expirationTimestamp = _expirationTimestamp;\r\n    }\r\n\r\n    function clearState() external {\r\n        delete identifier;\r\n        delete timestamp;\r\n        delete refund;\r\n        delete price;\r\n    }\r\n\r\n    function priceProposed(\r\n        bytes32 _identifier,\r\n        uint256 _timestamp,\r\n        bytes memory _ancillaryData\r\n    ) external override {\r\n        require(!shouldRevert);\r\n        identifier = _identifier;\r\n        timestamp = _timestamp;\r\n        ancillaryData = _ancillaryData;\r\n    }\r\n\r\n    function priceDisputed(\r\n        bytes32 _identifier,\r\n        uint256 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        uint256 _refund\r\n    ) external override {\r\n        require(!shouldRevert);\r\n        identifier = _identifier;\r\n        timestamp = _timestamp;\r\n        ancillaryData = _ancillaryData;\r\n        refund = _refund;\r\n    }\r\n\r\n    function priceSettled(\r\n        bytes32 _identifier,\r\n        uint256 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        int256 _price\r\n    ) external override {\r\n        require(!shouldRevert);\r\n        identifier = _identifier;\r\n        timestamp = _timestamp;\r\n        ancillaryData = _ancillaryData;\r\n        price = _price;\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v2/test/SkinnyOptimisticRequesterTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../previous-versions/SkinnyOptimisticOracle.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\n\r\n// This is just a test contract to make requests to the optimistic oracle.\r\ncontract SkinnyOptimisticRequesterTest {\r\n    using SafeMath for uint256;\r\n\r\n    SkinnyOptimisticOracle optimisticOracle;\r\n    bool public shouldRevert = false;\r\n\r\n    // Finder to provide addresses for DVM contracts.\r\n    FinderInterface public finder;\r\n\r\n    // State variables to track incoming calls.\r\n    bytes32 public identifier;\r\n    uint32 public timestamp;\r\n    bytes public ancillaryData;\r\n    SkinnyOptimisticOracle.Request public request;\r\n\r\n    // Manually set an expiration timestamp to simulate expiry price requests\r\n    uint256 public expirationTimestamp;\r\n\r\n    constructor(SkinnyOptimisticOracle _optimisticOracle, FinderInterface _finderAddress) {\r\n        optimisticOracle = _optimisticOracle;\r\n        finder = _finderAddress;\r\n    }\r\n\r\n    function requestAndProposePriceFor(\r\n        bytes32 _identifier,\r\n        uint32 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        uint256 bond,\r\n        uint256 customLiveness,\r\n        address proposer,\r\n        int256 proposedPrice\r\n    ) external {\r\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\r\n\r\n        currency.approve(address(optimisticOracle), reward.add(bond).add(finalFee));\r\n        optimisticOracle.requestAndProposePriceFor(\r\n            _identifier,\r\n            _timestamp,\r\n            _ancillaryData,\r\n            currency,\r\n            reward,\r\n            bond,\r\n            customLiveness,\r\n            proposer,\r\n            proposedPrice\r\n        );\r\n    }\r\n\r\n    function requestPrice(\r\n        bytes32 _identifier,\r\n        uint32 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        uint256 bond,\r\n        uint256 customLiveness\r\n    ) external {\r\n        currency.approve(address(optimisticOracle), reward);\r\n        optimisticOracle.requestPrice(_identifier, _timestamp, _ancillaryData, currency, reward, bond, customLiveness);\r\n    }\r\n\r\n    function setExpirationTimestamp(uint256 _expirationTimestamp) external {\r\n        expirationTimestamp = _expirationTimestamp;\r\n    }\r\n\r\n    function setRevert(bool _shouldRevert) external {\r\n        shouldRevert = _shouldRevert;\r\n    }\r\n\r\n    function priceProposed(\r\n        bytes32 _identifier,\r\n        uint32 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        SkinnyOptimisticOracle.Request memory _request\r\n    ) external {\r\n        require(!shouldRevert);\r\n        identifier = _identifier;\r\n        timestamp = _timestamp;\r\n        ancillaryData = _ancillaryData;\r\n        request = _request;\r\n    }\r\n\r\n    function priceDisputed(\r\n        bytes32 _identifier,\r\n        uint32 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        SkinnyOptimisticOracle.Request memory _request\r\n    ) external {\r\n        require(!shouldRevert);\r\n        identifier = _identifier;\r\n        timestamp = _timestamp;\r\n        ancillaryData = _ancillaryData;\r\n        request = _request;\r\n    }\r\n\r\n    function priceSettled(\r\n        bytes32 _identifier,\r\n        uint32 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        SkinnyOptimisticOracle.Request memory _request\r\n    ) external {\r\n        require(!shouldRevert);\r\n        identifier = _identifier;\r\n        timestamp = _timestamp;\r\n        ancillaryData = _ancillaryData;\r\n        request = _request;\r\n    }\r\n\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v2/test/SkinnyOptimisticV2RequesterTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../implementation/SkinnyOptimisticOracleV2.sol\";\r\n\r\n// This is just a test contract to make requests to the optimistic oracle.\r\ncontract SkinnyOptimisticV2RequesterTest {\r\n    using SafeMath for uint256;\r\n\r\n    SkinnyOptimisticOracleV2 optimisticOracle;\r\n    bool public shouldRevert = false;\r\n\r\n    // Finder to provide addresses for DVM contracts.\r\n    FinderInterface public finder;\r\n\r\n    // State variables to track incoming calls.\r\n    bytes32 public identifier;\r\n    uint32 public timestamp;\r\n    bytes public ancillaryData;\r\n    SkinnyOptimisticOracleV2.Request public request;\r\n\r\n    // Manually set an expiration timestamp to simulate expiry price requests\r\n    uint256 public expirationTimestamp;\r\n\r\n    constructor(SkinnyOptimisticOracleV2 _optimisticOracle, FinderInterface _finderAddress) {\r\n        optimisticOracle = _optimisticOracle;\r\n        finder = _finderAddress;\r\n    }\r\n\r\n    function requestAndProposePriceFor(\r\n        bytes32 _identifier,\r\n        uint32 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        SkinnyOptimisticOracleV2Interface.RequestSettings memory requestSettings,\r\n        address proposer,\r\n        int256 proposedPrice\r\n    ) external {\r\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\r\n\r\n        currency.approve(address(optimisticOracle), reward.add(requestSettings.bond).add(finalFee));\r\n        optimisticOracle.requestAndProposePriceFor(\r\n            _identifier,\r\n            _timestamp,\r\n            _ancillaryData,\r\n            currency,\r\n            reward,\r\n            requestSettings,\r\n            proposer,\r\n            proposedPrice\r\n        );\r\n    }\r\n\r\n    function requestPrice(\r\n        bytes32 _identifier,\r\n        uint32 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward,\r\n        SkinnyOptimisticOracleV2Interface.RequestSettings memory requestSettings\r\n    ) external {\r\n        currency.approve(address(optimisticOracle), reward);\r\n        optimisticOracle.requestPrice(_identifier, _timestamp, _ancillaryData, currency, reward, requestSettings);\r\n    }\r\n\r\n    function setExpirationTimestamp(uint256 _expirationTimestamp) external {\r\n        expirationTimestamp = _expirationTimestamp;\r\n    }\r\n\r\n    function setRevert(bool _shouldRevert) external {\r\n        shouldRevert = _shouldRevert;\r\n    }\r\n\r\n    function priceProposed(\r\n        bytes32 _identifier,\r\n        uint32 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        SkinnyOptimisticOracleV2.Request memory _request\r\n    ) external {\r\n        require(!shouldRevert);\r\n        identifier = _identifier;\r\n        timestamp = _timestamp;\r\n        ancillaryData = _ancillaryData;\r\n        request = _request;\r\n    }\r\n\r\n    function priceDisputed(\r\n        bytes32 _identifier,\r\n        uint32 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        SkinnyOptimisticOracleV2.Request memory _request\r\n    ) external {\r\n        require(!shouldRevert);\r\n        identifier = _identifier;\r\n        timestamp = _timestamp;\r\n        ancillaryData = _ancillaryData;\r\n        request = _request;\r\n    }\r\n\r\n    function priceSettled(\r\n        bytes32 _identifier,\r\n        uint32 _timestamp,\r\n        bytes memory _ancillaryData,\r\n        SkinnyOptimisticOracleV2.Request memory _request\r\n    ) external {\r\n        require(!shouldRevert);\r\n        identifier = _identifier;\r\n        timestamp = _timestamp;\r\n        ancillaryData = _ancillaryData;\r\n        request = _request;\r\n    }\r\n\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/ClaimData.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { AncillaryData as ClaimData } from \"../../common/implementation/AncillaryData.sol\";\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/escalation-manager/BaseEscalationManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../../interfaces/EscalationManagerInterface.sol\";\r\nimport \"../../interfaces/OptimisticOracleV3Interface.sol\";\r\n\r\n/**\r\n * @title BaseEscalationManager\r\n * @notice Base contract for escalation managers. This contract is responsible for managing the escalation policy for\r\n * assertions. This base implementation simply exposes the required interface and provides a default implementation\r\n * (returning default values or doing nothing).\r\n */\r\ncontract BaseEscalationManager is EscalationManagerInterface {\r\n    OptimisticOracleV3Interface public immutable optimisticOracleV3;\r\n\r\n    event PriceRequestAdded(bytes32 indexed identifier, uint256 time, bytes ancillaryData);\r\n\r\n    /**\r\n     * @notice Reverts unless the configured Optimistic Oracle V3 is the caller.\r\n     */\r\n    modifier onlyOptimisticOracleV3() {\r\n        require(msg.sender == address(optimisticOracleV3), \"Not the Optimistic Oracle V3\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructs the escalation manager.\r\n     * @param _optimisticOracleV3 the Optimistic Oracle V3 to use.\r\n     */\r\n    constructor(address _optimisticOracleV3) {\r\n        optimisticOracleV3 = OptimisticOracleV3Interface(_optimisticOracleV3);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the assertion policy for the given assertionId.\r\n     * @param assertionId the assertionId to get the assertion policy for.\r\n     * @return the assertion policy for the given assertionId.\r\n     */\r\n    function getAssertionPolicy(bytes32 assertionId) public view virtual returns (AssertionPolicy memory) {\r\n        return\r\n            AssertionPolicy({\r\n                blockAssertion: false,\r\n                arbitrateViaEscalationManager: false,\r\n                discardOracle: false,\r\n                validateDisputers: false\r\n            });\r\n    }\r\n\r\n    /**\r\n     * @notice Callback function that is called by Optimistic Oracle V3 when an assertion is disputed. Used to validate\r\n     * if the dispute should be allowed based on the escalation policy.\r\n     * @param assertionId the assertionId to validate the dispute for.\r\n     * @param disputeCaller the caller of the dispute function.\r\n     * @return bool true if the dispute is allowed, false otherwise.\r\n     */\r\n    function isDisputeAllowed(bytes32 assertionId, address disputeCaller) public view virtual returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Implements price getting logic. This method is called by Optimistic Oracle V3 settling an assertion that\r\n     * is configured to use the escalation manager as the oracle. The interface is constructed to mimic the UMA DVM.\r\n     * @param identifier price identifier being requested.\r\n     * @param time timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return price from the escalation manager to inform the resolution of the dispute.\r\n     */\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (int256) {}\r\n\r\n    /**\r\n     * @notice Implements price requesting logic for the escalation manager. This function is called by the Optimistic\r\n     * Oracle V3 on dispute and is constructed to mimic that of the UMA DVM interface.\r\n     * @param identifier the identifier to fetch the price for.\r\n     * @param time the time to fetch the price for.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public virtual onlyOptimisticOracleV3 {\r\n        emit PriceRequestAdded(identifier, time, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Callback function that is called by Optimistic Oracle V3 when an assertion is resolved.\r\n     * @param assertionId The identifier of the assertion that was resolved.\r\n     * @param assertedTruthfully Whether the assertion was resolved as truthful or not.\r\n     */\r\n    function assertionResolvedCallback(bytes32 assertionId, bool assertedTruthfully)\r\n        public\r\n        virtual\r\n        onlyOptimisticOracleV3\r\n    {}\r\n\r\n    /**\r\n     * @notice Callback function that is called by Optimistic Oracle V3 when an assertion is disputed.\r\n     * @param assertionId The identifier of the assertion that was disputed.\r\n     */\r\n    function assertionDisputedCallback(bytes32 assertionId) public virtual onlyOptimisticOracleV3 {}\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/escalation-manager/DisputeLimitingEscalationManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./BaseEscalationManager.sol\";\r\n\r\n// This Escalation Manager blocks all assertions till the blocking dispute is resolved by Oracle. In order to avoid\r\n// interference among different applications this Escalation Manager allows assertions only from one requesting contract.\r\n// This is useful to create a system where only one assertion dispute can occur at a time.\r\ncontract DisputeLimitingEscalationManager is BaseEscalationManager, Ownable {\r\n    // Address of linked requesting contract. Before this is set via setAssertingCaller all assertions will be blocked.\r\n    address public assertingCaller;\r\n\r\n    bytes32 public disputedAssertionId;\r\n\r\n    event AssertingCallerSet(address indexed assertingCaller);\r\n\r\n    constructor(address _optimisticOracleV3) BaseEscalationManager(_optimisticOracleV3) {}\r\n\r\n    // Set the address of the contract that will be allowed to use Optimistic Oracle V3.\r\n    // This can only be set once. We do not set this at constructor just to allow for some flexibility in the ordering\r\n    // of how contracts are deployed.\r\n    function setAssertingCaller(address _assertingCaller) public onlyOwner {\r\n        require(_assertingCaller != address(0), \"Invalid asserting caller\");\r\n        require(assertingCaller == address(0), \"Asserting caller already set\");\r\n        assertingCaller = _assertingCaller;\r\n        emit AssertingCallerSet(_assertingCaller);\r\n    }\r\n\r\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\r\n        return\r\n            AssertionPolicy({\r\n                blockAssertion: _checkIfShouldBlockAssertion(assertionId),\r\n                arbitrateViaEscalationManager: false,\r\n                discardOracle: false,\r\n                validateDisputers: false\r\n            });\r\n    }\r\n\r\n    // Callback function that is called by Optimistic Oracle V3 when an assertion is disputed.\r\n    function assertionDisputedCallback(bytes32 assertionId) public override onlyOptimisticOracleV3 {\r\n        // Only apply new assertion block if the dispute is related to the linked client contract.\r\n        if (optimisticOracleV3.getAssertion(assertionId).escalationManagerSettings.assertingCaller == assertingCaller) {\r\n            disputedAssertionId = assertionId;\r\n        }\r\n    }\r\n\r\n    // Callback function that is called by Optimistic Oracle V3 when an assertion is resolved.\r\n    function assertionResolvedCallback(bytes32 assertionId, bool) public override onlyOptimisticOracleV3 {\r\n        // Remove assertion block if the disputed assertion was resolved.\r\n        if (assertionId == disputedAssertionId) disputedAssertionId = bytes32(0);\r\n    }\r\n\r\n    function _checkIfShouldBlockAssertion(bytes32 assertionId) internal view returns (bool) {\r\n        OptimisticOracleV3Interface.Assertion memory assertion = optimisticOracleV3.getAssertion(assertionId);\r\n        if (assertion.escalationManagerSettings.assertingCaller != assertingCaller) return true; // Only allow assertions through linked client contract.\r\n        return disputedAssertionId != bytes32(0); // Block if there is outstanding dispute.\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/escalation-manager/FullPolicyEscalationManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./BaseEscalationManager.sol\";\r\n\r\n/**\r\n * @title The FullPolicyEscalationManager enables the owner to configure all policy parameters and store the arbitration\r\n * resolutions for the Escalation Manager. Optionally, assertion blocking can be enabled using a whitelist of\r\n * assertingCallers or assertingCallers and asserters. On the other hand, it enables the determination of whether to\r\n * arbitrate via the escalation manager as opposed to the DVM, whether to disregard the resolution of a potential\r\n * dispute arbitrated by the Oracle, and whether to restrict who can register disputes via whitelistedDisputeCallers.\r\n * @dev If nothing is configured using the setters and configureEscalationManager method upon deployment, the\r\n * FullPolicyEscalationManager will return a default policy with all values set to false.\r\n */\r\ncontract FullPolicyEscalationManager is BaseEscalationManager, Ownable {\r\n    // Struct to store the arbitration resolution for a given identifier, time, and ancillary data.\r\n    struct ArbitrationResolution {\r\n        bool valueSet; // True if the resolution has been set.\r\n        bool resolution; // True or false depending on the resolution.\r\n    }\r\n\r\n    event EscalationManagerConfigured(\r\n        bool blockByAssertingCaller,\r\n        bool blockByAsserter,\r\n        bool validateDisputers,\r\n        bool arbitrateViaEscalationManager,\r\n        bool discardOracle\r\n    );\r\n\r\n    event ArbitrationResolutionSet(bytes32 indexed identifier, uint256 time, bytes ancillaryData, bool resolution);\r\n\r\n    event DisputeCallerWhitelistSet(address indexed disputeCaller, bool whitelisted);\r\n\r\n    event AssertingCallerWhitelistSet(address indexed assertingCaller, bool whitelisted);\r\n\r\n    event AsserterWhitelistSet(address indexed asserter, bool whitelisted);\r\n\r\n    int256 public constant numericalTrue = 1e18; // Numerical representation of true.\r\n\r\n    bool public blockByAssertingCaller; // True if assertions are allowed only by whitelisted asserting callers.\r\n\r\n    bool public blockByAsserter; // True if assertions are allowed only by whitelisted asserters.\r\n\r\n    bool public arbitrateViaEscalationManager; // True if it is determined that the escalation manager should arbitrate.\r\n\r\n    bool public discardOracle; // True if escalation manager should disregard the Oracle's resolution.\r\n\r\n    bool public validateDisputers; // True if escalation manager should validate disputers via whitelistedDisputeCallers.\r\n\r\n    mapping(bytes32 => ArbitrationResolution) public arbitrationResolutions; // Arbitration resolutions for a given identifier, time, and ancillary data.\r\n\r\n    mapping(address => bool) public whitelistedDisputeCallers; // Whitelisted disputer that can file disputes.\r\n\r\n    mapping(address => bool) public whitelistedAssertingCallers; // Whitelisted assertingCallers that can assert prices.\r\n\r\n    mapping(address => bool) public whitelistedAsserters; // Whitelisted asserters that can assert prices.\r\n\r\n    /**\r\n     * @notice Constructs the escalation manager.\r\n     * @param _optimisticOracleV3 the Optimistic Oracle V3 to use.\r\n     */\r\n    constructor(address _optimisticOracleV3) BaseEscalationManager(_optimisticOracleV3) {}\r\n\r\n    /**\r\n     * @notice Returns the Assertion Policy defined by this contract's parameters and functions.\r\n     * @param assertionId the ID of the assertion to get the policy for.\r\n     * @return the Assertion Policy defined by this contract's parameters and functions.\r\n     * @dev If no configuration is done after deployment, this function returns an all false default policy.\r\n     */\r\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\r\n        bool blocked = _checkIfAssertionBlocked(assertionId);\r\n        return\r\n            AssertionPolicy({\r\n                blockAssertion: blocked, // Block assertion if it is blocked.\r\n                arbitrateViaEscalationManager: arbitrateViaEscalationManager, // Arbitrate via escalation manager if configured.\r\n                discardOracle: discardOracle, // Ignore Oracle (DVM or EM) resolution if configured.\r\n                validateDisputers: validateDisputers // Validate disputers if configured.\r\n            });\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the price for identifier and time if it has already been requested and resolved.\r\n     * @dev If the price is not available, the method reverts.\r\n     * @param identifier uniquely identifies the price requested.\r\n     * @param time unix timestamp of the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return int256 representing the resolved price for the given identifier and timestamp.\r\n     * @dev This function replicates the interface of the corresponding DVM function to allow the user to use his own\r\n     * dispute arbitration system when arbitrating via the escalation manager in a DVM-compatible manner. Refer to the\r\n     * UMA Voting and VotingV2 contracts for further details.\r\n     */\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override returns (int256) {\r\n        bytes32 requestId = getRequestId(identifier, time, ancillaryData);\r\n        require(arbitrationResolutions[requestId].valueSet, \"Arbitration resolution not set\");\r\n        if (arbitrationResolutions[requestId].resolution) return numericalTrue;\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns, given an assertionId and a disputerCaller address, if the disputerCaller is authorised to\r\n     * dispute the assertion.\r\n     * @param assertionId the ID of the assertion to check the disputerCaller for.\r\n     * @param disputeCaller the address of the disputeCaller to check.\r\n     * @return true if the disputerCaller is authorised to dispute the assertion.\r\n     * @dev In order for this function to be used by the Optimistic Oracle V3, validateDisputers must be set to true.\r\n     */\r\n    function isDisputeAllowed(bytes32 assertionId, address disputeCaller) public view override returns (bool) {\r\n        return whitelistedDisputeCallers[disputeCaller];\r\n    }\r\n\r\n    /**\r\n     * @notice Defines how the assertion policy for each configuration's rules is to be defined.\r\n     * @param _blockByAssertingCaller true if assertions are allowed only by whitelisted asserting callers.\r\n     * @param _blockByAsserter true if assertions are allowed only by whitelisted asserters.\r\n     * @param _validateDisputers true if the escalation manager should validate disputers via whitelistedDisputeCallers.\r\n     * @param _arbitrateViaEscalationManager true if the escalation manager should arbitrate instead of the DVM.\r\n     * @param _discardOracle true if the escalation manager should disregard the Oracle's (DVM or EM) resolution.\r\n     * @dev This setting just activates the rules that will be executed; each rule must additionally be defined using\r\n     * the other functions.\r\n     */\r\n    function configureEscalationManager(\r\n        bool _blockByAssertingCaller,\r\n        bool _blockByAsserter,\r\n        bool _validateDisputers,\r\n        bool _arbitrateViaEscalationManager,\r\n        bool _discardOracle\r\n    ) public onlyOwner {\r\n        require(!_blockByAsserter || _blockByAssertingCaller, \"Cannot block only by asserter\");\r\n        blockByAssertingCaller = _blockByAssertingCaller;\r\n        blockByAsserter = _blockByAsserter;\r\n        validateDisputers = _validateDisputers;\r\n        arbitrateViaEscalationManager = _arbitrateViaEscalationManager;\r\n        discardOracle = _discardOracle;\r\n        emit EscalationManagerConfigured(\r\n            _blockByAssertingCaller,\r\n            _blockByAsserter,\r\n            _validateDisputers,\r\n            _arbitrateViaEscalationManager,\r\n            _discardOracle\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Set the arbitration resolution for a given identifier, time, and ancillary data.\r\n     * @param identifier uniquely identifies the price requested.\r\n     * @param time unix timestamp of the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param arbitrationResolution true if the assertion should be resolved as true, false otherwise.\r\n     * @dev The owner should use this function whenever a dispute arises and it should be arbitrated by the Escalation\r\n     * Manager; it is up to the owner to determine how to resolve the dispute. See the requestPrice implementation in\r\n     * BaseEscalationManager, which escalates a dispute to the Escalation Manager for resolution.\r\n     */\r\n    function setArbitrationResolution(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bool arbitrationResolution\r\n    ) public onlyOwner {\r\n        bytes32 requestId = getRequestId(identifier, time, ancillaryData);\r\n        require(arbitrationResolutions[requestId].valueSet == false, \"Arbitration already resolved\");\r\n        arbitrationResolutions[requestId] = ArbitrationResolution(true, arbitrationResolution);\r\n        emit ArbitrationResolutionSet(identifier, time, ancillaryData, arbitrationResolution);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds/removes a disputeCaller to the whitelist of disputers that can file disputes.\r\n     * @param disputeCaller the address of the disputeCaller to add.\r\n     * @param value true represents adding and false represents removing the disputeCaller from the whitelist.\r\n     * @dev This function is only used if validateDisputers is set to true.\r\n     */\r\n    function setDisputeCallerInWhitelist(address disputeCaller, bool value) public onlyOwner {\r\n        whitelistedDisputeCallers[disputeCaller] = value;\r\n        emit DisputeCallerWhitelistSet(disputeCaller, value);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds/removes an asserter to the whitelist of assertingCallers that can make assertions.\r\n     * @param assertingCaller the address of the assertingCaller to add.\r\n     * @param value true represents adding and false represents removing the assertingCaller from the whitelist.\r\n     */\r\n    function setWhitelistedAssertingCallers(address assertingCaller, bool value) public onlyOwner {\r\n        whitelistedAssertingCallers[assertingCaller] = value;\r\n        emit AssertingCallerWhitelistSet(assertingCaller, value);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds/removes an asserter to the whitelist of asserters that can make assertions.\r\n     * @param asserter the address of the asserter to add.\r\n     * @param value true represents adding and false represents removing the asserter from the whitelist.\r\n     * @dev This function must be used in conjunction with setWhitelistedAssertingCallers in order to have an effect.\r\n     */\r\n    function setWhitelistedAsserters(address asserter, bool value) public onlyOwner {\r\n        whitelistedAsserters[asserter] = value;\r\n        emit AsserterWhitelistSet(asserter, value);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates price request identifier for a given identifier, time, and ancillary data.\r\n     * @param identifier uniquely identifies the price requested.\r\n     * @param time unix timestamp of the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return price request identifier.\r\n     */\r\n    function getRequestId(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encode(identifier, time, ancillaryData));\r\n    }\r\n\r\n    // Checks if an assertion is blocked depending on the blockByAssertingCaller / blockByAsserter settings and the\r\n    // assertion's properties.\r\n    function _checkIfAssertionBlocked(bytes32 assertionId) internal view returns (bool) {\r\n        OptimisticOracleV3Interface.Assertion memory assertion = optimisticOracleV3.getAssertion(assertionId);\r\n        return\r\n            (blockByAssertingCaller &&\r\n                !whitelistedAssertingCallers[assertion.escalationManagerSettings.assertingCaller]) ||\r\n            (blockByAsserter && !whitelistedAsserters[assertion.asserter]);\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/escalation-manager/OwnerDiscardOracleEscalationManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./BaseEscalationManager.sol\";\r\n\r\ncontract OwnerDiscardOracleEscalationManager is BaseEscalationManager, Ownable {\r\n    bool public discardOracle;\r\n\r\n    constructor(address _optimisticOracleV3) BaseEscalationManager(_optimisticOracleV3) {}\r\n\r\n    function setDiscardOracle(bool value) public onlyOwner {\r\n        discardOracle = value;\r\n    }\r\n\r\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\r\n        return\r\n            AssertionPolicy({\r\n                blockAssertion: false,\r\n                arbitrateViaEscalationManager: false,\r\n                discardOracle: discardOracle,\r\n                validateDisputers: false\r\n            });\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/escalation-manager/OwnerSelectOracleEscalationManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./BaseEscalationManager.sol\";\r\n\r\ncontract OwnerSelectOracleEscalationManager is BaseEscalationManager, Ownable {\r\n    struct ArbitrationResolution {\r\n        bool valueSet;\r\n        bool resolution;\r\n    }\r\n\r\n    mapping(bytes32 => ArbitrationResolution) arbitrationResolutions;\r\n\r\n    bool arbitrateViaEscalationManager;\r\n\r\n    constructor(address _optimisticOracleV3) BaseEscalationManager(_optimisticOracleV3) {}\r\n\r\n    function setArbitrationResolution(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        bool arbitrationResolution\r\n    ) public onlyOwner {\r\n        bytes32 requestId = keccak256(abi.encode(identifier, time, ancillaryData));\r\n        arbitrationResolutions[requestId] = ArbitrationResolution(true, arbitrationResolution);\r\n    }\r\n\r\n    function setArbitrateViaSs(bool value) public onlyOwner {\r\n        arbitrateViaEscalationManager = value;\r\n    }\r\n\r\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\r\n        return\r\n            AssertionPolicy({\r\n                blockAssertion: false,\r\n                arbitrateViaEscalationManager: arbitrateViaEscalationManager,\r\n                discardOracle: false,\r\n                validateDisputers: false\r\n            });\r\n    }\r\n\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override returns (int256) {\r\n        bytes32 requestId = keccak256(abi.encode(identifier, time, ancillaryData));\r\n        require(arbitrationResolutions[requestId].valueSet, \"Arbitration resolution not set\");\r\n        if (arbitrationResolutions[requestId].resolution) return 1e18;\r\n        return 0;\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/escalation-manager/SuperbondEscalationManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"./BaseEscalationManager.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n// This EscalationManager allows to arbitrate for each assertion based on its bond via the DVM or the EscalationManager.\r\n// If the bond is greater than the superbond, it is arbitrated automatically through the EscalationManager; otherwise,\r\n// it is arbitrated through the DVM.\r\ncontract SuperbondEscalationManager is BaseEscalationManager, Ownable {\r\n    uint256 public superbond;\r\n    address public superbondCurrency;\r\n\r\n    constructor(address _optimisticOracleV3) BaseEscalationManager(_optimisticOracleV3) {}\r\n\r\n    function setSuperbond(uint256 newSuperbond) public onlyOwner {\r\n        superbond = newSuperbond;\r\n    }\r\n\r\n    function setSuperbondCurrency(address newSuperbondCurrency) public onlyOwner {\r\n        superbondCurrency = newSuperbondCurrency;\r\n    }\r\n\r\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\r\n        OptimisticOracleV3Interface.Assertion memory assertion = optimisticOracleV3.getAssertion(assertionId);\r\n        bool isSuperbondCurrency = address(assertion.currency) == superbondCurrency;\r\n        return\r\n            AssertionPolicy({\r\n                blockAssertion: false,\r\n                arbitrateViaEscalationManager: isSuperbondCurrency ? assertion.bond > superbond : false,\r\n                discardOracle: false,\r\n                validateDisputers: false\r\n            });\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/escalation-manager/WhitelistAsserterEscalationManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./BaseEscalationManager.sol\";\r\n\r\ncontract WhitelistAsserterEscalationManager is BaseEscalationManager, Ownable {\r\n    // Address of linked requesting contract. Before this is set via setAssertingCaller all assertions will be blocked.\r\n    // Security of returning correct policy depends on requesting contract passing msg.sender as asserter.\r\n    address public assertingCaller;\r\n\r\n    mapping(address => bool) public whitelistedAsserters;\r\n\r\n    event AssertingCallerSet(address indexed assertingCaller);\r\n\r\n    constructor(address _optimisticOracleV3) BaseEscalationManager(_optimisticOracleV3) {}\r\n\r\n    // Set the address of the contract that will be allowed to use Optimistic Oracle V3.\r\n    // This can only be set once. We do not set this at constructor just to allow for some flexibility in the ordering\r\n    // of how contracts are deployed.\r\n    function setAssertingCaller(address _assertingCaller) public onlyOwner {\r\n        require(_assertingCaller != address(0), \"Invalid asserting caller\");\r\n        require(assertingCaller == address(0), \"Asserting caller already set\");\r\n        assertingCaller = _assertingCaller;\r\n        emit AssertingCallerSet(_assertingCaller);\r\n    }\r\n\r\n    function setAsserterInWhitelist(address asserter, bool value) public onlyOwner {\r\n        whitelistedAsserters[asserter] = value;\r\n    }\r\n\r\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\r\n        OptimisticOracleV3Interface.Assertion memory assertion = optimisticOracleV3.getAssertion(assertionId);\r\n        bool blocked = _checkIfAssertionBlocked(assertion);\r\n        return\r\n            AssertionPolicy({\r\n                blockAssertion: blocked,\r\n                arbitrateViaEscalationManager: false,\r\n                discardOracle: false,\r\n                validateDisputers: false\r\n            });\r\n    }\r\n\r\n    function _checkIfAssertionBlocked(OptimisticOracleV3Interface.Assertion memory assertion)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (assertion.escalationManagerSettings.assertingCaller != assertingCaller) return true; // Only allow assertions through linked client contract.\r\n        return !whitelistedAsserters[assertion.asserter]; // Return if asserter is not whitelisted.\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/escalation-manager/WhitelistCallerEscalationManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./BaseEscalationManager.sol\";\r\n\r\ncontract WhitelistCallerEscalationManager is BaseEscalationManager, Ownable {\r\n    mapping(address => bool) whitelistedAssertingCallers;\r\n\r\n    constructor(address _optimisticOracleV3) BaseEscalationManager(_optimisticOracleV3) {}\r\n\r\n    function setAssertingCallerInWhitelist(address assertingCaller, bool value) public onlyOwner {\r\n        whitelistedAssertingCallers[assertingCaller] = value;\r\n    }\r\n\r\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\r\n        return\r\n            AssertionPolicy({\r\n                blockAssertion: !whitelistedAssertingCallers[\r\n                    optimisticOracleV3.getAssertion(assertionId).escalationManagerSettings.assertingCaller\r\n                ],\r\n                arbitrateViaEscalationManager: false,\r\n                discardOracle: false,\r\n                validateDisputers: false\r\n            });\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/escalation-manager/WhitelistDisputerEscalationManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./BaseEscalationManager.sol\";\r\n\r\ncontract WhitelistDisputerEscalationManager is BaseEscalationManager, Ownable {\r\n    mapping(address => bool) whitelistedDisputeCallers;\r\n\r\n    constructor(address _optimisticOracleV3) BaseEscalationManager(_optimisticOracleV3) {}\r\n\r\n    function getAssertionPolicy(bytes32 assertionId) public view override returns (AssertionPolicy memory) {\r\n        return\r\n            AssertionPolicy({\r\n                blockAssertion: false,\r\n                arbitrateViaEscalationManager: false,\r\n                discardOracle: false,\r\n                validateDisputers: true\r\n            });\r\n    }\r\n\r\n    function setDisputeCallerInWhitelist(address disputeCaller, bool value) public onlyOwner {\r\n        whitelistedDisputeCallers[disputeCaller] = value;\r\n    }\r\n\r\n    function isDisputeAllowed(bytes32 assertionId, address disputeCaller) public view override returns (bool) {\r\n        return whitelistedDisputeCallers[disputeCaller];\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/examples/DataAsserter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../implementation/ClaimData.sol\";\r\nimport \"../../interfaces/OptimisticOracleV3Interface.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n// This contract allows assertions on any form of data to be made using the UMA Optimistic Oracle V3 and stores the\r\n// proposed value so that it may be retrieved on chain. The dataId is intended to be an arbitrary value that uniquely\r\n// identifies a specific piece of information in the consuming contract and is replaceable. Similarly, any data\r\n// structure can be used to replace the asserted data.\r\ncontract DataAsserter {\r\n    using SafeERC20 for IERC20;\r\n    IERC20 public immutable defaultCurrency;\r\n    OptimisticOracleV3Interface public immutable oo;\r\n    uint64 public constant assertionLiveness = 7200;\r\n    bytes32 public immutable defaultIdentifier;\r\n\r\n    struct DataAssertion {\r\n        bytes32 dataId; // The dataId that was asserted.\r\n        bytes32 data; // This could be an arbitrary data type.\r\n        address asserter; // The address that made the assertion.\r\n        bool resolved; // Whether the assertion has been resolved.\r\n    }\r\n\r\n    mapping(bytes32 => DataAssertion) public assertionsData;\r\n\r\n    event DataAsserted(bytes32 indexed dataId, bytes32 data, address indexed asserter, bytes32 assertionId);\r\n\r\n    event DataAssertionResolved(bytes32 indexed dataId, bytes32 data, address indexed asserter, bytes32 assertionId);\r\n\r\n    constructor(address _defaultCurrency, address _optimisticOracleV3) {\r\n        defaultCurrency = IERC20(_defaultCurrency);\r\n        oo = OptimisticOracleV3Interface(_optimisticOracleV3);\r\n        defaultIdentifier = oo.defaultIdentifier();\r\n    }\r\n\r\n    // For a given assertionId, returns a boolean indicating whether the data is accessible and the data itself.\r\n    function getData(bytes32 assertionId) public view returns (bool, bytes32) {\r\n        if (!assertionsData[assertionId].resolved) return (false, 0);\r\n        return (true, assertionsData[assertionId].data);\r\n    }\r\n\r\n    // Asserts data for a specific dataId on behalf of an asserter address.\r\n    // Data can be asserted many times with the same combination of arguments, resulting in unique assertionIds. This is\r\n    // because the block.timestamp is included in the claim. The consumer contract must store the returned assertionId\r\n    // identifiers to able to get the information using getData.\r\n    function assertDataFor(\r\n        bytes32 dataId,\r\n        bytes32 data,\r\n        address asserter\r\n    ) public returns (bytes32 assertionId) {\r\n        asserter = asserter == address(0) ? msg.sender : asserter;\r\n        uint256 bond = oo.getMinimumBond(address(defaultCurrency));\r\n        defaultCurrency.safeTransferFrom(msg.sender, address(this), bond);\r\n        defaultCurrency.safeApprove(address(oo), bond);\r\n\r\n        // The claim we want to assert is the first argument of assertTruth. It must contain all of the relevant\r\n        // details so that anyone may verify the claim without having to read any further information on chain. As a\r\n        // result, the claim must include both the data id and data, as well as a set of instructions that allow anyone\r\n        // to verify the information in publicly available sources.\r\n        // See the UMIP corresponding to the defaultIdentifier used in the OptimisticOracleV3 \"ASSERT_TRUTH\" for more\r\n        // information on how to construct the claim.\r\n        assertionId = oo.assertTruth(\r\n            abi.encodePacked(\r\n                \"Data asserted: 0x\", // in the example data is type bytes32 so we add the hex prefix 0x.\r\n                ClaimData.toUtf8Bytes(data),\r\n                \" for dataId: 0x\",\r\n                ClaimData.toUtf8Bytes(dataId),\r\n                \" and asserter: 0x\",\r\n                ClaimData.toUtf8BytesAddress(asserter),\r\n                \" at timestamp: \",\r\n                ClaimData.toUtf8BytesUint(block.timestamp),\r\n                \" in the DataAsserter contract at 0x\",\r\n                ClaimData.toUtf8BytesAddress(address(this)),\r\n                \" is valid.\"\r\n            ),\r\n            asserter,\r\n            address(this),\r\n            address(0), // No sovereign security.\r\n            assertionLiveness,\r\n            defaultCurrency,\r\n            bond,\r\n            defaultIdentifier,\r\n            bytes32(0) // No domain.\r\n        );\r\n        assertionsData[assertionId] = DataAssertion(dataId, data, asserter, false);\r\n        emit DataAsserted(dataId, data, asserter, assertionId);\r\n    }\r\n\r\n    // OptimisticOracleV3 resolve callback.\r\n    function assertionResolvedCallback(bytes32 assertionId, bool assertedTruthfully) public {\r\n        require(msg.sender == address(oo));\r\n        // If the assertion was true, then the data assertion is resolved.\r\n        if (assertedTruthfully) {\r\n            assertionsData[assertionId].resolved = true;\r\n            DataAssertion memory dataAssertion = assertionsData[assertionId];\r\n            emit DataAssertionResolved(dataAssertion.dataId, dataAssertion.data, dataAssertion.asserter, assertionId);\r\n            // Else delete the data assertion if it was false to save gas.\r\n        } else delete assertionsData[assertionId];\r\n    }\r\n\r\n    // If assertion is disputed, do nothing and wait for resolution.\r\n    // This OptimisticOracleV3 callback function needs to be defined so the OOv3 doesn't revert when it tries to call it.\r\n    function assertionDisputedCallback(bytes32 assertionId) public {}\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/examples/Insurance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../implementation/ClaimData.sol\";\r\nimport \"../../interfaces/OptimisticOracleV3Interface.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n// This Isurance contract enables for the issuance of a single unlimited time policy per event/payout recipient There is\r\n// no limit to the number of payout requests that can be made of the same policy; however, only the first asserted\r\n// request will settle the insurance payment, whereas OOv3 will settle bonds for all requestors.\r\ncontract Insurance {\r\n    using SafeERC20 for IERC20;\r\n    IERC20 public immutable defaultCurrency;\r\n    OptimisticOracleV3Interface public immutable oo;\r\n    uint64 public constant assertionLiveness = 7200;\r\n    bytes32 public immutable defaultIdentifier;\r\n\r\n    struct Policy {\r\n        uint256 insuranceAmount;\r\n        address payoutAddress;\r\n        bytes insuredEvent;\r\n        bool settled;\r\n    }\r\n\r\n    mapping(bytes32 => bytes32) public assertedPolicies;\r\n\r\n    mapping(bytes32 => Policy) public policies;\r\n\r\n    event InsuranceIssued(\r\n        bytes32 indexed policyId,\r\n        bytes insuredEvent,\r\n        uint256 insuranceAmount,\r\n        address indexed payoutAddress\r\n    );\r\n\r\n    event InsurancePayoutRequested(bytes32 indexed policyId, bytes32 indexed assertionId);\r\n\r\n    event InsurancePayoutSettled(bytes32 indexed policyId, bytes32 indexed assertionId);\r\n\r\n    constructor(address _defaultCurrency, address _optimisticOracleV3) {\r\n        defaultCurrency = IERC20(_defaultCurrency);\r\n        oo = OptimisticOracleV3Interface(_optimisticOracleV3);\r\n        defaultIdentifier = oo.defaultIdentifier();\r\n    }\r\n\r\n    function issueInsurance(\r\n        uint256 insuranceAmount,\r\n        address payoutAddress,\r\n        bytes memory insuredEvent\r\n    ) public returns (bytes32 policyId) {\r\n        policyId = keccak256(abi.encode(insuredEvent, payoutAddress));\r\n        require(policies[policyId].payoutAddress == address(0), \"Policy already exists\");\r\n        policies[policyId] = Policy({\r\n            insuranceAmount: insuranceAmount,\r\n            payoutAddress: payoutAddress,\r\n            insuredEvent: insuredEvent,\r\n            settled: false\r\n        });\r\n        defaultCurrency.safeTransferFrom(msg.sender, address(this), insuranceAmount);\r\n        emit InsuranceIssued(policyId, insuredEvent, insuranceAmount, payoutAddress);\r\n    }\r\n\r\n    function requestPayout(bytes32 policyId) public returns (bytes32 assertionId) {\r\n        require(policies[policyId].payoutAddress != address(0), \"Policy does not exist\");\r\n        uint256 bond = oo.getMinimumBond(address(defaultCurrency));\r\n        defaultCurrency.safeTransferFrom(msg.sender, address(this), bond);\r\n        defaultCurrency.safeApprove(address(oo), bond);\r\n        assertionId = oo.assertTruth(\r\n            abi.encodePacked(\r\n                \"Insurance contract is claiming that insurance event \",\r\n                policies[policyId].insuredEvent,\r\n                \" had occurred as of \",\r\n                ClaimData.toUtf8BytesUint(block.timestamp),\r\n                \".\"\r\n            ),\r\n            msg.sender,\r\n            address(this),\r\n            address(0), // No sovereign security.\r\n            assertionLiveness,\r\n            defaultCurrency,\r\n            bond,\r\n            defaultIdentifier,\r\n            bytes32(0) // No domain.\r\n        );\r\n        assertedPolicies[assertionId] = policyId;\r\n        emit InsurancePayoutRequested(policyId, assertionId);\r\n    }\r\n\r\n    function assertionResolvedCallback(bytes32 assertionId, bool assertedTruthfully) public {\r\n        require(msg.sender == address(oo));\r\n        // If the assertion was true, then the policy is settled.\r\n        if (assertedTruthfully) {\r\n            _settlePayout(assertionId);\r\n        }\r\n    }\r\n\r\n    function assertionDisputedCallback(bytes32 assertionId) public {}\r\n\r\n    function _settlePayout(bytes32 assertionId) internal {\r\n        // If already settled, do nothing. We don't revert because this function is called by the\r\n        // OptimisticOracleV3, which may block the assertion resolution.\r\n        bytes32 policyId = assertedPolicies[assertionId];\r\n        Policy storage policy = policies[policyId];\r\n        if (policy.settled) return;\r\n        policy.settled = true;\r\n        defaultCurrency.safeTransfer(policy.payoutAddress, policy.insuranceAmount);\r\n        emit InsurancePayoutSettled(policyId, assertionId);\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/examples/PredictionMarket.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../../../common/implementation/AddressWhitelist.sol\";\r\nimport \"../../../common/implementation/ExpandedERC20.sol\";\r\nimport \"../../../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../implementation/ClaimData.sol\";\r\nimport \"../../interfaces/OptimisticOracleV3Interface.sol\";\r\nimport \"../../interfaces/OptimisticOracleV3CallbackRecipientInterface.sol\";\r\n\r\n// This contract allows to initialize prediction markets each having a pair of binary outcome tokens. Anyone can mint\r\n// and burn the same amount of paired outcome tokens for the default payout currency. Trading of outcome tokens is\r\n// outside the scope of this contract. Anyone can assert 3 possible outcomes (outcome 1, outcome 2 or split) that is\r\n// verified through Optimistic Oracle V3. If the assertion is resolved true then holders of outcome tokens can settle\r\n// them for the payout currency based on resolved market outcome.\r\ncontract PredictionMarket is OptimisticOracleV3CallbackRecipientInterface {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct Market {\r\n        bool resolved; // True if the market has been resolved and payouts can be settled.\r\n        bytes32 assertedOutcomeId; // Hash of asserted outcome (outcome1, outcome2 or unresolvable).\r\n        ExpandedIERC20 outcome1Token; // ERC20 token representing the value of the first outcome.\r\n        ExpandedIERC20 outcome2Token; // ERC20 token representing the value of the second outcome.\r\n        uint256 reward; // Reward available for asserting true market outcome.\r\n        uint256 requiredBond; // Expected bond to assert market outcome (OOv3 can require higher bond).\r\n        bytes outcome1; // Short name of the first outcome.\r\n        bytes outcome2; // Short name of the second outcome.\r\n        bytes description; // Description of the market.\r\n    }\r\n\r\n    struct AssertedMarket {\r\n        address asserter; // Address of the asserter used for reward payout.\r\n        bytes32 marketId; // Identifier for markets mapping.\r\n    }\r\n\r\n    mapping(bytes32 => Market) public markets; // Maps marketId to Market struct.\r\n\r\n    mapping(bytes32 => AssertedMarket) public assertedMarkets; // Maps assertionId to AssertedMarket.\r\n\r\n    FinderInterface public immutable finder; // UMA protocol Finder used to discover other protocol contracts.\r\n    IERC20 public immutable currency; // Currency used for all prediction markets.\r\n    OptimisticOracleV3Interface public immutable oo;\r\n    uint64 public constant assertionLiveness = 7200; // 2 hours.\r\n    bytes32 public immutable defaultIdentifier; // Identifier used for all prediction markets.\r\n    bytes public constant unresolvable = \"Unresolvable\"; // Name of the unresolvable outcome where payouts are split.\r\n\r\n    event MarketInitialized(\r\n        bytes32 indexed marketId,\r\n        string outcome1,\r\n        string outcome2,\r\n        string description,\r\n        address outcome1Token,\r\n        address outcome2Token,\r\n        uint256 reward,\r\n        uint256 requiredBond\r\n    );\r\n    event MarketAsserted(bytes32 indexed marketId, string assertedOutcome, bytes32 indexed assertionId);\r\n    event MarketResolved(bytes32 indexed marketId);\r\n    event TokensCreated(bytes32 indexed marketId, address indexed account, uint256 tokensCreated);\r\n    event TokensRedeemed(bytes32 indexed marketId, address indexed account, uint256 tokensRedeemed);\r\n    event TokensSettled(\r\n        bytes32 indexed marketId,\r\n        address indexed account,\r\n        uint256 payout,\r\n        uint256 outcome1Tokens,\r\n        uint256 outcome2Tokens\r\n    );\r\n\r\n    constructor(\r\n        address _finder,\r\n        address _currency,\r\n        address _optimisticOracleV3\r\n    ) {\r\n        finder = FinderInterface(_finder);\r\n        require(_getCollateralWhitelist().isOnWhitelist(_currency), \"Unsupported currency\");\r\n        currency = IERC20(_currency);\r\n        oo = OptimisticOracleV3Interface(_optimisticOracleV3);\r\n        defaultIdentifier = oo.defaultIdentifier();\r\n    }\r\n\r\n    function getMarket(bytes32 marketId) public view returns (Market memory) {\r\n        return markets[marketId];\r\n    }\r\n\r\n    function initializeMarket(\r\n        string memory outcome1, // Short name of the first outcome.\r\n        string memory outcome2, // Short name of the second outcome.\r\n        string memory description, // Description of the market.\r\n        uint256 reward, // Reward available for asserting true market outcome.\r\n        uint256 requiredBond // Expected bond to assert market outcome (OOv3 can require higher bond).\r\n    ) public returns (bytes32 marketId) {\r\n        require(bytes(outcome1).length > 0, \"Empty first outcome\");\r\n        require(bytes(outcome2).length > 0, \"Empty second outcome\");\r\n        require(keccak256(bytes(outcome1)) != keccak256(bytes(outcome2)), \"Outcomes are the same\");\r\n        require(bytes(description).length > 0, \"Empty description\");\r\n        marketId = keccak256(abi.encode(block.number, description));\r\n        require(markets[marketId].outcome1Token == ExpandedIERC20(address(0)), \"Market already exists\");\r\n\r\n        // Create position tokens with this contract having minter and burner roles.\r\n        ExpandedIERC20 outcome1Token = new ExpandedERC20(string(abi.encodePacked(outcome1, \" Token\")), \"O1T\", 18);\r\n        ExpandedIERC20 outcome2Token = new ExpandedERC20(string(abi.encodePacked(outcome2, \" Token\")), \"O2T\", 18);\r\n        outcome1Token.addMinter(address(this));\r\n        outcome2Token.addMinter(address(this));\r\n        outcome1Token.addBurner(address(this));\r\n        outcome2Token.addBurner(address(this));\r\n\r\n        markets[marketId] = Market({\r\n            resolved: false,\r\n            assertedOutcomeId: bytes32(0),\r\n            outcome1Token: outcome1Token,\r\n            outcome2Token: outcome2Token,\r\n            reward: reward,\r\n            requiredBond: requiredBond,\r\n            outcome1: bytes(outcome1),\r\n            outcome2: bytes(outcome2),\r\n            description: bytes(description)\r\n        });\r\n        if (reward > 0) currency.safeTransferFrom(msg.sender, address(this), reward); // Pull reward.\r\n\r\n        emit MarketInitialized(\r\n            marketId,\r\n            outcome1,\r\n            outcome2,\r\n            description,\r\n            address(outcome1Token),\r\n            address(outcome2Token),\r\n            reward,\r\n            requiredBond\r\n        );\r\n    }\r\n\r\n    // Assert the market with any of 3 possible outcomes: names of outcome1, outcome2 or unresolvable.\r\n    // Only one concurrent assertion per market is allowed.\r\n    function assertMarket(bytes32 marketId, string memory assertedOutcome) public returns (bytes32 assertionId) {\r\n        Market storage market = markets[marketId];\r\n        require(market.outcome1Token != ExpandedIERC20(address(0)), \"Market does not exist\");\r\n        bytes32 assertedOutcomeId = keccak256(bytes(assertedOutcome));\r\n        require(market.assertedOutcomeId == bytes32(0), \"Assertion active or resolved\");\r\n        require(\r\n            assertedOutcomeId == keccak256(market.outcome1) ||\r\n                assertedOutcomeId == keccak256(market.outcome2) ||\r\n                assertedOutcomeId == keccak256(unresolvable),\r\n            \"Invalid asserted outcome\"\r\n        );\r\n\r\n        market.assertedOutcomeId = assertedOutcomeId;\r\n        uint256 minimumBond = oo.getMinimumBond(address(currency)); // OOv3 might require higher bond.\r\n        uint256 bond = market.requiredBond > minimumBond ? market.requiredBond : minimumBond;\r\n        bytes memory claim = _composeClaim(assertedOutcome, market.description);\r\n\r\n        // Pull bond and make the assertion.\r\n        currency.safeTransferFrom(msg.sender, address(this), bond);\r\n        currency.safeApprove(address(oo), bond);\r\n        assertionId = _assertTruthWithDefaults(claim, bond);\r\n\r\n        // Store the asserter and marketId for the assertionResolvedCallback.\r\n        assertedMarkets[assertionId] = AssertedMarket({ asserter: msg.sender, marketId: marketId });\r\n\r\n        emit MarketAsserted(marketId, assertedOutcome, assertionId);\r\n    }\r\n\r\n    // Callback from settled assertion.\r\n    // If the assertion was resolved true, then the asserter gets the reward and the market is marked as resolved.\r\n    // Otherwise, assertedOutcomeId is reset and the market can be asserted again.\r\n    function assertionResolvedCallback(bytes32 assertionId, bool assertedTruthfully) public {\r\n        require(msg.sender == address(oo), \"Not authorized\");\r\n        Market storage market = markets[assertedMarkets[assertionId].marketId];\r\n\r\n        if (assertedTruthfully) {\r\n            market.resolved = true;\r\n            if (market.reward > 0) currency.safeTransfer(assertedMarkets[assertionId].asserter, market.reward);\r\n            emit MarketResolved(assertedMarkets[assertionId].marketId);\r\n        } else market.assertedOutcomeId = bytes32(0);\r\n        delete assertedMarkets[assertionId];\r\n    }\r\n\r\n    // Dispute callback does nothing.\r\n    function assertionDisputedCallback(bytes32 assertionId) public {}\r\n\r\n    // Mints pair of tokens representing the value of outcome1 and outcome2. Trading of outcome tokens is outside of the\r\n    // scope of this contract. The caller must approve this contract to spend the currency tokens.\r\n    function createOutcomeTokens(bytes32 marketId, uint256 tokensToCreate) public {\r\n        Market storage market = markets[marketId];\r\n        require(market.outcome1Token != ExpandedIERC20(address(0)), \"Market does not exist\");\r\n\r\n        currency.safeTransferFrom(msg.sender, address(this), tokensToCreate);\r\n\r\n        market.outcome1Token.mint(msg.sender, tokensToCreate);\r\n        market.outcome2Token.mint(msg.sender, tokensToCreate);\r\n\r\n        emit TokensCreated(marketId, msg.sender, tokensToCreate);\r\n    }\r\n\r\n    // Burns equal amount of outcome1 and outcome2 tokens returning settlement currency tokens.\r\n    function redeemOutcomeTokens(bytes32 marketId, uint256 tokensToRedeem) public {\r\n        Market storage market = markets[marketId];\r\n        require(market.outcome1Token != ExpandedIERC20(address(0)), \"Market does not exist\");\r\n\r\n        market.outcome1Token.burnFrom(msg.sender, tokensToRedeem);\r\n        market.outcome2Token.burnFrom(msg.sender, tokensToRedeem);\r\n\r\n        currency.safeTransfer(msg.sender, tokensToRedeem);\r\n\r\n        emit TokensRedeemed(marketId, msg.sender, tokensToRedeem);\r\n    }\r\n\r\n    // If the market is resolved, then all of caller's outcome tokens are burned and currency payout is made depending\r\n    // on the resolved market outcome and the amount of outcome tokens burned. If the market was resolved to the first\r\n    // outcome, then the payout equals balance of outcome1Token while outcome2Token provides nothing. If the market was\r\n    // resolved to the second outcome, then the payout equals balance of outcome2Token while outcome1Token provides\r\n    // nothing. If the market was resolved to the split outcome, then both outcome tokens provides half of their balance\r\n    // as currency payout.\r\n    function settleOutcomeTokens(bytes32 marketId) public returns (uint256 payout) {\r\n        Market storage market = markets[marketId];\r\n        require(market.resolved, \"Market not resolved\");\r\n\r\n        uint256 outcome1Balance = market.outcome1Token.balanceOf(msg.sender);\r\n        uint256 outcome2Balance = market.outcome2Token.balanceOf(msg.sender);\r\n\r\n        if (market.assertedOutcomeId == keccak256(market.outcome1)) payout = outcome1Balance;\r\n        else if (market.assertedOutcomeId == keccak256(market.outcome2)) payout = outcome2Balance;\r\n        else payout = (outcome1Balance + outcome2Balance) / 2;\r\n\r\n        market.outcome1Token.burnFrom(msg.sender, outcome1Balance);\r\n        market.outcome2Token.burnFrom(msg.sender, outcome2Balance);\r\n        currency.safeTransfer(msg.sender, payout);\r\n\r\n        emit TokensSettled(marketId, msg.sender, payout, outcome1Balance, outcome2Balance);\r\n    }\r\n\r\n    function _getCollateralWhitelist() internal view returns (AddressWhitelist) {\r\n        return AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n    }\r\n\r\n    function _composeClaim(string memory outcome, bytes memory description) internal view returns (bytes memory) {\r\n        return\r\n            abi.encodePacked(\r\n                \"As of assertion timestamp \",\r\n                ClaimData.toUtf8BytesUint(block.timestamp),\r\n                \", the described prediction market outcome is: \",\r\n                outcome,\r\n                \". The market description is: \",\r\n                description\r\n            );\r\n    }\r\n\r\n    function _assertTruthWithDefaults(bytes memory claim, uint256 bond) internal returns (bytes32 assertionId) {\r\n        assertionId = oo.assertTruth(\r\n            claim,\r\n            msg.sender, // Asserter\r\n            address(this), // Receive callback in this contract.\r\n            address(0), // No sovereign security.\r\n            assertionLiveness,\r\n            currency,\r\n            bond,\r\n            defaultIdentifier,\r\n            bytes32(0) // No domain.\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/OptimisticOracleV3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../interfaces/OptimisticOracleV3CallbackRecipientInterface.sol\";\r\nimport \"../interfaces/OptimisticOracleV3Interface.sol\";\r\nimport \"../interfaces/EscalationManagerInterface.sol\";\r\n\r\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\r\n\r\nimport \"../../common/implementation/AddressWhitelist.sol\";\r\nimport \"../../common/implementation/AncillaryData.sol\";\r\nimport \"../../common/implementation/Lockable.sol\";\r\nimport \"../../common/implementation/MultiCaller.sol\";\r\n\r\n/**\r\n * @title Optimistic Oracle V3.\r\n * @notice The OOv3 is used to assert truths about the world which are verified using an optimistic escalation game.\r\n * @dev Core idea: an asserter makes a statement about a truth, calling \"assertTruth\". If this statement is not\r\n * challenged, it is taken as the state of the world. If challenged, it is arbitrated using the UMA DVM, or if\r\n * configured, an escalation manager. Escalation managers enable integrations to define their own security properties and\r\n * tradeoffs, enabling the notion of \"sovereign security\".\r\n */\r\n\r\ncontract OptimisticOracleV3 is OptimisticOracleV3Interface, Lockable, Ownable, MultiCaller {\r\n    using SafeERC20 for IERC20;\r\n\r\n    FinderInterface public immutable finder; // Finder used to discover other UMA ecosystem contracts.\r\n\r\n    // Cached UMA parameters.\r\n    address public cachedOracle;\r\n    mapping(address => WhitelistedCurrency) public cachedCurrencies;\r\n    mapping(bytes32 => bool) public cachedIdentifiers;\r\n\r\n    mapping(bytes32 => Assertion) public assertions; // All assertions made by the Optimistic Oracle V3.\r\n\r\n    uint256 public burnedBondPercentage; // Percentage of the bond that is paid to the UMA store if the assertion is disputed.\r\n\r\n    bytes32 public constant defaultIdentifier = \"ASSERT_TRUTH\";\r\n    int256 public constant numericalTrue = 1e18; // Numerical representation of true.\r\n    IERC20 public defaultCurrency;\r\n    uint64 public defaultLiveness;\r\n\r\n    /**\r\n     * @notice Construct the OptimisticOracleV3 contract.\r\n     * @param _finder keeps track of all contracts within the UMA system based on their interfaceName.\r\n     * @param _defaultCurrency the default currency to bond asserters in assertTruthWithDefaults.\r\n     * @param _defaultLiveness the default liveness for assertions in assertTruthWithDefaults.\r\n     */\r\n    constructor(\r\n        FinderInterface _finder,\r\n        IERC20 _defaultCurrency,\r\n        uint64 _defaultLiveness\r\n    ) {\r\n        finder = _finder;\r\n        setAdminProperties(_defaultCurrency, _defaultLiveness, 0.5e18);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the default currency, liveness, and burned bond percentage.\r\n     * @dev Only callable by the contract owner (UMA governor).\r\n     * @param _defaultCurrency the default currency to bond asserters in assertTruthWithDefaults.\r\n     * @param _defaultLiveness the default liveness for assertions in assertTruthWithDefaults.\r\n     * @param _burnedBondPercentage the percentage of the bond that is sent as fee to UMA Store contract on disputes.\r\n     */\r\n    function setAdminProperties(\r\n        IERC20 _defaultCurrency,\r\n        uint64 _defaultLiveness,\r\n        uint256 _burnedBondPercentage\r\n    ) public onlyOwner {\r\n        require(_burnedBondPercentage <= 1e18, \"Burned bond percentage > 100\");\r\n        require(_burnedBondPercentage > 0, \"Burned bond percentage is 0\");\r\n        burnedBondPercentage = _burnedBondPercentage;\r\n        defaultCurrency = _defaultCurrency;\r\n        defaultLiveness = _defaultLiveness;\r\n        syncUmaParams(defaultIdentifier, address(_defaultCurrency));\r\n\r\n        emit AdminPropertiesSet(_defaultCurrency, _defaultLiveness, _burnedBondPercentage);\r\n    }\r\n\r\n    /**\r\n     * @notice Asserts a truth about the world, using the default currency and liveness. No callback recipient or\r\n     * escalation manager is enabled. The caller is expected to provide a bond of finalFee/burnedBondPercentage\r\n     * (with burnedBondPercentage set to 50%, the bond is 2x final fee) of the default currency.\r\n     * @dev The caller must approve this contract to spend at least the result of getMinimumBond(defaultCurrency).\r\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\r\n     * @param asserter account that receives bonds back at settlement. This could be msg.sender or\r\n     * any other account that the caller wants to receive the bond at settlement time.\r\n     * @return assertionId unique identifier for this assertion.\r\n     */\r\n\r\n    function assertTruthWithDefaults(bytes calldata claim, address asserter) external returns (bytes32) {\r\n        // Note: re-entrancy guard is done in the inner call.\r\n        return\r\n            assertTruth(\r\n                claim,\r\n                asserter, // asserter\r\n                address(0), // callbackRecipient\r\n                address(0), // escalationManager\r\n                defaultLiveness,\r\n                defaultCurrency,\r\n                getMinimumBond(address(defaultCurrency)),\r\n                defaultIdentifier,\r\n                bytes32(0)\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Asserts a truth about the world, using a fully custom configuration.\r\n     * @dev The caller must approve this contract to spend at least bond amount of currency.\r\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\r\n     * @param asserter account that receives bonds back at settlement. This could be msg.sender or\r\n     * any other account that the caller wants to receive the bond at settlement time.\r\n     * @param callbackRecipient if configured, this address will receive a function call assertionResolvedCallback and\r\n     * assertionDisputedCallback at resolution or dispute respectively. Enables dynamic responses to these events. The\r\n     * recipient _must_ implement these callbacks and not revert or the assertion resolution will be blocked.\r\n     * @param escalationManager if configured, this address will control escalation properties of the assertion. This\r\n     * means a) choosing to arbitrate via the UMA DVM, b) choosing to discard assertions on dispute, or choosing to\r\n     * validate disputes. Combining these, the asserter can define their own security properties for the assertion.\r\n     * escalationManager also _must_ implement the same callbacks as callbackRecipient.\r\n     * @param liveness time to wait before the assertion can be resolved. Assertion can be disputed in this time.\r\n     * @param currency bond currency pulled from the caller and held in escrow until the assertion is resolved.\r\n     * @param bond amount of currency to pull from the caller and hold in escrow until the assertion is resolved. This\r\n     * must be >= getMinimumBond(address(currency)).\r\n     * @param identifier UMA DVM identifier to use for price requests in the event of a dispute. Must be pre-approved.\r\n     * @param domainId optional domain that can be used to relate this assertion to others in the escalationManager and\r\n     * can be used by the configured escalationManager to define custom behavior for groups of assertions. This is\r\n     * typically used for \"escalation games\" by changing bonds or other assertion properties based on the other\r\n     * assertions that have come before. If not needed this value should be 0 to save gas.\r\n     * @return assertionId unique identifier for this assertion.\r\n     */\r\n    function assertTruth(\r\n        bytes memory claim,\r\n        address asserter,\r\n        address callbackRecipient,\r\n        address escalationManager,\r\n        uint64 liveness,\r\n        IERC20 currency,\r\n        uint256 bond,\r\n        bytes32 identifier,\r\n        bytes32 domainId\r\n    ) public nonReentrant returns (bytes32 assertionId) {\r\n        uint64 time = uint64(getCurrentTime());\r\n        assertionId = _getId(claim, bond, time, liveness, currency, callbackRecipient, escalationManager, identifier);\r\n\r\n        require(asserter != address(0), \"Asserter cant be 0\");\r\n        require(assertions[assertionId].asserter == address(0), \"Assertion already exists\");\r\n        require(_validateAndCacheIdentifier(identifier), \"Unsupported identifier\");\r\n        require(_validateAndCacheCurrency(address(currency)), \"Unsupported currency\");\r\n        require(bond >= getMinimumBond(address(currency)), \"Bond amount too low\");\r\n\r\n        assertions[assertionId] = Assertion({\r\n            escalationManagerSettings: EscalationManagerSettings({\r\n                arbitrateViaEscalationManager: false, // Default behavior: use the DVM as an oracle.\r\n                discardOracle: false, // Default behavior: respect the Oracle result.\r\n                validateDisputers: false, // Default behavior: disputer will not be validated.\r\n                escalationManager: escalationManager,\r\n                assertingCaller: msg.sender\r\n            }),\r\n            asserter: asserter,\r\n            disputer: address(0),\r\n            callbackRecipient: callbackRecipient,\r\n            currency: currency,\r\n            domainId: domainId,\r\n            identifier: identifier,\r\n            bond: bond,\r\n            settled: false,\r\n            settlementResolution: false,\r\n            assertionTime: time,\r\n            expirationTime: time + liveness\r\n        });\r\n\r\n        {\r\n            EscalationManagerInterface.AssertionPolicy memory assertionPolicy = _getAssertionPolicy(assertionId);\r\n            require(!assertionPolicy.blockAssertion, \"Assertion not allowed\"); // Check if the assertion is permitted.\r\n            EscalationManagerSettings storage emSettings = assertions[assertionId].escalationManagerSettings;\r\n            (emSettings.arbitrateViaEscalationManager, emSettings.discardOracle, emSettings.validateDisputers) = (\r\n                // Choose which oracle to arbitrate disputes via. If set to true then the escalation manager will\r\n                // arbitrate disputes. Else, the DVM arbitrates disputes. This lets integrations \"unplug\" the DVM.\r\n                assertionPolicy.arbitrateViaEscalationManager,\r\n                // Choose whether to discard the Oracle result. If true then \"throw away\" the assertion. To get an\r\n                // assertion to be true it must be re-asserted and not disputed.\r\n                assertionPolicy.discardOracle,\r\n                // Configures if the escalation manager should validate the disputer on assertions. This enables you\r\n                // to construct setups such as whitelisted disputers.\r\n                assertionPolicy.validateDisputers\r\n            );\r\n        }\r\n\r\n        currency.safeTransferFrom(msg.sender, address(this), bond); // Pull the bond from the caller.\r\n\r\n        emit AssertionMade(\r\n            assertionId,\r\n            domainId,\r\n            claim,\r\n            asserter,\r\n            callbackRecipient,\r\n            escalationManager,\r\n            msg.sender,\r\n            time + liveness,\r\n            currency,\r\n            bond,\r\n            identifier\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes an assertion. Depending on how the assertion was configured, this may either escalate to the UMA\r\n     * DVM or the configured escalation manager for arbitration.\r\n     * @dev The caller must approve this contract to spend at least bond amount of currency for the associated assertion.\r\n     * @param assertionId unique identifier for the assertion to dispute.\r\n     * @param disputer receives bonds back at settlement.\r\n     */\r\n    function disputeAssertion(bytes32 assertionId, address disputer) external nonReentrant {\r\n        require(disputer != address(0), \"Disputer can't be 0\");\r\n        Assertion storage assertion = assertions[assertionId];\r\n        require(assertion.asserter != address(0), \"Assertion does not exist\");\r\n        require(assertion.disputer == address(0), \"Assertion already disputed\");\r\n        require(assertion.expirationTime > getCurrentTime(), \"Assertion is expired\");\r\n        require(_isDisputeAllowed(assertionId), \"Dispute not allowed\");\r\n\r\n        assertion.disputer = disputer;\r\n\r\n        assertion.currency.safeTransferFrom(msg.sender, address(this), assertion.bond);\r\n\r\n        _oracleRequestPrice(assertionId, assertion.identifier, assertion.assertionTime);\r\n\r\n        _callbackOnAssertionDispute(assertionId);\r\n\r\n        // Send resolve callback if dispute resolution is discarded\r\n        if (assertion.escalationManagerSettings.discardOracle) _callbackOnAssertionResolve(assertionId, false);\r\n\r\n        emit AssertionDisputed(assertionId, msg.sender, disputer);\r\n    }\r\n\r\n    /**\r\n     * @notice Resolves an assertion. If the assertion has not been disputed, the assertion is resolved as true and the\r\n     * asserter receives the bond. If the assertion has been disputed, the assertion is resolved depending on the oracle\r\n     * result. Based on the result, the asserter or disputer receives the bond. If the assertion was disputed then an\r\n     * amount of the bond is sent to the UMA Store as an oracle fee based on the burnedBondPercentage. The remainder of\r\n     * the bond is returned to the asserter or disputer.\r\n     * @param assertionId unique identifier for the assertion to resolve.\r\n     */\r\n    function settleAssertion(bytes32 assertionId) public nonReentrant {\r\n        Assertion storage assertion = assertions[assertionId];\r\n        require(assertion.asserter != address(0), \"Assertion does not exist\"); // Revert if assertion does not exist.\r\n        require(!assertion.settled, \"Assertion already settled\"); // Revert if assertion already settled.\r\n        assertion.settled = true;\r\n        if (assertion.disputer == address(0)) {\r\n            // No dispute, settle with the asserter\r\n            require(assertion.expirationTime <= getCurrentTime(), \"Assertion not expired\"); // Revert if not expired.\r\n            assertion.settlementResolution = true;\r\n            assertion.currency.safeTransfer(assertion.asserter, assertion.bond);\r\n            _callbackOnAssertionResolve(assertionId, true);\r\n\r\n            emit AssertionSettled(assertionId, assertion.asserter, false, true, msg.sender);\r\n        } else {\r\n            // Dispute, settle with the disputer. Reverts if price not resolved.\r\n            int256 resolvedPrice = _oracleGetPrice(assertionId, assertion.identifier, assertion.assertionTime);\r\n\r\n            // If set to discard settlement resolution then false. Else, use oracle value to find resolution.\r\n            if (assertion.escalationManagerSettings.discardOracle) assertion.settlementResolution = false;\r\n            else assertion.settlementResolution = resolvedPrice == numericalTrue;\r\n\r\n            address bondRecipient = resolvedPrice == numericalTrue ? assertion.asserter : assertion.disputer;\r\n\r\n            // Calculate oracle fee and the remaining amount of bonds to send to the correct party (asserter or disputer).\r\n            uint256 oracleFee = (burnedBondPercentage * assertion.bond) / 1e18;\r\n            uint256 bondRecipientAmount = assertion.bond * 2 - oracleFee;\r\n\r\n            // Pay out the oracle fee and remaining bonds to the correct party. Note: the oracle fee is sent to the\r\n            // Store contract, even if the escalation manager is used to arbitrate disputes.\r\n            assertion.currency.safeTransfer(address(_getStore()), oracleFee);\r\n            assertion.currency.safeTransfer(bondRecipient, bondRecipientAmount);\r\n\r\n            if (!assertion.escalationManagerSettings.discardOracle)\r\n                _callbackOnAssertionResolve(assertionId, assertion.settlementResolution);\r\n\r\n            emit AssertionSettled(assertionId, bondRecipient, true, assertion.settlementResolution, msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Settles an assertion and returns the resolution.\r\n     * @param assertionId unique identifier for the assertion to resolve and return the resolution for.\r\n     * @return resolution of the assertion.\r\n     */\r\n    function settleAndGetAssertionResult(bytes32 assertionId) external returns (bool) {\r\n        // Note: re-entrancy guard is done in the inner settleAssertion call.\r\n        if (!assertions[assertionId].settled) settleAssertion(assertionId);\r\n        return getAssertionResult(assertionId);\r\n    }\r\n\r\n    /**\r\n     * @notice Fetches information about a specific identifier & currency from the UMA contracts and stores a local copy\r\n     * of the information within this contract. This is used to save gas when making assertions as we can avoid an\r\n     * external call to the UMA contracts to fetch this.\r\n     * @param identifier identifier to fetch information for and store locally.\r\n     * @param currency currency to fetch information for and store locally.\r\n     */\r\n    function syncUmaParams(bytes32 identifier, address currency) public {\r\n        cachedOracle = finder.getImplementationAddress(OracleInterfaces.Oracle);\r\n        cachedIdentifiers[identifier] = _getIdentifierWhitelist().isIdentifierSupported(identifier);\r\n        cachedCurrencies[currency].isWhitelisted = _getCollateralWhitelist().isOnWhitelist(currency);\r\n        cachedCurrencies[currency].finalFee = _getStore().computeFinalFee(currency).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Fetches information about a specific assertion and returns it.\r\n     * @param assertionId unique identifier for the assertion to fetch information for.\r\n     * @return assertion information about the assertion.\r\n     */\r\n    function getAssertion(bytes32 assertionId) external view returns (Assertion memory) {\r\n        return assertions[assertionId];\r\n    }\r\n\r\n    /**\r\n     * @notice Fetches the resolution of a specific assertion and returns it. If the assertion has not been settled then\r\n     * this will revert. If the assertion was disputed and configured to discard the oracle resolution return false.\r\n     * @param assertionId unique identifier for the assertion to fetch the resolution for.\r\n     * @return resolution of the assertion.\r\n     */\r\n    function getAssertionResult(bytes32 assertionId) public view returns (bool) {\r\n        Assertion memory assertion = assertions[assertionId];\r\n        // Return early if not using answer from resolved dispute.\r\n        if (assertion.disputer != address(0) && assertion.escalationManagerSettings.discardOracle) return false;\r\n        require(assertion.settled, \"Assertion not settled\"); // Revert if assertion not settled.\r\n        return assertion.settlementResolution;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current block timestamp.\r\n     * @dev Can be overridden to control contract time.\r\n     * @return current block timestamp.\r\n     */\r\n    function getCurrentTime() public view virtual returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Appends information onto an assertionId to construct ancillary data used for dispute resolution.\r\n     * @param assertionId unique identifier for the assertion to construct ancillary data for.\r\n     * @return ancillaryData stamped assertion information.\r\n     */\r\n    function stampAssertion(bytes32 assertionId) public view returns (bytes memory) {\r\n        return _stampAssertion(assertionId);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the minimum bond amount required to make an assertion. This is calculated as the final fee of the\r\n     * currency divided by the burnedBondPercentage. If burn percentage is 50% then the min bond is 2x the final fee.\r\n     * @param currency currency to calculate the minimum bond for.\r\n     * @return minimum bond amount.\r\n     */\r\n    function getMinimumBond(address currency) public view returns (uint256) {\r\n        uint256 finalFee = cachedCurrencies[currency].finalFee;\r\n        return (finalFee * 1e18) / burnedBondPercentage;\r\n    }\r\n\r\n    // Returns the unique identifier for this assertion. This identifier is used to identify the assertion.\r\n    function _getId(\r\n        bytes memory claim,\r\n        uint256 bond,\r\n        uint256 time,\r\n        uint64 liveness,\r\n        IERC20 currency,\r\n        address callbackRecipient,\r\n        address escalationManager,\r\n        bytes32 identifier\r\n    ) internal view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    claim,\r\n                    bond,\r\n                    time,\r\n                    liveness,\r\n                    currency,\r\n                    callbackRecipient,\r\n                    escalationManager,\r\n                    identifier,\r\n                    msg.sender\r\n                )\r\n            );\r\n    }\r\n\r\n    // Returns ancillary data for the Oracle request containing assertionId and asserter.\r\n    function _stampAssertion(bytes32 assertionId) internal view returns (bytes memory) {\r\n        return\r\n            AncillaryData.appendKeyValueAddress(\r\n                AncillaryData.appendKeyValueBytes32(\"\", \"assertionId\", assertionId),\r\n                \"ooAsserter\",\r\n                assertions[assertionId].asserter\r\n            );\r\n    }\r\n\r\n    // Returns the Address Whitelist contract to validate the currency.\r\n    function _getCollateralWhitelist() internal view returns (AddressWhitelist) {\r\n        return AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n    }\r\n\r\n    // Returns the Identifier Whitelist contract to validate the identifier.\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    // Returns the Store contract to fetch the final fee.\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n\r\n    // Returns the Oracle contract to use on dispute. This can be either UMA DVM or the escalation manager.\r\n    function _getOracle(bytes32 assertionId) internal view returns (OracleAncillaryInterface) {\r\n        if (assertions[assertionId].escalationManagerSettings.arbitrateViaEscalationManager)\r\n            return OracleAncillaryInterface(_getEscalationManager(assertionId));\r\n        return OracleAncillaryInterface(cachedOracle);\r\n    }\r\n\r\n    // Requests resolving dispute from the Oracle (UMA DVM or escalation manager).\r\n    function _oracleRequestPrice(\r\n        bytes32 assertionId,\r\n        bytes32 identifier,\r\n        uint256 time\r\n    ) internal {\r\n        _getOracle(assertionId).requestPrice(identifier, time, _stampAssertion(assertionId));\r\n    }\r\n\r\n    // Returns the resolved resolution from the Oracle (UMA DVM or escalation manager).\r\n    function _oracleGetPrice(\r\n        bytes32 assertionId,\r\n        bytes32 identifier,\r\n        uint256 time\r\n    ) internal view returns (int256) {\r\n        return _getOracle(assertionId).getPrice(identifier, time, _stampAssertion(assertionId));\r\n    }\r\n\r\n    // Returns the escalation manager address for the assertion.\r\n    function _getEscalationManager(bytes32 assertionId) internal view returns (address) {\r\n        return assertions[assertionId].escalationManagerSettings.escalationManager;\r\n    }\r\n\r\n    // Returns the assertion policy parameters from the escalation manager. If no escalation manager is set then return\r\n    // default values.\r\n    function _getAssertionPolicy(bytes32 assertionId)\r\n        internal\r\n        view\r\n        returns (EscalationManagerInterface.AssertionPolicy memory)\r\n    {\r\n        address em = _getEscalationManager(assertionId);\r\n        if (em == address(0)) return EscalationManagerInterface.AssertionPolicy(false, false, false, false);\r\n        return EscalationManagerInterface(em).getAssertionPolicy(assertionId);\r\n    }\r\n\r\n    // Returns whether the dispute is allowed by the escalation manager. If no escalation manager is set or the\r\n    // escalation manager is not configured to validate disputers then return true.\r\n    function _isDisputeAllowed(bytes32 assertionId) internal view returns (bool) {\r\n        if (!assertions[assertionId].escalationManagerSettings.validateDisputers) return true;\r\n        address em = assertions[assertionId].escalationManagerSettings.escalationManager;\r\n        if (em == address(0)) return true;\r\n        return EscalationManagerInterface(em).isDisputeAllowed(assertionId, msg.sender);\r\n    }\r\n\r\n    // Validates if the identifier is whitelisted by first checking the cache. If not whitelisted in the cache then\r\n    // checks it from the identifier whitelist contract and caches result.\r\n    function _validateAndCacheIdentifier(bytes32 identifier) internal returns (bool) {\r\n        if (cachedIdentifiers[identifier]) return true;\r\n        cachedIdentifiers[identifier] = _getIdentifierWhitelist().isIdentifierSupported(identifier);\r\n        return cachedIdentifiers[identifier];\r\n    }\r\n\r\n    // Validates if the currency is whitelisted by first checking the cache. If not whitelisted in the cache then\r\n    // checks it from the collateral whitelist contract and caches whitelist status and final fee.\r\n    function _validateAndCacheCurrency(address currency) internal returns (bool) {\r\n        if (cachedCurrencies[currency].isWhitelisted) return true;\r\n        cachedCurrencies[currency].isWhitelisted = _getCollateralWhitelist().isOnWhitelist(currency);\r\n        cachedCurrencies[currency].finalFee = _getStore().computeFinalFee(currency).rawValue;\r\n        return cachedCurrencies[currency].isWhitelisted;\r\n    }\r\n\r\n    // Sends assertion resolved callback to the callback recipient and escalation manager (if set).\r\n    function _callbackOnAssertionResolve(bytes32 assertionId, bool assertedTruthfully) internal {\r\n        address cr = assertions[assertionId].callbackRecipient;\r\n        address em = _getEscalationManager(assertionId);\r\n        if (cr != address(0))\r\n            OptimisticOracleV3CallbackRecipientInterface(cr).assertionResolvedCallback(assertionId, assertedTruthfully);\r\n        if (em != address(0)) EscalationManagerInterface(em).assertionResolvedCallback(assertionId, assertedTruthfully);\r\n    }\r\n\r\n    // Sends assertion disputed callback to the callback recipient and escalation manager (if set).\r\n    function _callbackOnAssertionDispute(bytes32 assertionId) internal {\r\n        address cr = assertions[assertionId].callbackRecipient;\r\n        address em = _getEscalationManager(assertionId);\r\n        if (cr != address(0)) OptimisticOracleV3CallbackRecipientInterface(cr).assertionDisputedCallback(assertionId);\r\n        if (em != address(0)) EscalationManagerInterface(em).assertionDisputedCallback(assertionId);\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/test/AssertingCallerTest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../OptimisticOracleV3.sol\";\r\n\r\n// Test contract used to wrap assertions for integration testing.\r\ncontract AssertingCallerTest {\r\n    using SafeERC20 for IERC20;\r\n\r\n    OptimisticOracleV3 immutable optimisticOracleV3;\r\n\r\n    constructor(OptimisticOracleV3 _optimisticOracleV3) {\r\n        optimisticOracleV3 = _optimisticOracleV3;\r\n    }\r\n\r\n    // Wraps the OptimisticOracleV3 assertTruth function by passing msg.sender as the asserter and transferring the bond.\r\n    function assertTruth(\r\n        bytes memory claim,\r\n        address callbackRecipient,\r\n        address escalationManager,\r\n        uint64 liveness,\r\n        IERC20 currency,\r\n        uint256 bond,\r\n        bytes32 identifier,\r\n        bytes32 domainId\r\n    ) public returns (bytes32 assertionId) {\r\n        currency.safeTransferFrom(msg.sender, address(this), bond);\r\n        currency.safeApprove(address(optimisticOracleV3), bond);\r\n\r\n        assertionId = optimisticOracleV3.assertTruth(\r\n            claim,\r\n            msg.sender,\r\n            callbackRecipient,\r\n            escalationManager,\r\n            liveness,\r\n            currency,\r\n            bond,\r\n            identifier,\r\n            domainId\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/implementation/test/OptimisticOracleV3Test.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../OptimisticOracleV3.sol\";\r\nimport \"../../../common/implementation/Testable.sol\";\r\n\r\n// Test contract used to manage the time for the contract in tests.\r\ncontract OptimisticOracleV3Test is OptimisticOracleV3, Testable {\r\n    constructor(\r\n        FinderInterface _finder,\r\n        IERC20 _defaultCurrency,\r\n        uint64 _defaultLiveness,\r\n        address _timerAddress\r\n    ) OptimisticOracleV3(_finder, _defaultCurrency, _defaultLiveness) Testable(_timerAddress) {}\r\n\r\n    function getCurrentTime() public view override(OptimisticOracleV3, Testable) returns (uint256) {\r\n        return uint256(Testable.getCurrentTime());\r\n    }\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/interfaces/EscalationManagerInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.16;\r\n\r\nimport \"./OptimisticOracleV3CallbackRecipientInterface.sol\";\r\n\r\n/**\r\n * @title Escalation Manager Interface\r\n * @notice Interface for contracts that manage the escalation policy for assertions.\r\n */\r\ninterface EscalationManagerInterface is OptimisticOracleV3CallbackRecipientInterface {\r\n    // Assertion policy parameters as returned by the escalation manager.\r\n    struct AssertionPolicy {\r\n        bool blockAssertion; // If true, the the assertion should be blocked.\r\n        bool arbitrateViaEscalationManager; // If true, the escalation manager will arbitrate the assertion.\r\n        bool discardOracle; // If true, the Optimistic Oracle V3 should discard the oracle price.\r\n        bool validateDisputers; // If true, the escalation manager will validate the disputers.\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the assertion policy for the given assertion.\r\n     * @param assertionId the assertion identifier to get the assertion policy for.\r\n     * @return the assertion policy for the given assertion identifier.\r\n     */\r\n    function getAssertionPolicy(bytes32 assertionId) external view returns (AssertionPolicy memory);\r\n\r\n    /**\r\n     * @notice Callback function that is called by Optimistic Oracle V3 when an assertion is disputed. Used to validate\r\n     * if the dispute should be allowed based on the escalation policy.\r\n     * @param assertionId the assertionId to validate the dispute for.\r\n     * @param disputeCaller the caller of the dispute function.\r\n     * @return bool true if the dispute is allowed, false otherwise.\r\n     */\r\n    function isDisputeAllowed(bytes32 assertionId, address disputeCaller) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Implements price getting logic. This method is called by Optimistic Oracle V3 settling an assertion that\r\n     * is configured to use the escalation manager as the oracle. The interface is constructed to mimic the UMA DVM.\r\n     * @param identifier price identifier being requested.\r\n     * @param time timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return price from the escalation manager to inform the resolution of the dispute.\r\n     */\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) external returns (int256);\r\n\r\n    /**\r\n     * @notice Implements price requesting logic for the escalation manager. This function is called by the Optimistic\r\n     * Oracle V3 on dispute and is constructed to mimic that of the UMA DVM interface.\r\n     * @param identifier the identifier to fetch the price for.\r\n     * @param time the time to fetch the price for.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) external;\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/interfaces/OptimisticOracleV3CallbackRecipientInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.16;\r\n\r\n/**\r\n * @title Optimistic Oracle V3 Callback Recipient Interface\r\n * @notice Interface for contracts implementing callbacks to be received from the Optimistic Oracle V3.\r\n */\r\ninterface OptimisticOracleV3CallbackRecipientInterface {\r\n    /**\r\n     * @notice Callback function that is called by Optimistic Oracle V3 when an assertion is resolved.\r\n     * @param assertionId The identifier of the assertion that was resolved.\r\n     * @param assertedTruthfully Whether the assertion was resolved as truthful or not.\r\n     */\r\n    function assertionResolvedCallback(bytes32 assertionId, bool assertedTruthfully) external;\r\n\r\n    /**\r\n     * @notice Callback function that is called by Optimistic Oracle V3 when an assertion is disputed.\r\n     * @param assertionId The identifier of the assertion that was disputed.\r\n     */\r\n    function assertionDisputedCallback(bytes32 assertionId) external;\r\n}\r\n"
    },
    "contracts/optimistic-oracle-v3/interfaces/OptimisticOracleV3Interface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.16;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title Optimistic Oracle V3 Interface that callers must use to assert truths about the world.\r\n */\r\ninterface OptimisticOracleV3Interface {\r\n    // Struct grouping together the settings related to the escalation manager stored in the assertion.\r\n    struct EscalationManagerSettings {\r\n        bool arbitrateViaEscalationManager; // False if the DVM is used as an oracle (EscalationManager on True).\r\n        bool discardOracle; // False if Oracle result is used for resolving assertion after dispute.\r\n        bool validateDisputers; // True if the EM isDisputeAllowed should be checked on disputes.\r\n        address assertingCaller; // Stores msg.sender when assertion was made.\r\n        address escalationManager; // Address of the escalation manager (zero address if not configured).\r\n    }\r\n\r\n    // Struct for storing properties and lifecycle of an assertion.\r\n    struct Assertion {\r\n        EscalationManagerSettings escalationManagerSettings; // Settings related to the escalation manager.\r\n        address asserter; // Address of the asserter.\r\n        uint64 assertionTime; // Time of the assertion.\r\n        bool settled; // True if the request is settled.\r\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\r\n        uint64 expirationTime; // Unix timestamp marking threshold when the assertion can no longer be disputed.\r\n        bool settlementResolution; // Resolution of the assertion (false till resolved).\r\n        bytes32 domainId; // Optional domain that can be used to relate the assertion to others in the escalationManager.\r\n        bytes32 identifier; // UMA DVM identifier to use for price requests in the event of a dispute.\r\n        uint256 bond; // Amount of currency that the asserter has bonded.\r\n        address callbackRecipient; // Address that receives the callback.\r\n        address disputer; // Address of the disputer.\r\n    }\r\n\r\n    // Struct for storing cached currency whitelist.\r\n    struct WhitelistedCurrency {\r\n        bool isWhitelisted; // True if the currency is whitelisted.\r\n        uint256 finalFee; // Final fee of the currency.\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes an assertion. Depending on how the assertion was configured, this may either escalate to the UMA\r\n     * DVM or the configured escalation manager for arbitration.\r\n     * @dev The caller must approve this contract to spend at least bond amount of currency for the associated assertion.\r\n     * @param assertionId unique identifier for the assertion to dispute.\r\n     * @param disputer receives bonds back at settlement.\r\n     */\r\n    function disputeAssertion(bytes32 assertionId, address disputer) external;\r\n\r\n    /**\r\n     * @notice Returns the default identifier used by the Optimistic Oracle V3.\r\n     * @return The default identifier.\r\n     */\r\n    function defaultIdentifier() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Fetches information about a specific assertion and returns it.\r\n     * @param assertionId unique identifier for the assertion to fetch information for.\r\n     * @return assertion information about the assertion.\r\n     */\r\n    function getAssertion(bytes32 assertionId) external view returns (Assertion memory);\r\n\r\n    /**\r\n     * @notice Asserts a truth about the world, using the default currency and liveness. No callback recipient or\r\n     * escalation manager is enabled. The caller is expected to provide a bond of finalFee/burnedBondPercentage\r\n     * (with burnedBondPercentage set to 50%, the bond is 2x final fee) of the default currency.\r\n     * @dev The caller must approve this contract to spend at least the result of getMinimumBond(defaultCurrency).\r\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\r\n     * @param asserter receives bonds back at settlement. This could be msg.sender or\r\n     * any other account that the caller wants to receive the bond at settlement time.\r\n     * @return assertionId unique identifier for this assertion.\r\n     */\r\n    function assertTruthWithDefaults(bytes memory claim, address asserter) external returns (bytes32);\r\n\r\n    /**\r\n     * @notice Asserts a truth about the world, using a fully custom configuration.\r\n     * @dev The caller must approve this contract to spend at least bond amount of currency.\r\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\r\n     * @param asserter receives bonds back at settlement. This could be msg.sender or\r\n     * any other account that the caller wants to receive the bond at settlement time.\r\n     * @param callbackRecipient if configured, this address will receive a function call assertionResolvedCallback and\r\n     * assertionDisputedCallback at resolution or dispute respectively. Enables dynamic responses to these events. The\r\n     * recipient _must_ implement these callbacks and not revert or the assertion resolution will be blocked.\r\n     * @param escalationManager if configured, this address will control escalation properties of the assertion. This\r\n     * means a) choosing to arbitrate via the UMA DVM, b) choosing to discard assertions on dispute, or choosing to\r\n     * validate disputes. Combining these, the asserter can define their own security properties for the assertion.\r\n     * escalationManager also _must_ implement the same callbacks as callbackRecipient.\r\n     * @param liveness time to wait before the assertion can be resolved. Assertion can be disputed in this time.\r\n     * @param currency bond currency pulled from the caller and held in escrow until the assertion is resolved.\r\n     * @param bond amount of currency to pull from the caller and hold in escrow until the assertion is resolved. This\r\n     * must be >= getMinimumBond(address(currency)).\r\n     * @param identifier UMA DVM identifier to use for price requests in the event of a dispute. Must be pre-approved.\r\n     * @param domainId optional domain that can be used to relate this assertion to others in the escalationManager and\r\n     * can be used by the configured escalationManager to define custom behavior for groups of assertions. This is\r\n     * typically used for \"escalation games\" by changing bonds or other assertion properties based on the other\r\n     * assertions that have come before. If not needed this value should be 0 to save gas.\r\n     * @return assertionId unique identifier for this assertion.\r\n     */\r\n    function assertTruth(\r\n        bytes memory claim,\r\n        address asserter,\r\n        address callbackRecipient,\r\n        address escalationManager,\r\n        uint64 liveness,\r\n        IERC20 currency,\r\n        uint256 bond,\r\n        bytes32 identifier,\r\n        bytes32 domainId\r\n    ) external returns (bytes32);\r\n\r\n    /**\r\n     * @notice Fetches information about a specific identifier & currency from the UMA contracts and stores a local copy\r\n     * of the information within this contract. This is used to save gas when making assertions as we can avoid an\r\n     * external call to the UMA contracts to fetch this.\r\n     * @param identifier identifier to fetch information for and store locally.\r\n     * @param currency currency to fetch information for and store locally.\r\n     */\r\n    function syncUmaParams(bytes32 identifier, address currency) external;\r\n\r\n    /**\r\n     * @notice Resolves an assertion. If the assertion has not been disputed, the assertion is resolved as true and the\r\n     * asserter receives the bond. If the assertion has been disputed, the assertion is resolved depending on the oracle\r\n     * result. Based on the result, the asserter or disputer receives the bond. If the assertion was disputed then an\r\n     * amount of the bond is sent to the UMA Store as an oracle fee based on the burnedBondPercentage. The remainder of\r\n     * the bond is returned to the asserter or disputer.\r\n     * @param assertionId unique identifier for the assertion to resolve.\r\n     */\r\n    function settleAssertion(bytes32 assertionId) external;\r\n\r\n    /**\r\n     * @notice Settles an assertion and returns the resolution.\r\n     * @param assertionId unique identifier for the assertion to resolve and return the resolution for.\r\n     * @return resolution of the assertion.\r\n     */\r\n    function settleAndGetAssertionResult(bytes32 assertionId) external returns (bool);\r\n\r\n    /**\r\n     * @notice Fetches the resolution of a specific assertion and returns it. If the assertion has not been settled then\r\n     * this will revert. If the assertion was disputed and configured to discard the oracle resolution return false.\r\n     * @param assertionId unique identifier for the assertion to fetch the resolution for.\r\n     * @return resolution of the assertion.\r\n     */\r\n    function getAssertionResult(bytes32 assertionId) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns the minimum bond amount required to make an assertion. This is calculated as the final fee of the\r\n     * currency divided by the burnedBondPercentage. If burn percentage is 50% then the min bond is 2x the final fee.\r\n     * @param currency currency to calculate the minimum bond for.\r\n     * @return minimum bond amount.\r\n     */\r\n    function getMinimumBond(address currency) external view returns (uint256);\r\n\r\n    event AssertionMade(\r\n        bytes32 indexed assertionId,\r\n        bytes32 domainId,\r\n        bytes claim,\r\n        address indexed asserter,\r\n        address callbackRecipient,\r\n        address escalationManager,\r\n        address caller,\r\n        uint64 expirationTime,\r\n        IERC20 currency,\r\n        uint256 bond,\r\n        bytes32 indexed identifier\r\n    );\r\n\r\n    event AssertionDisputed(bytes32 indexed assertionId, address indexed caller, address indexed disputer);\r\n\r\n    event AssertionSettled(\r\n        bytes32 indexed assertionId,\r\n        address indexed bondRecipient,\r\n        bool disputed,\r\n        bool settlementResolution,\r\n        address settleCaller\r\n    );\r\n\r\n    event AdminPropertiesSet(IERC20 defaultCurrency, uint64 defaultLiveness, uint256 burnedBondPercentage);\r\n}\r\n"
    },
    "contracts/polygon-cross-chain-oracle/GovernorChildTunnel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@maticnetwork/fx-portal/contracts/tunnel/FxBaseChildTunnel.sol\";\r\n\r\n/**\r\n * @title Governor contract deployed on sidechain that receives governance actions from Ethereum.\r\n */\r\ncontract GovernorChildTunnel is FxBaseChildTunnel {\r\n    event ExecutedGovernanceTransaction(address indexed to, bytes data);\r\n\r\n    constructor(address _fxChild) FxBaseChildTunnel(_fxChild) {}\r\n\r\n    /**\r\n     * @notice Executes governance transaction created on Ethereum.\r\n     * @dev The data will be received automatically from the state receiver when the state is synced between Ethereum\r\n     * and Polygon. This will revert if the Root chain sender is not the `fxRootTunnel` contract.\r\n     * @param sender The sender of `data` from the Root chain.\r\n     * @param data ABI encoded params to include in delegated transaction.\r\n     */\r\n    function _processMessageFromRoot(\r\n        uint256, /* stateId */\r\n        address sender,\r\n        bytes memory data\r\n    ) internal override validateSender(sender) {\r\n        (address to, bytes memory inputData) = abi.decode(data, (address, bytes));\r\n\r\n        require(_executeCall(to, inputData), \"execute call failed\");\r\n        emit ExecutedGovernanceTransaction(to, inputData);\r\n    }\r\n\r\n    // Note: this snippet of code is copied from Governor.sol.\r\n    function _executeCall(address to, bytes memory data) private returns (bool) {\r\n        // Note: this snippet of code is copied from Governor.sol.\r\n        // solhint-disable-next-line max-line-length\r\n        // https://github.com/gnosis/safe-contracts/blob/59cfdaebcd8b87a0a32f87b50fead092c10d3a05/contracts/base/Executor.sol#L23-L31\r\n        // solhint-disable-next-line no-inline-assembly\r\n\r\n        bool success;\r\n        assembly {\r\n            let inputData := add(data, 0x20)\r\n            let inputDataSize := mload(data)\r\n            // Hardcode value to be 0 for relayed governance calls in order to avoid addressing complexity of bridging\r\n            // value cross-chain.\r\n            success := call(gas(), to, 0, inputData, inputDataSize, 0, 0)\r\n        }\r\n        return success;\r\n    }\r\n}\r\n"
    },
    "contracts/polygon-cross-chain-oracle/GovernorRootTunnel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@maticnetwork/fx-portal/contracts/tunnel/FxBaseRootTunnel.sol\";\r\nimport \"../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Governance relayer contract to be deployed on Ethereum that receives messages from the owner (Governor) and\r\n * sends them to sidechain.\r\n */\r\ncontract GovernorRootTunnel is Ownable, FxBaseRootTunnel, Lockable {\r\n    event RelayedGovernanceRequest(address indexed to, bytes data);\r\n\r\n    constructor(address _checkpointManager, address _fxRoot) FxBaseRootTunnel(_checkpointManager, _fxRoot) {}\r\n\r\n    /**\r\n     * @notice This should be called in order to relay a governance request to the `GovernorChildTunnel` contract\r\n     * deployed to the sidechain. Note: this can only be called by the owner (presumably the Ethereum Governor\r\n     * contract).\r\n     * @dev The transaction submitted to `to` on the sidechain with the calldata `data` is assumed to have 0 `value`\r\n     * in order to avoid the added complexity of sending cross-chain transactions with positive value.\r\n     */\r\n    function relayGovernance(address to, bytes memory data) external nonReentrant() onlyOwner {\r\n        _sendMessageToChild(abi.encode(to, data));\r\n        emit RelayedGovernanceRequest(to, data);\r\n    }\r\n\r\n    /**\r\n     * @notice Function called as callback from child tunnel. Should not do anything as governance actions should only\r\n     * be sent from root to child.\r\n     */\r\n    function _processMessageFromChild(bytes memory data) internal override {\r\n        // no-op\r\n    }\r\n}\r\n"
    },
    "contracts/polygon-cross-chain-oracle/OracleBaseTunnel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../data-verification-mechanism/interfaces/FinderInterface.sol\";\r\nimport \"../data-verification-mechanism/implementation/Constants.sol\";\r\n\r\n/**\r\n * @notice Enforces lifecycle of price requests for deriving contract.\r\n */\r\nabstract contract OracleBaseTunnel {\r\n    enum RequestState { NeverRequested, Requested, Resolved }\r\n\r\n    struct Price {\r\n        RequestState state;\r\n        int256 price;\r\n    }\r\n\r\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\r\n    // that a price can be requested to this contract successfully, but cannot be resolved by the DVM which refuses\r\n    // to accept a price request made with ancillary data length over a certain size.\r\n    uint256 public constant ancillaryBytesLimit = 8192;\r\n\r\n    // Mapping of encoded price requests {identifier, time, ancillaryData} to Price objects.\r\n    mapping(bytes32 => Price) internal prices;\r\n\r\n    // Finder to provide addresses for DVM system contracts.\r\n    FinderInterface public finder;\r\n\r\n    event PriceRequestAdded(bytes32 indexed identifier, uint256 time, bytes ancillaryData, bytes32 indexed requestHash);\r\n    event PushedPrice(\r\n        bytes32 indexed identifier,\r\n        uint256 time,\r\n        bytes ancillaryData,\r\n        int256 price,\r\n        bytes32 indexed requestHash\r\n    );\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\r\n     */\r\n    constructor(address _finderAddress) {\r\n        finder = FinderInterface(_finderAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the given (identifier, time,\r\n     * ancillary data) combination. Will only emit an event if the request has never been requested.\r\n     */\r\n    function _requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) internal {\r\n        require(ancillaryData.length <= ancillaryBytesLimit, \"Invalid ancillary data\");\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\r\n        Price storage lookup = prices[priceRequestId];\r\n        if (lookup.state == RequestState.NeverRequested) {\r\n            lookup.state = RequestState.Requested;\r\n            emit PriceRequestAdded(identifier, time, ancillaryData, priceRequestId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Publishes price for a requested query. Will only emit an event if the request has never been resolved.\r\n     */\r\n    function _publishPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) internal {\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\r\n        Price storage lookup = prices[priceRequestId];\r\n        if (lookup.state == RequestState.Requested) {\r\n            lookup.price = price;\r\n            lookup.state = RequestState.Resolved;\r\n            emit PushedPrice(identifier, time, ancillaryData, lookup.price, priceRequestId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the convenient way to store price requests, uniquely identified by {identifier, time,\r\n     * ancillaryData }.\r\n     */\r\n    function _encodePriceRequest(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(identifier, time, ancillaryData));\r\n    }\r\n}\r\n"
    },
    "contracts/polygon-cross-chain-oracle/OracleChildTunnel.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@maticnetwork/fx-portal/contracts/tunnel/FxBaseChildTunnel.sol\";\r\nimport \"../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../data-verification-mechanism/interfaces/RegistryInterface.sol\";\r\nimport \"./OracleBaseTunnel.sol\";\r\nimport \"../common/implementation/AncillaryData.sol\";\r\nimport \"../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Adapter deployed on sidechain to give financial contracts the ability to trigger cross-chain price requests to\r\n * the mainnet DVM. Also has the ability to receive published prices from mainnet. This contract can be treated as the\r\n * \"DVM\" for this network, because a calling contract can request and access a resolved price request from this\r\n * contract.\r\n * @dev The intended client of this contract is an OptimisticOracle on sidechain that needs price\r\n * resolution secured by the DVM on mainnet.\r\n */\r\ncontract OracleChildTunnel is OracleBaseTunnel, OracleAncillaryInterface, FxBaseChildTunnel, Lockable {\r\n    constructor(address _fxChild, address _finderAddress)\r\n        OracleBaseTunnel(_finderAddress)\r\n        FxBaseChildTunnel(_fxChild)\r\n    {}\r\n\r\n    // This assumes that the local network has a Registry that resembles the mainnet registry.\r\n    modifier onlyRegisteredContract() {\r\n        RegistryInterface registry = RegistryInterface(finder.getImplementationAddress(OracleInterfaces.Registry));\r\n        require(registry.isContractRegistered(msg.sender), \"Caller must be registered\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice This should be called to bridge a price request to mainnet.\r\n     * @dev Can be called only by a registered contract that is allowed to make DVM price requests. Will mark this\r\n     * price request as Requested, and therefore able to receive the price resolution data from mainnet. Emits a message\r\n     * that will be included in regular checkpoint of all sidechain transactions to mainnet.\r\n     * @param identifier Identifier of price request.\r\n     * @param time Timestamp of price request.\r\n     * @param ancillaryData extra data of price request.\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public override nonReentrant() onlyRegisteredContract() {\r\n        // This implementation allows duplicate price requests to emit duplicate MessageSent events via\r\n        // _sendMessageToRoot. The DVM will not have a problem handling duplicate requests (it will just ignore them).\r\n        // This is potentially a fallback in case the checkpointing to mainnet is missing the `requestPrice` transaction\r\n        // for some reason. There is little risk in duplicating MessageSent emissions because the sidechain bridge\r\n        // does not impose any rate-limiting and this method is only callable by registered callers.\r\n        _requestPrice(identifier, time, _stampAncillaryData(ancillaryData, msg.sender));\r\n        _sendMessageToRoot(abi.encode(identifier, time, _stampAncillaryData(ancillaryData, msg.sender)));\r\n    }\r\n\r\n    /**\r\n     * @notice Resolves a price request.\r\n     * @dev The data will be received automatically from the state receiver when the state is synced between Ethereum\r\n     * and Polygon. This will revert if the Root chain sender is not the `fxRootTunnel` contract.\r\n     * @param sender The sender of `data` from the Root chain.\r\n     * @param data ABI encoded params with which to call `_publishPrice`.\r\n     */\r\n    function _processMessageFromRoot(\r\n        uint256, /* stateId */\r\n        address sender,\r\n        bytes memory data\r\n    ) internal override validateSender(sender) {\r\n        (bytes32 identifier, uint256 time, bytes memory ancillaryData, int256 price) =\r\n            abi.decode(data, (bytes32, uint256, bytes, int256));\r\n        _publishPrice(identifier, time, ancillaryData, price);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether a price has resolved for the request.\r\n     * @param identifier Identifier of price request.\r\n     * @param time Timestamp of price request\r\n     * @param ancillaryData extra data of price request.\r\n     * @return True if a price is available, False otherwise. If true, then getPrice will succeed for the request.\r\n     */\r\n    function hasPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() onlyRegisteredContract() returns (bool) {\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, _stampAncillaryData(ancillaryData, msg.sender));\r\n        return prices[priceRequestId].state == RequestState.Resolved;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns resolved price for the request.\r\n     * @dev Reverts if price is not available.\r\n     * @param identifier Identifier of price request.\r\n     * @param time Timestamp of price request\r\n     * @param ancillaryData extra data of price request.\r\n     * @return int256 Price, or reverts if no resolved price for any reason.\r\n     */\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() onlyRegisteredContract() returns (int256) {\r\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, _stampAncillaryData(ancillaryData, msg.sender));\r\n        Price storage lookup = prices[priceRequestId];\r\n        require(lookup.state == RequestState.Resolved, \"Price has not been resolved\");\r\n        return lookup.price;\r\n    }\r\n\r\n    /**\r\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param requester sender of the initial price request.\r\n     * @return the stamped ancillary bytes.\r\n     */\r\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\r\n        public\r\n        view\r\n        nonReentrantView()\r\n        returns (bytes memory)\r\n    {\r\n        return _stampAncillaryData(ancillaryData, requester);\r\n    }\r\n\r\n    /**\r\n     * @dev We don't handle specifically the case where `ancillaryData` is not already readily translatable in utf8.\r\n     * For those cases, we assume that the client will be able to strip out the utf8-translatable part of the\r\n     * ancillary data that this contract stamps.\r\n     */\r\n    function _stampAncillaryData(bytes memory ancillaryData, address requester) internal view returns (bytes memory) {\r\n        // Price requests that originate from this method, on Polygon, will ultimately be submitted to the DVM on\r\n        // Ethereum via the OracleRootTunnel. Therefore this contract should stamp its requester's address in the\r\n        // ancillary data so voters can conveniently track the requests path to the DVM.\r\n        return\r\n            AncillaryData.appendKeyValueUint(\r\n                AncillaryData.appendKeyValueAddress(ancillaryData, \"childRequester\", requester),\r\n                \"childChainId\",\r\n                block.chainid\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/polygon-cross-chain-oracle/OracleRootTunnel.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@maticnetwork/fx-portal/contracts/tunnel/FxBaseRootTunnel.sol\";\r\n\r\nimport \"./OracleBaseTunnel.sol\";\r\nimport \"../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\r\nimport \"../common/implementation/Lockable.sol\";\r\n\r\n/**\r\n * @title Adapter deployed on mainnet that validates and sends price requests from sidechain to the DVM on mainnet.\r\n * @dev This contract must be a registered financial contract in order to make DVM price requests.\r\n */\r\ncontract OracleRootTunnel is OracleBaseTunnel, FxBaseRootTunnel, Lockable {\r\n    constructor(\r\n        address _checkpointManager,\r\n        address _fxRoot,\r\n        address _finderAddress\r\n    ) OracleBaseTunnel(_finderAddress) FxBaseRootTunnel(_checkpointManager, _fxRoot) {}\r\n\r\n    /**\r\n     * @notice This is the first method that should be called in order to publish a price request to the sidechain.\r\n     * @dev Publishes the DVM resolved price for the price request, or reverts if not resolved yet. This contract must\r\n     * be registered with the DVM to query price requests.\r\n     * @param identifier Identifier of price request to resolve.\r\n     * @param time Timestamp of price request to resolve.\r\n     * @param ancillaryData extra data of price request to resolve.\r\n     */\r\n    function publishPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public nonReentrant() {\r\n        // `getPrice` will revert if there is no price.\r\n        int256 price = _getOracle().getPrice(identifier, time, ancillaryData);\r\n        // This implementation allows duplicate MessageSent events via _sendMessageToRoot. The child tunnel on the\r\n        // sidechain will not have a problem handling duplicate price resolutions (it will just ignore them). This is\r\n        // potentially a fallback in case the automatic state sync to the sidechain is missing the `publishPrice`\r\n        // transaction for some reason. There is little risk in duplicating MessageSent emissions because the sidechain\r\n        // bridge does not impose any rate-limiting.\r\n        _publishPrice(identifier, time, ancillaryData, price);\r\n        _sendMessageToChild(abi.encode(identifier, time, ancillaryData, price));\r\n    }\r\n\r\n    /**\r\n     * @notice Submits a price request.\r\n     * @dev This internal method will be called inside `receiveMessage(bytes memory inputData)`. The `inputData` is a\r\n     * proof of transaction that is derived from the transaction hash of the transaction on the child chain that\r\n     * originated the cross-chain price request via _sendMessageToRoot. This contract must be registered with the DVM\r\n     * to submit price requests.\r\n     * @param data ABI encoded params with which to call `requestPrice`.\r\n     */\r\n    function _processMessageFromChild(bytes memory data) internal override {\r\n        (bytes32 identifier, uint256 time, bytes memory ancillaryData) = abi.decode(data, (bytes32, uint256, bytes));\r\n        _requestPrice(identifier, time, ancillaryData);\r\n        _getOracle().requestPrice(identifier, time, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Return DVM for this network.\r\n     */\r\n    function _getOracle() internal view returns (OracleAncillaryInterface) {\r\n        return OracleAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n}\r\n"
    },
    "contracts/polygon-cross-chain-oracle/test/FxChildMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// IStateReceiver represents interface to receive state\r\ninterface IStateReceiver {\r\n    function onStateReceive(uint256 stateId, bytes calldata data) external;\r\n}\r\n\r\n// IFxMessageProcessor represents interface to process message\r\ninterface IFxMessageProcessor {\r\n    function processMessageFromRoot(\r\n        uint256 stateId,\r\n        address rootMessageSender,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title FxChild child contract for state receiver\r\n */\r\ncontract FxChildMock is IStateReceiver {\r\n    address public fxRoot;\r\n    address public systemCaller;\r\n\r\n    event NewFxMessage(address rootMessageSender, address receiver, bytes data);\r\n\r\n    constructor(address _systemCaller) {\r\n        systemCaller = _systemCaller;\r\n    }\r\n\r\n    function setFxRoot(address _fxRoot) public {\r\n        require(fxRoot == address(0x0));\r\n        fxRoot = _fxRoot;\r\n    }\r\n\r\n    function onStateReceive(uint256 stateId, bytes calldata _data) external override {\r\n        require(msg.sender == systemCaller, \"Invalid sender: must be system super user\");\r\n        (address rootMessageSender, address receiver, bytes memory data) = abi.decode(_data, (address, address, bytes));\r\n        emit NewFxMessage(rootMessageSender, receiver, data);\r\n        IFxMessageProcessor(receiver).processMessageFromRoot(stateId, rootMessageSender, data);\r\n    }\r\n}\r\n"
    },
    "contracts/polygon-cross-chain-oracle/test/FxRootMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IStateSender {\r\n    function syncState(address receiver, bytes calldata data) external;\r\n}\r\n\r\ninterface IFxStateSender {\r\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\r\n}\r\n\r\n/**\r\n * @title FxRoot root contract for fx-portal\r\n */\r\ncontract FxRootMock is IFxStateSender {\r\n    IStateSender public stateSender;\r\n    address public fxChild;\r\n\r\n    constructor(address _stateSender) {\r\n        stateSender = IStateSender(_stateSender);\r\n    }\r\n\r\n    function setFxChild(address _fxChild) public {\r\n        require(fxChild == address(0x0));\r\n        fxChild = _fxChild;\r\n    }\r\n\r\n    function sendMessageToChild(address _receiver, bytes calldata _data) public override {\r\n        bytes memory data = abi.encode(msg.sender, _receiver, _data);\r\n        stateSender.syncState(fxChild, data);\r\n    }\r\n}\r\n"
    },
    "contracts/polygon-cross-chain-oracle/test/OracleBaseTunnelMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../OracleBaseTunnel.sol\";\r\n\r\n/**\r\n * @title Test implementation of OracleBaseTunnel enabling unit tests on internal methods.\r\n * @dev Unit tests should ensure that internal methods `_requestPrice` and `_publishPrice` emit the correct events\r\n * and modify state as expected.\r\n */\r\ncontract OracleBaseTunnelMock is OracleBaseTunnel {\r\n    constructor(address _finderAddress) OracleBaseTunnel(_finderAddress) {}\r\n\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public {\r\n        _requestPrice(identifier, time, ancillaryData);\r\n    }\r\n\r\n    function encodePriceRequest(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public pure returns (bytes32) {\r\n        return _encodePriceRequest(identifier, time, ancillaryData);\r\n    }\r\n\r\n    function publishPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) public {\r\n        _publishPrice(identifier, time, ancillaryData, price);\r\n    }\r\n}\r\n"
    },
    "contracts/polygon-cross-chain-oracle/test/OracleRootTunnelMock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../OracleRootTunnel.sol\";\r\n\r\ncontract OracleRootTunnelMock is OracleRootTunnel {\r\n    // If set to true, then always revert on calls to receiveMessage.\r\n    bool public revertReceiveMessage;\r\n\r\n    // Error message to emit when receiveMessage reverts.\r\n    string public errorMessage;\r\n\r\n    event ReceivedMessage(bytes indexed inputData);\r\n\r\n    constructor(\r\n        address _checkpointManager,\r\n        address _fxRoot,\r\n        address _finderAddress\r\n    ) OracleRootTunnel(_checkpointManager, _fxRoot, _finderAddress) {\r\n        revertReceiveMessage = false;\r\n        errorMessage = \"generic error message\";\r\n    }\r\n\r\n    // Helper method to test _processMessageFromChild directly without having to call internal\r\n    // _validateAndExtractMessage\r\n    function processMessageFromChild(bytes memory message) public {\r\n        _processMessageFromChild(message);\r\n    }\r\n\r\n    // Helper method to test receiveMessage. Will always succeed unless `revertReceiveMessage` is True, then will\r\n    // always revert.\r\n    function receiveMessage(bytes memory inputData) public override {\r\n        if (!revertReceiveMessage) {\r\n            emit ReceivedMessage(inputData);\r\n        } else {\r\n            require(false, errorMessage);\r\n        }\r\n    }\r\n\r\n    function setRevertReceiveMessage(bool _revertReceiveMessage) public {\r\n        revertReceiveMessage = _revertReceiveMessage;\r\n    }\r\n\r\n    function setRevertErrorMessage(string calldata _errorMessage) public {\r\n        errorMessage = _errorMessage;\r\n    }\r\n}\r\n"
    },
    "contracts/polygon-cross-chain-oracle/test/StateSyncMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @notice Dummy State Sender contract to simulate plasma state sender while testing\r\n */\r\ncontract StateSyncMock {\r\n    /**\r\n     * @notice Event emitted when when syncState is called\r\n     * @dev Heimdall bridge listens to this event and sends the data to receiver contract on child chain\r\n     * @param id Id of the sync, increamented for each event in case of actual state sender contract\r\n     * @param contractAddress the contract receiving data on child chain\r\n     * @param data bytes data to be sent\r\n     */\r\n    event StateSynced(uint256 indexed id, address indexed contractAddress, bytes data);\r\n\r\n    /**\r\n     * @notice called to send data to child chain\r\n     * @dev sender and receiver contracts need to be registered in case of actual state sender contract\r\n     * @param receiver the contract receiving data on child chain\r\n     * @param data bytes data to be sent\r\n     */\r\n    function syncState(address receiver, bytes calldata data) external {\r\n        emit StateSynced(1, receiver, data);\r\n    }\r\n}\r\n"
    },
    "contracts/proxy-scripts/atomic-disputer/ReserveCurrencyDisputer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\npragma abicoder v2;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\";\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n/**\r\n * @title ReserveCurrencyDisputer\r\n * @notice Helper contract to enable a disputer to hold one reserver currency and dispute against any number of\r\n * financial contracts. Is assumed to be called by a DSProxy which holds reserve currency.\r\n */\r\n\r\ncontract ReserveCurrencyDisputer {\r\n    using SafeMath for uint256;\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    /**\r\n     * @notice Swaps required amount of reserve currency to collateral currency which is then used to dispute a liquidation.\r\n     * @dev Any collateral the contract has will be used before anything is purchased on Uniswap.\r\n     * @param uniswapRouter address of the uniswap router used to facilitate trades.\r\n     * @param financialContract address of the financial contract on which the liquidation is occurring.\r\n     * @param reserveCurrency address of the token to swap for collateral. This is the common currency held by the DSProxy.\r\n     * @param sponsor address of the sponsor who's liquidation is disputed.\r\n     * @param liquidationId index of the liquidation for the given sponsor.\r\n     * @param maxReserveTokenSpent maximum number of reserve tokens to spend in the trade. Bounds slippage.\r\n     * @param deadline abort the trade and dispute if the transaction is mined after this timestamp.\r\n     **/\r\n    function swapDispute(\r\n        address uniswapRouter,\r\n        address financialContract,\r\n        address reserveCurrency,\r\n        uint256 liquidationId,\r\n        address sponsor,\r\n        uint256 maxReserveTokenSpent,\r\n        uint256 deadline\r\n    ) public {\r\n        IFinancialContract fc = IFinancialContract(financialContract);\r\n\r\n        // 1. Fetch information about the liquidation from the financial contract.\r\n        IFinancialContract.LiquidationData memory liquidationData = fc.liquidations(sponsor, liquidationId);\r\n\r\n        // 2. Fetch the disputeBondPercentage from the financial contract.\r\n        FixedPoint.Unsigned memory disputeBondPercentage = fc.disputeBondPercentage();\r\n\r\n        // 3. Compute the disputeBondAmount. Multiply by the unit collateral so the dispute bond is a percentage of the\r\n        // locked collateral after fees. To add fees we simply multiply the rawUnitCollateral by the cumulativeFeeMultiplier.\r\n        FixedPoint.Unsigned memory disputeBondAmount =\r\n            liquidationData.lockedCollateral.mul(disputeBondPercentage).mul(\r\n                (liquidationData.rawUnitCollateral).mul(fc.cumulativeFeeMultiplier())\r\n            );\r\n\r\n        // 4. Calculate required collateral. Cost of a dispute is the dispute bond + the final fee.\r\n        FixedPoint.Unsigned memory totalCollateralRequired = disputeBondAmount.add(liquidationData.finalFee);\r\n\r\n        // 5. Compute the collateral shortfall. This considers and collateral that is current in the contract.\r\n        FixedPoint.Unsigned memory collateralToBePurchased =\r\n            subOrZero(totalCollateralRequired, getCollateralBalance(fc));\r\n\r\n        // 6. If there is collateral to be purchased, buy it on uniswap with the reserve currency.\r\n        if (collateralToBePurchased.isGreaterThan(0) && reserveCurrency != fc.collateralCurrency()) {\r\n            IUniswapV2Router01 router = IUniswapV2Router01(uniswapRouter);\r\n            address[] memory path = new address[](2);\r\n            path[0] = reserveCurrency;\r\n            path[1] = fc.collateralCurrency();\r\n\r\n            TransferHelper.safeApprove(reserveCurrency, address(router), maxReserveTokenSpent);\r\n            router.swapTokensForExactTokens(\r\n                collateralToBePurchased.rawValue,\r\n                maxReserveTokenSpent,\r\n                path,\r\n                address(this),\r\n                deadline\r\n            );\r\n        }\r\n\r\n        // 7. Finally, submit the dispute.\r\n        TransferHelper.safeApprove(fc.collateralCurrency(), address(fc), totalCollateralRequired.rawValue);\r\n        fc.dispute(liquidationId, sponsor);\r\n    }\r\n\r\n    // Helper method to work around subtraction overflow in the case of: a - b with b > a.\r\n    function subOrZero(FixedPoint.Unsigned memory a, FixedPoint.Unsigned memory b)\r\n        internal\r\n        pure\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        return b.isGreaterThanOrEqual(a) ? FixedPoint.fromUnscaledUint(0) : a.sub(b);\r\n    }\r\n\r\n    // Helper method to return the collateral balance of this contract.\r\n    function getCollateralBalance(IFinancialContract fc) internal view returns (FixedPoint.Unsigned memory) {\r\n        return FixedPoint.Unsigned(IERC20(fc.collateralCurrency()).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\n// Define some simple interfaces for dealing with UMA contracts.\r\ninterface IFinancialContract {\r\n    enum Status { Uninitialized, NotDisputed, Disputed, DisputeSucceeded, DisputeFailed }\r\n\r\n    struct LiquidationData {\r\n        address sponsor;\r\n        address liquidator;\r\n        Status state;\r\n        uint256 liquidationTime;\r\n        FixedPoint.Unsigned tokensOutstanding;\r\n        FixedPoint.Unsigned lockedCollateral;\r\n        FixedPoint.Unsigned liquidatedCollateral;\r\n        FixedPoint.Unsigned rawUnitCollateral;\r\n        address disputer;\r\n        FixedPoint.Unsigned settlementPrice;\r\n        FixedPoint.Unsigned finalFee;\r\n    }\r\n\r\n    function liquidations(address sponsor, uint256 liquidationId) external view returns (LiquidationData memory);\r\n\r\n    function disputeBondPercentage() external view returns (FixedPoint.Unsigned memory);\r\n\r\n    function disputerDisputeRewardPct() external view returns (FixedPoint.Unsigned memory);\r\n\r\n    function cumulativeFeeMultiplier() external view returns (FixedPoint.Unsigned memory);\r\n\r\n    function collateralCurrency() external view returns (address);\r\n\r\n    function dispute(uint256 liquidationId, address sponsor) external returns (FixedPoint.Unsigned memory totalPaid);\r\n}\r\n"
    },
    "contracts/proxy-scripts/atomic-liquidator/ReserveCurrencyLiquidator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\";\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n/**\r\n * @title ReserveCurrencyLiquidator\r\n * @notice Helper contract to enable a liquidator to hold one reserver currency and liquidate against any number of\r\n * financial contracts. Is assumed to be called by a DSProxy which holds reserve currency.\r\n */\r\n\r\ncontract ReserveCurrencyLiquidator {\r\n    using SafeMath for uint256;\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    /**\r\n     * @notice Swaps required amount of reserve currency to collateral currency which is then used to mint tokens to\r\n     * liquidate a position within one transaction.\r\n     * @dev After the liquidation is done the DSProxy that called this method will have an open position AND pending\r\n     * liquidation within the financial contract. The bot using the DSProxy should withdraw the liquidation once it has\r\n     * passed liveness. At this point the position can be manually unwound.\r\n     * @dev Any synthetics & collateral that the DSProxy already has are considered in the amount swapped and minted.\r\n     * These existing tokens will be used first before any swaps or mints are done.\r\n     * @dev If there is a token shortfall (either from not enough reserve to buy sufficient collateral or not enough\r\n     * collateral to begins with or due to slippage) the script will liquidate as much as possible given the reserves.\r\n     * @param uniswapRouter address of the uniswap router used to facilitate trades.\r\n     * @param financialContract address of the financial contract on which the liquidation is occurring.\r\n     * @param reserveCurrency address of the token to swap for collateral. THis is the common currency held by the DSProxy.\r\n     * @param liquidatedSponsor address of the sponsor to be liquidated.\r\n     * @param maxSlippage max slip the trade on uniswap will accept before reverting.\r\n     * @param minCollateralPerTokenLiquidated abort the liquidation if the position's collateral per token is below this value.\r\n     * @param maxCollateralPerTokenLiquidated abort the liquidation if the position's collateral per token exceeds this value.\r\n     * @param maxTokensToLiquidate max number of tokens to liquidate. For a full liquidation this is the full position debt.\r\n     * @param deadline abort the trade and liquidation if the transaction is mined after this timestamp.\r\n     **/\r\n    function swapMintLiquidate(\r\n        address uniswapRouter,\r\n        address financialContract,\r\n        address reserveCurrency,\r\n        address liquidatedSponsor,\r\n        FixedPoint.Unsigned calldata minCollateralPerTokenLiquidated,\r\n        FixedPoint.Unsigned calldata maxCollateralPerTokenLiquidated,\r\n        FixedPoint.Unsigned memory maxTokensToLiquidate,\r\n        uint256 maxSlippage,\r\n        uint256 deadline\r\n    ) public {\r\n        IFinancialContract fc = IFinancialContract(financialContract);\r\n\r\n        // 1. Calculate the token shortfall. This is the synthetics to liquidate minus any synthetics the DSProxy already\r\n        // has. If this number is negative(balance large than synthetics to liquidate) the return 0 (no shortfall).\r\n        FixedPoint.Unsigned memory tokenShortfall = subOrZero(maxTokensToLiquidate, getSyntheticBalance(fc));\r\n\r\n        // 2. Calculate how much collateral is needed to make up the token shortfall from minting new synthetics.\r\n        FixedPoint.Unsigned memory gcr = fc.pfc().divCeil(fc.totalTokensOutstanding());\r\n        FixedPoint.Unsigned memory collateralToMintShortfall = tokenShortfall.mulCeil(gcr);\r\n\r\n        // 3. Calculate the total collateral required. This considers the final fee for the given collateral type + any\r\n        // collateral needed to mint the token short fall.\r\n\r\n        FixedPoint.Unsigned memory totalCollateralRequired = getFinalFee(fc).add(collateralToMintShortfall);\r\n\r\n        // 4.a. Calculate how much collateral needs to be purchased. If the DSProxy already has some collateral then this\r\n        // will factor this in. If the DSProxy has more collateral than the total amount required the purchased = 0.\r\n        uint256 collateralToBePurchased = subOrZero(totalCollateralRequired, getCollateralBalance(fc)).rawValue;\r\n\r\n        // 4.b. If there is some collateral to be purchased, execute a trade on uniswap to meet the shortfall.\r\n        // Note the path assumes a direct route from the reserve currency to the collateral currency.\r\n        // Note the maxInputAmount is computed by taking the 1000000 wei trade as the spot price from the router,\r\n        // multiplied by collateral to be purchased to arrive at a \"zero slippage input amount\". This would be the amount of\r\n        // required input to buy the amountOut, assuming zero slippage. This is then scalded by maxSlippage & swap fees\r\n        // to find the amountInMax that factors in the max tolerable exchange slippage. The maxSlippage is divided by two\r\n        // as slippage in an AMM is constituted by the inputToken going up and the outputToken going down in proportion.\r\n        // the +1e18 is used to offset the slippage percentage provided. i.e a 5% will be input at 0.05e18, offset by 1e18\r\n        // to bring it up to 1.05e18. the *997 and *1000 in the numerator and denominator respectively are for uniswap fees.\r\n        if (collateralToBePurchased > 0 && reserveCurrency != fc.collateralCurrency()) {\r\n            IUniswapV2Router01 router = IUniswapV2Router01(uniswapRouter);\r\n            address[] memory path = new address[](2);\r\n            path[0] = reserveCurrency;\r\n            path[1] = fc.collateralCurrency();\r\n\r\n            TransferHelper.safeApprove(reserveCurrency, address(router), type(uint256).max);\r\n            router.swapTokensForExactTokens(\r\n                collateralToBePurchased, // amountOut\r\n                (router.getAmountsIn(1000000, path)[0] * collateralToBePurchased * (1e18 + maxSlippage / 2) * 997) /\r\n                    (1000000 * 1e18 * 1000), // amountInMax\r\n                path,\r\n                address(this),\r\n                deadline\r\n            );\r\n        }\r\n\r\n        // 4.c. If at this point we were not able to get `the required amount of collateral (due to insufficient reserve\r\n        // or not enough collateral in the contract) the script should try to liquidate as much as it can regardless.\r\n        // Update the values of total collateral to the current collateral balance and re-compute the tokenShortfall\r\n        // as the maximum tokens that could be liquidated at the current GCR.\r\n        if (totalCollateralRequired.isGreaterThan(getCollateralBalance(fc))) {\r\n            totalCollateralRequired = getCollateralBalance(fc);\r\n            collateralToMintShortfall = totalCollateralRequired.sub(getFinalFee(fc));\r\n            tokenShortfall = collateralToMintShortfall.divCeil(gcr);\r\n        }\r\n        // 5. Mint the shortfall synthetics with collateral. Note we are minting at the GCR.\r\n        // If the DSProxy already has enough tokens (tokenShortfall = 0) we still preform the approval on the collateral\r\n        // currency as this is needed to pay the final fee in the liquidation tx.\r\n        TransferHelper.safeApprove(fc.collateralCurrency(), address(fc), totalCollateralRequired.rawValue);\r\n        if (tokenShortfall.isGreaterThan(0)) fc.create(collateralToMintShortfall, tokenShortfall);\r\n\r\n        // The liquidatableTokens is either the maxTokensToLiquidate (if we were able to buy/mint enough) or the full\r\n        // token token balance at this point if there was a shortfall.\r\n        if (maxTokensToLiquidate.isGreaterThan(getSyntheticBalance(fc))) maxTokensToLiquidate = getSyntheticBalance(fc);\r\n\r\n        // 6. Liquidate position with newly minted synthetics.\r\n        TransferHelper.safeApprove(fc.tokenCurrency(), address(fc), maxTokensToLiquidate.rawValue);\r\n        fc.createLiquidation(\r\n            liquidatedSponsor,\r\n            minCollateralPerTokenLiquidated,\r\n            maxCollateralPerTokenLiquidated,\r\n            maxTokensToLiquidate,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    // Helper method to work around subtraction overflow in the case of: a - b with b > a.\r\n    function subOrZero(FixedPoint.Unsigned memory a, FixedPoint.Unsigned memory b)\r\n        internal\r\n        pure\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        return b.isGreaterThanOrEqual(a) ? FixedPoint.fromUnscaledUint(0) : a.sub(b);\r\n    }\r\n\r\n    // Helper method to return the current final fee for a given financial contract instance.\r\n    function getFinalFee(IFinancialContract fc) internal view returns (FixedPoint.Unsigned memory) {\r\n        return IStore(IFinder(fc.finder()).getImplementationAddress(\"Store\")).computeFinalFee(fc.collateralCurrency());\r\n    }\r\n\r\n    // Helper method to return the collateral balance of this contract.\r\n    function getCollateralBalance(IFinancialContract fc) internal view returns (FixedPoint.Unsigned memory) {\r\n        return FixedPoint.Unsigned(IERC20(fc.collateralCurrency()).balanceOf(address(this)));\r\n    }\r\n\r\n    // Helper method to return the synthetic balance of this contract.\r\n    function getSyntheticBalance(IFinancialContract fc) internal view returns (FixedPoint.Unsigned memory) {\r\n        return FixedPoint.Unsigned(IERC20(fc.tokenCurrency()).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\n// Define some simple interfaces for dealing with UMA contracts.\r\ninterface IFinancialContract {\r\n    struct PositionData {\r\n        FixedPoint.Unsigned tokensOutstanding;\r\n        uint256 withdrawalRequestPassTimestamp;\r\n        FixedPoint.Unsigned withdrawalRequestAmount;\r\n        FixedPoint.Unsigned rawCollateral;\r\n        uint256 transferPositionRequestPassTimestamp;\r\n    }\r\n\r\n    function positions(address sponsor) external view returns (PositionData memory);\r\n\r\n    function collateralCurrency() external view returns (address);\r\n\r\n    function tokenCurrency() external view returns (address);\r\n\r\n    function finder() external view returns (address);\r\n\r\n    function pfc() external view returns (FixedPoint.Unsigned memory);\r\n\r\n    function totalTokensOutstanding() external view returns (FixedPoint.Unsigned memory);\r\n\r\n    function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens) external;\r\n\r\n    function createLiquidation(\r\n        address sponsor,\r\n        FixedPoint.Unsigned calldata minCollateralPerToken,\r\n        FixedPoint.Unsigned calldata maxCollateralPerToken,\r\n        FixedPoint.Unsigned calldata maxTokensToLiquidate,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 liquidationId,\r\n            FixedPoint.Unsigned memory tokensLiquidated,\r\n            FixedPoint.Unsigned memory finalFeeBond\r\n        );\r\n}\r\n\r\ninterface IStore {\r\n    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory);\r\n}\r\n\r\ninterface IFinder {\r\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\r\n}\r\n"
    },
    "contracts/proxy-scripts/bot-action-wrappers/LiquidationWithdrawer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n// Simple contract used to withdraw liquidations using a DSProxy from legacy contracts (1.2.2 and below).\r\ncontract LiquidationWithdrawer {\r\n    function withdrawLiquidation(\r\n        address financialContractAddress,\r\n        uint256 liquidationId,\r\n        address sponsor\r\n    ) public returns (FixedPoint.Unsigned memory) {\r\n        return IFinancialContract(financialContractAddress).withdrawLiquidation(liquidationId, sponsor);\r\n    }\r\n}\r\n\r\ninterface IFinancialContract {\r\n    function withdrawLiquidation(uint256 liquidationId, address sponsor)\r\n        external\r\n        returns (FixedPoint.Unsigned memory amountWithdrawn);\r\n}\r\n"
    },
    "contracts/proxy-scripts/bot-action-wrappers/PositionSettler.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\n// Simple contract used to Settle expired positions using a DSProxy.\r\ncontract PositionSettler {\r\n    function settleExpired(address financialContractAddress) public returns (FixedPoint.Unsigned memory) {\r\n        return IFinancialContract(financialContractAddress).settleExpired();\r\n    }\r\n}\r\n\r\ninterface IFinancialContract {\r\n    function settleExpired() external returns (FixedPoint.Unsigned memory amountWithdrawn);\r\n}\r\n"
    },
    "contracts/proxy-scripts/bot-action-wrappers/TokenRedeemer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\n\r\n// Simple contract used to redeem tokens using a DSProxy from an emp.\r\ncontract TokenRedeemer {\r\n    function redeem(address financialContractAddress, FixedPoint.Unsigned memory numTokens)\r\n        public\r\n        returns (FixedPoint.Unsigned memory)\r\n    {\r\n        IFinancialContract fc = IFinancialContract(financialContractAddress);\r\n        TransferHelper.safeApprove(fc.tokenCurrency(), financialContractAddress, numTokens.rawValue);\r\n        return fc.redeem(numTokens);\r\n    }\r\n}\r\n\r\ninterface IFinancialContract {\r\n    function redeem(FixedPoint.Unsigned memory numTokens) external returns (FixedPoint.Unsigned memory amountWithdrawn);\r\n\r\n    function tokenCurrency() external returns (address);\r\n}\r\n"
    },
    "contracts/proxy-scripts/bot-action-wrappers/TokenSender.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../common/implementation/ExpandedERC20.sol\";\r\n\r\ncontract TokenSender {\r\n    function transferERC20(\r\n        address tokenAddress,\r\n        address recipientAddress,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        IERC20 token = IERC20(tokenAddress);\r\n        token.transfer(recipientAddress, amount);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/proxy-scripts/lsp-broker/LspUniswapV2Broker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\r\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\r\n\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\";\r\n\r\nimport \"../../common/implementation/FixedPoint.sol\";\r\n\r\nimport \"../../financial-templates/long-short-pair/LongShortPair.sol\";\r\n\r\n/**\r\n * @title LspUniswapV2Broker\r\n * @notice Helper contract to facilitate batched LSP and UniswapV2 transactions, including Mint+Sell and Mint+LP.\r\n */\r\ncontract LspUniswapV2Broker {\r\n    using FixedPoint for FixedPoint.Signed;\r\n    using FixedPoint for FixedPoint.Unsigned;\r\n\r\n    /**\r\n     * @notice Mint long and short tokens and deposit them all into a UniV2 Pool.\r\n     * @dev The caller of this method needs to approve `amountCollateral` collateral to be spent by this contract.\r\n     * @param callingAsEOA If True, caller has balance of collateral and expects to receive back all LP  tokens + dust.\r\n     * @param longShortPair LSP contract address to mint position on.\r\n     * @param router Contract to call to exchange long and short tokens.\r\n     * @param amountCollateral Amount of collateral to deposit and mint long and short tokens against.\r\n     * @param minLpTokens Minimum number of LP tokens to mint\r\n     * @param deadline Unix timestamp that will force the transaction to revert if minded after this time.\r\n     */\r\n    function atomicMintAddLiquidity(\r\n        bool callingAsEOA,\r\n        LongShortPair longShortPair,\r\n        IUniswapV2Router01 router,\r\n        uint256 amountCollateral,\r\n        uint256 minLpTokens,\r\n        uint256 deadline\r\n    ) public {\r\n        require(address(longShortPair) != address(0), \"Invalid long short pair\");\r\n        require(address(router) != address(0), \"Invalid router\");\r\n        require(amountCollateral != 0, \"Collateral to mint with\");\r\n\r\n        IERC20 collateralToken = IERC20(longShortPair.collateralToken());\r\n        IERC20 longToken = IERC20(longShortPair.longToken());\r\n        IERC20 shortToken = IERC20(longShortPair.shortToken());\r\n\r\n        // 0) Pull collateral from caller if necessary and approve LSP to spend it.\r\n        if (callingAsEOA)\r\n            TransferHelper.safeTransferFrom(address(collateralToken), msg.sender, address(this), amountCollateral);\r\n\r\n        // 1) Approve collateral to be spent by the LSP from this contract at size of amountCollateral.\r\n        TransferHelper.safeApprove(address(collateralToken), address(longShortPair), amountCollateral);\r\n\r\n        // 2) Deposit collateral into LSP and mint long and short tokens.\r\n        uint256 tokensToCreate =\r\n            FixedPoint.fromUnscaledUint(amountCollateral).div(longShortPair.collateralPerPair()).rawValue;\r\n        longShortPair.create(tokensToCreate);\r\n\r\n        require(\r\n            longToken.balanceOf(address(this)) == shortToken.balanceOf(address(this)) &&\r\n                longToken.balanceOf(address(this)) == tokensToCreate,\r\n            \"Create invariant failed\"\r\n        );\r\n\r\n        {\r\n            // 3) Calculate if we need to sell the long token for the short or the short token for the long. Calculate\r\n            // the total trade size to bring the balance of long/short in this contract to equal the pool ratio after\r\n            // the trade. Note this computation must consider how the resultant pool ratios is impacted by the trade.\r\n            bool aToB;\r\n            uint256 tradeSize;\r\n            (uint256 reserveA, uint256 reserveB) =\r\n                getReserves(router.factory(), address(longToken), address(shortToken));\r\n            (aToB, tradeSize) = computeSwapToMintAtPoolRatio(\r\n                FixedPoint.Signed(int256(tokensToCreate)),\r\n                FixedPoint.Signed(int256(reserveA)),\r\n                FixedPoint.Signed(int256(reserveB))\r\n            );\r\n            address[] memory path = new address[](2);\r\n\r\n            // 3.a) If the trade is token a to b then we are selling long tokens for short tokens. In this case, we\r\n            // know the exact output number of tokens we want (short tokens) and use the router's\r\n            // swapTokensForExactTokens with the exact output number of tokens specified.\r\n            if (aToB && tradeSize > 0) {\r\n                path[0] = address(longToken);\r\n                path[1] = address(shortToken);\r\n                TransferHelper.safeApprove(address(longToken), address(router), tradeSize);\r\n                router.swapTokensForExactTokens(tradeSize, type(uint256).max, path, address(this), deadline);\r\n            }\r\n            if (!aToB && tradeSize > 0) {\r\n                // Else, if the trade is b to a then we are selling short tokens for long tokens. In this case, we\r\n                // know the exact input number of tokens that we need to sell (short tokens) and can use the router's\r\n                // swapExactTokensForTokens with the exact input specified.\r\n                path[0] = address(shortToken);\r\n                path[1] = address(longToken);\r\n                TransferHelper.safeApprove(address(shortToken), address(router), tradeSize);\r\n                router.swapExactTokensForTokens(tradeSize, 0, path, address(this), deadline);\r\n            }\r\n        }\r\n\r\n        // 4) Add liquidity to the pool via the router. Approve both long and short tokens with the full account balance\r\n        // in this contract (i.e the amount of tokens minted +- that traded in step 2.).\r\n        TransferHelper.safeApprove(address(longToken), address(router), longToken.balanceOf(address(this)));\r\n        TransferHelper.safeApprove(address(shortToken), address(router), shortToken.balanceOf(address(this)));\r\n        router.addLiquidity(\r\n            address(longToken),\r\n            address(shortToken),\r\n            longToken.balanceOf(address(this)),\r\n            shortToken.balanceOf(address(this)),\r\n            0,\r\n            0,\r\n            address(this),\r\n            deadline\r\n        );\r\n\r\n        // 5) Validate that at least the minimum number of tokens have been minted. If not, revert.\r\n        {\r\n            IERC20 lPToken = IERC20(address(pairFor(router.factory(), address(longToken), address(shortToken))));\r\n            require(lPToken.balanceOf(address(this)) > minLpTokens, \"Failed to mint min LP tokens\");\r\n\r\n            // 5) Finally, if the caller is an EOA, send back the LP tokens from minting + any dust that was left over.\r\n            // The dust is in the long and short tokens and will be left over as a result of small rounding errors in\r\n            // the calculation on how many long/short should be bought/sold to meet the pool ratio before minting.\r\n            if (callingAsEOA) {\r\n                // Send the LP tokens back to the minter.\r\n                TransferHelper.safeTransfer(address(lPToken), msg.sender, lPToken.balanceOf(address(this)));\r\n\r\n                // Send any dust left over back to the minter that may have happened due to small rounding errors in\r\n                // the computation methods within computeSwapToMintAtPoolRatio.\r\n                TransferHelper.safeTransfer(address(longToken), msg.sender, longToken.balanceOf(address(this)));\r\n                TransferHelper.safeTransfer(address(shortToken), msg.sender, shortToken.balanceOf(address(this)));\r\n            }\r\n        }\r\n    }\r\n\r\n    // For a given mint size (m) and pool balances (ra & rb), compute the trade size such that the resulting ratio\r\n    // of tokens, considering the mint and trade,is equal to the pool ratio after the trade. This is computed using the\r\n    // following logic: Assume m tokens are minted in equal proportion of long and short. This contract will therefore\r\n    // hold t_l=m+l long tokens and t_s=m-s after a trade of s for l tokens. The ratio t_l/t_s must equal the pool\r\n    // ratio after the trade. The pool ratio, considering the trade can be expressed as (R_a-a)(R_b+b)=k for a\r\n    // trade of a for b and a swap fee of =(1-swapFee). Using this, with a bit of algebra and simplification, we can\r\n    // solve for the resultant ratio to be (m+a)/(m-b)=(R_a-a)/(R_b+b). i.e the ratio of mint+trade must equal the\r\n    // ratio of token A and B in the pool after the trade has concluded. We also know that a can be solved for as\r\n    // a=(bR_a)/(R_b+b) by manipulating a known uniswap equation. Using this equation and the expression of ratios\r\n    // we can solve simultaneously for b. I.e how many short tokens do we need to sell such that the ratio of long and\r\n    // short after the trade equal the pool ratios. Numerically, this works out to this form:\r\n    // b=(sqrt(R_b(R_a+m)(R_a(R_b(^2+2+1)+4m)+R_b(^2-2+1)m))+R_b(--1)(R_a+m))/(2(R_a+m)). For how this was solved\r\n    // from the algebraic solution above see https://bit.ly/3jn7AF6 on wolfram alpha showing the derivation.\r\n    function computeSwapToMintAtPoolRatio(\r\n        FixedPoint.Signed memory m,\r\n        FixedPoint.Signed memory ra,\r\n        FixedPoint.Signed memory rb\r\n    ) private pure returns (bool, uint256) {\r\n        FixedPoint.Signed memory numerator1 =\r\n            sqrt(\r\n                rb.mul(ra.add(m)).mul(\r\n                    ra\r\n                        .mul(rb.mul(lambda2().add(num(2).mul(lambda())).add(num(1))).add(num(4).mul(lambda().mul(m))))\r\n                        .add(rb.mul(lambda2().sub(num(2).mul(lambda())).add(num(1))).mul(m))\r\n                )\r\n            );\r\n\r\n        FixedPoint.Signed memory numerator2 = rb.mul(ra.add(m)).mul(num(-1).sub(lambda()));\r\n\r\n        FixedPoint.Signed memory numerator = numerator1.mul(1e9).add(numerator2);\r\n\r\n        FixedPoint.Signed memory denominator = num(2).mul(lambda()).mul(ra.add(m));\r\n\r\n        FixedPoint.Signed memory tradeSize = numerator.div(denominator);\r\n\r\n        // If the trade size is negative then we are traversing the equation backwards. In this case the contract must\r\n        // swap between swapTokensForExactTokens and swapExactTokensForTokens methods as we are always solving for b.\r\n        // In other words, we are always solving for how many short tokens are needed to be bought/sold. If the number\r\n        // is positive then we are buying them. if it is negative then we are selling them. In the case we are selling\r\n        // them (negative) then we swap the polarity and apply the swap fee to the trade.\r\n        bool aToB = tradeSize.isLessThan(0);\r\n        return (aToB, uint256(aToB ? applySwapFee(tradeSize.mul(-1)).rawValue : tradeSize.rawValue));\r\n    }\r\n\r\n    // Syntactical sugar to calculate square root of a number.\r\n    function sqrt(FixedPoint.Signed memory _num) private pure returns (FixedPoint.Signed memory) {\r\n        return FixedPoint.Signed(int256(Babylonian.sqrt(uint256(_num.rawValue))));\r\n    }\r\n\r\n    // Syntactical sugar to convert a int256 to a Fixedpoint.Signed.\r\n    function num(int256 _num) private pure returns (FixedPoint.Signed memory) {\r\n        return FixedPoint.fromUnscaledInt(_num);\r\n    }\r\n\r\n    // Takes an input fixedPoint.Signed num and returns the num scaled by 0.997. 0.3% swap fee as in uniswap.\r\n    function applySwapFee(FixedPoint.Signed memory _num) private pure returns (FixedPoint.Signed memory) {\r\n        return _num.mul(997).div(1000);\r\n    }\r\n\r\n    // 1 with 0.3% fees applied.\r\n    function lambda() private pure returns (FixedPoint.Signed memory) {\r\n        return applySwapFee(FixedPoint.fromUnscaledInt(1));\r\n    }\r\n\r\n    // 1 with 0.3% fees applied twice.\r\n    function lambda2() private pure returns (FixedPoint.Signed memory) {\r\n        return applySwapFee(lambda());\r\n    }\r\n\r\n    /**\r\n     * @notice Mint long and short tokens and convert all of one side into the other.\r\n     * @dev The caller of this method needs to approve `amountCollateral` collateral to be spent by this contract.\r\n     * @param callingAsEOA If True, caller has balance of collateral and expects to receive back all long/short tokens.\r\n     * @param sellLong If True, converts all long tokens into short, else the opposite.\r\n     * @param longShortPair LSP contract address to mint position on.\r\n     * @param router Contract to call to exchange long and short tokens.\r\n     * @param amountCollateral Amount of collateral to deposit and mint long and short tokens against.\r\n     * @param swapPath `Router.swapExactTokensForTokens` param: path with which to swap token to sell for the other.\r\n     * @param deadline `Router.swapExactTokensForTokens` param: time before transaction must be mined.\r\n     */\r\n    function atomicMintSellOneSide(\r\n        bool callingAsEOA,\r\n        bool sellLong,\r\n        LongShortPair longShortPair,\r\n        IUniswapV2Router01 router, /* TODO: Should we allow `router` to be any exchange, such as a Matcha multihop? */\r\n        uint256 amountCollateral,\r\n        address[] memory swapPath,\r\n        uint256 deadline\r\n    ) public {\r\n        require(address(longShortPair) != address(0), \"Invalid long short pair\");\r\n        require(address(router) != address(0), \"Invalid router\");\r\n        require(amountCollateral != 0, \"Collateral to mint with\");\r\n\r\n        IERC20 collateralToken = IERC20(longShortPair.collateralToken());\r\n\r\n        // 0) Pull collateral from caller if necessary and approve LSP to spend it.\r\n        if (callingAsEOA)\r\n            TransferHelper.safeTransferFrom(address(collateralToken), msg.sender, address(this), amountCollateral);\r\n\r\n        TransferHelper.safeApprove(address(collateralToken), address(longShortPair), amountCollateral);\r\n\r\n        // 1) Deposit collateral into LSP and mint long and short tokens.\r\n        uint256 tokensToCreate =\r\n            FixedPoint.fromUnscaledUint(amountCollateral).div(longShortPair.collateralPerPair()).rawValue;\r\n        longShortPair.create(tokensToCreate);\r\n\r\n        // 2) Determine which token we are selling and convert it all into the other.\r\n        IERC20 soldToken = IERC20(sellLong ? longShortPair.shortToken() : longShortPair.longToken());\r\n        TransferHelper.safeApprove(address(soldToken), address(router), soldToken.balanceOf(address(this)));\r\n        require(swapPath[0] == address(soldToken), \"Sold token != 0th swapPath\");\r\n        router.swapExactTokensForTokens(\r\n            soldToken.balanceOf(address(this)), // sell all of the sold tokens held by the contract.\r\n            0,\r\n            swapPath,\r\n            address(this),\r\n            deadline\r\n        );\r\n\r\n        // 3) Send tokens back to caller if necessary.\r\n        if (callingAsEOA) {\r\n            IERC20 purchasedToken = IERC20(!sellLong ? longShortPair.shortToken() : longShortPair.longToken());\r\n            TransferHelper.safeTransfer(address(purchasedToken), msg.sender, purchasedToken.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    function getReserves(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) public view returns (uint256 reserveA, uint256 reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal pure returns (IUniswapV2Pair pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = IUniswapV2Pair(\r\n            address(\r\n                uint160(\r\n                    uint256(\r\n                        keccak256(\r\n                            abi.encodePacked(\r\n                                hex\"ff\",\r\n                                factory,\r\n                                keccak256(abi.encodePacked(token0, token1)),\r\n                                hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/proxy-scripts/uniswap-broker/UniswapV2Broker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\r\n\r\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\";\r\n\r\n/**\r\n * @title UniswapV2Broker\r\n * @notice Trading contract used to arb uniswap pairs to a desired \"true\" price. Intended use is to arb UMA perpetual\r\n * synthetics that trade off peg. This implementation can ber used in conjunction with a DSProxy contract to atomically\r\n * swap and move a uniswap market.\r\n */\r\n\r\ncontract UniswapV2Broker {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @notice Swaps an amount of either token such that the trade results in the uniswap pair's price being as close as\r\n     * possible to the truePrice.\r\n     * @dev True price is expressed in the ratio of token A to token B.\r\n     * @dev The caller must approve this contract to spend whichever token is intended to be swapped.\r\n     * @param tradingAsEOA bool to indicate if the UniswapV2Broker is being called by a DSProxy or an EOA.\r\n     * @param uniswapRouter address of the uniswap router used to facilitate trades.\r\n     * @param uniswapFactory address of the uniswap factory used to fetch current pair reserves.\r\n     * @param swappedTokens array of addresses which are to be swapped. The order does not matter as the function will figure\r\n     * out which tokens need to be exchanged to move the market to the desired \"true\" price.\r\n     * @param truePriceTokens array of unit used to represent the true price. 0th value is the numerator of the true price\r\n     * and the 1st value is the the denominator of the true price.\r\n     * @param maxSpendTokens array of unit to represent the max to spend in the two tokens.\r\n     * @param to recipient of the trade proceeds.\r\n     * @param deadline to limit when the trade can execute. If the tx is mined after this timestamp then revert.\r\n     */\r\n    function swapToPrice(\r\n        bool tradingAsEOA,\r\n        address uniswapRouter,\r\n        address uniswapFactory,\r\n        address[2] memory swappedTokens,\r\n        uint256[2] memory truePriceTokens,\r\n        uint256[2] memory maxSpendTokens,\r\n        address to,\r\n        uint256 deadline\r\n    ) public {\r\n        IUniswapV2Router01 router = IUniswapV2Router01(uniswapRouter);\r\n\r\n        // true price is expressed as a ratio, so both values must be non-zero\r\n        require(truePriceTokens[0] != 0 && truePriceTokens[1] != 0, \"SwapToPrice: ZERO_PRICE\");\r\n        // caller can specify 0 for either if they wish to swap in only one direction, but not both\r\n        require(maxSpendTokens[0] != 0 || maxSpendTokens[1] != 0, \"SwapToPrice: ZERO_SPEND\");\r\n\r\n        bool aToB;\r\n        uint256 amountIn;\r\n        {\r\n            (uint256 reserveA, uint256 reserveB) = getReserves(uniswapFactory, swappedTokens[0], swappedTokens[1]);\r\n            (aToB, amountIn) = computeTradeToMoveMarket(truePriceTokens[0], truePriceTokens[1], reserveA, reserveB);\r\n        }\r\n\r\n        require(amountIn > 0, \"SwapToPrice: ZERO_AMOUNT_IN\");\r\n\r\n        // spend up to the allowance of the token in\r\n        uint256 maxSpend = aToB ? maxSpendTokens[0] : maxSpendTokens[1];\r\n        if (amountIn > maxSpend) {\r\n            amountIn = maxSpend;\r\n        }\r\n\r\n        address tokenIn = aToB ? swappedTokens[0] : swappedTokens[1];\r\n        address tokenOut = aToB ? swappedTokens[1] : swappedTokens[0];\r\n\r\n        TransferHelper.safeApprove(tokenIn, address(router), amountIn);\r\n\r\n        if (tradingAsEOA) TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), amountIn);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenIn;\r\n        path[1] = tokenOut;\r\n\r\n        router.swapExactTokensForTokens(\r\n            amountIn,\r\n            0, // amountOutMin: we can skip computing this number because the math is tested within the uniswap tests.\r\n            path,\r\n            to,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Given the \"true\" price a token (represented by truePriceTokenA/truePriceTokenB) and the reservers in the\r\n     * uniswap pair, calculate: a) the direction of trade (aToB) and b) the amount needed to trade (amountIn) to move\r\n     * the pool price to be equal to the true price.\r\n     * @dev Note that this method uses the Babylonian square root method which has a small margin of error which will\r\n     * result in a small over or under estimation on the size of the trade needed.\r\n     * @param truePriceTokenA the nominator of the true price.\r\n     * @param truePriceTokenB the denominator of the true price.\r\n     * @param reserveA number of token A in the pair reserves\r\n     * @param reserveB number of token B in the pair reserves\r\n     */\r\n    //\r\n    function computeTradeToMoveMarket(\r\n        uint256 truePriceTokenA,\r\n        uint256 truePriceTokenB,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) public pure returns (bool aToB, uint256 amountIn) {\r\n        aToB = FullMath.mulDiv(reserveA, truePriceTokenB, reserveB) < truePriceTokenA;\r\n\r\n        uint256 invariant = reserveA.mul(reserveB);\r\n\r\n        // The trade a of token a required to move the market to some desired price P' from the current price P can be\r\n        // found with a=(kP')^1/2-Ra.\r\n        uint256 leftSide =\r\n            Babylonian.sqrt(\r\n                FullMath.mulDiv(\r\n                    invariant,\r\n                    aToB ? truePriceTokenA : truePriceTokenB,\r\n                    aToB ? truePriceTokenB : truePriceTokenA\r\n                )\r\n            );\r\n        uint256 rightSide = (aToB ? reserveA : reserveB);\r\n\r\n        if (leftSide < rightSide) return (false, 0);\r\n\r\n        // compute the amount that must be sent to move the price back to the true price.\r\n        amountIn = leftSide.sub(rightSide);\r\n    }\r\n\r\n    // The methods below are taken from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol\r\n    // We could import this library into this contract but this library is dependent Uniswap's SafeMath, which is bound\r\n    // to solidity 6.6.6. UMA uses 0.8.0 and so a modified version is needed to accomidate this solidity version.\r\n    function getReserves(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) public view returns (uint256 reserveA, uint256 reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(\r\n            uint160(\r\n                uint256(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            hex\"ff\",\r\n                            factory,\r\n                            keccak256(abi.encodePacked(token0, token1)),\r\n                            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\n// The library below is taken from @uniswap/lib/contracts/libraries/FullMath.sol. It has been modified to work with solidity 0.8\r\nlibrary FullMath {\r\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = a * b\r\n        // Compute the product mod 2**256 and mod 2**256 - 1\r\n        // then use the Chinese Remainder Theorem to reconstruct\r\n        // the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2**256 + prod0\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(a, b, not(0))\r\n            prod0 := mul(a, b)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division\r\n        if (prod1 == 0) {\r\n            require(denominator > 0);\r\n            assembly {\r\n                result := div(prod0, denominator)\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2**256.\r\n        // Also prevents denominator == 0\r\n        require(denominator > prod1);\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0]\r\n        // Compute remainder using mulmod\r\n        uint256 remainder;\r\n        assembly {\r\n            remainder := mulmod(a, b, denominator)\r\n        }\r\n        // Subtract 256 bit number from 512 bit number\r\n        assembly {\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator\r\n        // Compute largest power of two divisor of denominator.\r\n        // Always >= 1.\r\n        uint256 twos = denominator & (~denominator + 1);\r\n        // Divide denominator by power of two\r\n        assembly {\r\n            denominator := div(denominator, twos)\r\n        }\r\n\r\n        // Divide [prod1 prod0] by the factors of two\r\n        assembly {\r\n            prod0 := div(prod0, twos)\r\n        }\r\n        // Shift in bits from prod1 into prod0. For this we need\r\n        // to flip `twos` such that it is 2**256 / twos.\r\n        // If twos is zero, then it becomes one\r\n        assembly {\r\n            twos := add(div(sub(0, twos), twos), 1)\r\n        }\r\n        prod0 |= prod1 * twos;\r\n\r\n        // Invert denominator mod 2**256\r\n        // Now that denominator is an odd number, it has an inverse\r\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n        // Compute the inverse by starting with a seed that is correct\r\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n        uint256 inv = (3 * denominator) ^ 2;\r\n        // Now use Newton-Raphson iteration to improve the precision.\r\n        // Thanks to Hensel's lifting lemma, this also works in modular\r\n        // arithmetic, doubling the correct bits in each step.\r\n        inv *= 2 - denominator * inv; // inverse mod 2**8\r\n        inv *= 2 - denominator * inv; // inverse mod 2**16\r\n        inv *= 2 - denominator * inv; // inverse mod 2**32\r\n        inv *= 2 - denominator * inv; // inverse mod 2**64\r\n        inv *= 2 - denominator * inv; // inverse mod 2**128\r\n        inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n        // Because the division is now exact we can divide by multiplying\r\n        // with the modular inverse of denominator. This will give us the\r\n        // correct result modulo 2**256. Since the precoditions guarantee\r\n        // that the outcome is less than 2**256, this is the final result.\r\n        // We don't need to compute the high bits of the result and prod1\r\n        // is no longer required.\r\n        result = prod0 * inv;\r\n        return result;\r\n    }\r\n\r\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    function mulDivRoundingUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        result = mulDiv(a, b, denominator);\r\n        if (mulmod(a, b, denominator) > 0) {\r\n            require(result < type(uint256).max);\r\n            result++;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/proxy-scripts/uniswap-broker/UniswapV3Broker.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\n\r\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\r\n\r\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\r\n\r\nimport \"@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol\";\r\nimport \"@uniswap/v3-core/contracts/libraries/LiquidityMath.sol\";\r\nimport \"@uniswap/v3-core/contracts/libraries/BitMath.sol\";\r\nimport \"@uniswap/v3-core/contracts/libraries/UnsafeMath.sol\";\r\nimport \"@uniswap/v3-core/contracts/libraries/SafeCast.sol\";\r\n\r\n/**\r\n * @title UniswapV3Broker\r\n * @notice Trading contract used to arb uniswapV3 pairs to a desired \"true\" price. Intended use is to arb UMA perpetual\r\n * synthetics that trade off peg. This implementation can ber used in conjunction with a DSProxy contract to atomically\r\n * swap and move a uniswap market.\r\n */\r\n\r\ncontract UniswapV3Broker {\r\n    using SafeCast for uint256;\r\n    using LowGasSafeMath for uint256;\r\n    using LowGasSafeMath for int256;\r\n\r\n    struct SwapState {\r\n        uint160 sqrtPriceX96;\r\n        int24 tick;\r\n        uint128 liquidity;\r\n        uint256 requiredInputAmount;\r\n    }\r\n\r\n    struct StepComputations {\r\n        uint160 sqrtPriceStartX96;\r\n        int24 tickNext;\r\n        bool initialized;\r\n        uint160 sqrtPriceNextX96;\r\n    }\r\n\r\n    /**\r\n     * @notice Swaps an amount of either pool tokens such that the trade results in the uniswap pair's price equaling a\r\n     * desired price.\r\n     * @dev The desired price is represented as sqrtRatioTargetX96. This is the Price^(1/2) * 96^2.\r\n     * @dev The caller must approve this contract to spend whichever token is intended to be swapped.\r\n     * @param tradingAsEOA bool to indicate if the UniswapBroker is being called by a DSProxy or an EOA.\r\n     * @param uniswapPool address of the pool to uniswap v3 trade against.\r\n     * @param uniswapRouter address of the uniswap v3 router to route the trade.\r\n     * @param sqrtRatioTargetX96 target, encoded price.\r\n     * @param recipient address that the output tokens should be sent to.\r\n     * @param deadline to limit when the trade can execute. If the tx is mined after this timestamp then revert.\r\n     */\r\n    function swapToPrice(\r\n        bool tradingAsEOA,\r\n        address uniswapPool,\r\n        address uniswapRouter,\r\n        uint160 sqrtRatioTargetX96,\r\n        address recipient,\r\n        uint256 deadline\r\n    ) external returns (uint256) {\r\n        // Create an instance of the pool and load in the current token price and the active tick.\r\n        IUniswapV3Pool pool = IUniswapV3Pool(uniswapPool);\r\n        (uint160 sqrtPriceX96, int24 tick, , , , , ) = pool.slot0();\r\n\r\n        // Work out the direction we need to trade. If the current price is more than the target price then we are\r\n        // trading token0 for token1. Else, we are trading token1 for token0.\r\n        bool zeroForOne = sqrtPriceX96 >= sqrtRatioTargetX96;\r\n\r\n        // Build a state object to store this information which can be re-used during.\r\n        SwapState memory state =\r\n            SwapState({ sqrtPriceX96: sqrtPriceX96, tick: tick, liquidity: pool.liquidity(), requiredInputAmount: 0 });\r\n\r\n        // Iterate in a while loop that breaks when we hit the target price.\r\n        while (true) {\r\n            // Compute the next initialized tick. We only need to traverse initialized ticks as uninitialized ticks\r\n            // have the same liquidity as the previous tick.\r\n            StepComputations memory step;\r\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\r\n            (step.tickNext, step.initialized) = TickBitmap.nextInitializedTickWithinOneWord(\r\n                pool,\r\n                state.tick,\r\n                pool.tickSpacing(),\r\n                zeroForOne\r\n            );\r\n\r\n            // Double check we are not over or underflow the ticks.\r\n            if (step.tickNext < TickMath.MIN_TICK) step.tickNext = TickMath.MIN_TICK;\r\n            else if (step.tickNext > TickMath.MAX_TICK) step.tickNext = TickMath.MAX_TICK;\r\n\r\n            // Find the price at the next tick. Between the current state.sqrtPriceX96 and the nextTickPriceX96 we\r\n            // can find how much of the sold token is needed to sufficiently move the market over the interval.\r\n\r\n            uint160 nextTickPriceX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\r\n            uint256 inputAmountForStep;\r\n\r\n            // If zeroForOne is true, then we are moving the price UP. In this case we need to ensure that if the next\r\n            // tick price is more than the target price, we set the set the the next step price to the target price. This\r\n            // ensures that the price does not undershoot when the next tick is the last tick. Else, traverse the whole tick.\r\n            if (zeroForOne) {\r\n                step.sqrtPriceNextX96 = nextTickPriceX96 > sqrtRatioTargetX96 ? sqrtRatioTargetX96 : nextTickPriceX96;\r\n                inputAmountForStep = SqrtPriceMath.getAmount0Delta( // As we are trading token0 for token1, calculate the token0 input.\r\n                    step.sqrtPriceStartX96,\r\n                    step.sqrtPriceNextX96,\r\n                    state.liquidity,\r\n                    false\r\n                );\r\n                // Else, if zeroForOne is false, then we are moving the price DOWN. In this case we need to ensure that we\r\n                // don't overshoot the price on the next step.\r\n            } else {\r\n                step.sqrtPriceNextX96 = nextTickPriceX96 > sqrtRatioTargetX96 ? nextTickPriceX96 : sqrtRatioTargetX96;\r\n                inputAmountForStep = SqrtPriceMath.getAmount1Delta( // As we are trading token1 for token0, calculate the token1 input.\r\n                    step.sqrtPriceStartX96,\r\n                    step.sqrtPriceNextX96,\r\n                    state.liquidity,\r\n                    false\r\n                );\r\n            }\r\n\r\n            // Add amount for this step to the total required input.\r\n            state.requiredInputAmount = state.requiredInputAmount.add(inputAmountForStep);\r\n\r\n            // If we have hit(or exceeded) our target price in the associate direction, then stop.\r\n            if (zeroForOne && state.sqrtPriceX96 <= sqrtRatioTargetX96) break;\r\n            if (!zeroForOne && state.sqrtPriceX96 >= sqrtRatioTargetX96) break;\r\n\r\n            // If the next step is is initialized then we will need to update the liquidity for the current step.\r\n            if (step.initialized) {\r\n                // Fetch the net liquidity. this could be positive or negative depending on if a LP is turning on or off at this price.\r\n                (, int128 liquidityNet, , , , , , ) = pool.ticks(step.tickNext);\r\n                state.liquidity = LiquidityMath.addDelta(state.liquidity, zeroForOne ? liquidityNet : -liquidityNet);\r\n            }\r\n\r\n            // Finally, set the state price to the next price for the next iteration.\r\n            state.sqrtPriceX96 = step.sqrtPriceNextX96;\r\n            state.tick = step.tickNext;\r\n        }\r\n\r\n        // Based on the direction we are moving, set the input and output tokens.\r\n        (address tokenIn, address tokenOut) =\r\n            zeroForOne ? (pool.token0(), pool.token1()) : (pool.token1(), pool.token0());\r\n\r\n        // If trading from an EOA pull tokens into this contract. If trading from a DSProxy this is redundant.\r\n        if (tradingAsEOA)\r\n            TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), state.requiredInputAmount);\r\n\r\n        // Approve the router and execute the swap.\r\n        TransferHelper.safeApprove(tokenIn, address(uniswapRouter), state.requiredInputAmount);\r\n        ISwapRouter(uniswapRouter).exactInputSingle(\r\n            ISwapRouter.ExactInputSingleParams({\r\n                tokenIn: tokenIn,\r\n                tokenOut: tokenOut,\r\n                fee: pool.fee(),\r\n                recipient: recipient,\r\n                deadline: deadline,\r\n                amountIn: state.requiredInputAmount,\r\n                amountOutMinimum: 0,\r\n                sqrtPriceLimitX96: sqrtRatioTargetX96\r\n            })\r\n        );\r\n\r\n        return state.requiredInputAmount;\r\n    }\r\n}\r\n\r\n// The code below are taken almost verbatim from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/TickBitmap.sol.\r\n// They was modified slightly to enable the them to be called on an external pool by passing in a pool address and\r\n// to accommodate solidity 0.8.\r\n\r\nlibrary TickBitmap {\r\n    function nextInitializedTickWithinOneWord(\r\n        IUniswapV3Pool pool,\r\n        int24 tick,\r\n        int24 tickSpacing,\r\n        bool lte\r\n    ) internal view returns (int24 next, bool initialized) {\r\n        int24 compressed = tick / tickSpacing;\r\n        if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\r\n\r\n        if (lte) {\r\n            (int16 wordPos, uint8 bitPos) = position(compressed);\r\n            // all the 1s at or to the right of the current bitPos\r\n            uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\r\n            uint256 masked = pool.tickBitmap(wordPos) & mask;\r\n\r\n            // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\r\n            initialized = masked != 0;\r\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\r\n            next = initialized\r\n                ? (compressed - int24(int24(uint24(bitPos)) - int24(uint24(BitMath.mostSignificantBit(masked))))) *\r\n                    tickSpacing\r\n                : (compressed - int24(uint24(bitPos))) * tickSpacing;\r\n        } else {\r\n            // start from the word of the next tick, since the current tick state doesn't matter\r\n            (int16 wordPos, uint8 bitPos) = position(compressed + 1);\r\n            // all the 1s at or to the left of the bitPos\r\n            uint256 mask = ~((1 << bitPos) - 1);\r\n            uint256 masked = pool.tickBitmap(wordPos) & mask;\r\n\r\n            // if there are no initialized ticks to the left of the current tick, return leftmost in the word\r\n            initialized = masked != 0;\r\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\r\n            next = initialized\r\n                ? (compressed + 1 + int24(BitMath.leastSignificantBit(masked) - uint24(bitPos))) * tickSpacing\r\n                : (compressed + 1 + int24(type(uint8).max - uint24(bitPos))) * tickSpacing;\r\n        }\r\n    }\r\n\r\n    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\r\n        wordPos = int16(tick >> 8);\r\n        bitPos = uint8(int8(tick % 256));\r\n    }\r\n\r\n    function flipTick(\r\n        mapping(int16 => uint256) storage self,\r\n        int24 tick,\r\n        int24 tickSpacing\r\n    ) internal {\r\n        require(tick % tickSpacing == 0); // ensure that the tick is spaced\r\n        (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\r\n        uint256 mask = 1 << bitPos;\r\n        self[wordPos] ^= mask;\r\n    }\r\n}\r\n\r\n// Taken from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/TickMath.sol and update\r\n// to work with solidity 0.8.\r\nlibrary TickMath {\r\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n    int24 internal constant MIN_TICK = -887272;\r\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n    int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\r\n\r\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n    /// @dev Throws if |tick| > max tick\r\n    /// @param tick The input tick for the above formula\r\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n    /// at the given tick\r\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\r\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\r\n        require(absTick <= uint256(int256(MAX_TICK)), \"T\");\r\n\r\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\r\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n        if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\r\n    }\r\n\r\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\r\n        // second inequality must be < because the price can never reach the price at the max tick\r\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \"R\");\r\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\r\n\r\n        uint256 r = ratio;\r\n        uint256 msb = 0;\r\n\r\n        assembly {\r\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(5, gt(r, 0xFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(4, gt(r, 0xFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(3, gt(r, 0xFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(2, gt(r, 0xF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(1, gt(r, 0x3))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := gt(r, 0x1)\r\n            msb := or(msb, f)\r\n        }\r\n\r\n        if (msb >= 128) r = ratio >> (msb - 127);\r\n        else r = ratio << (127 - msb);\r\n\r\n        int256 log_2 = (int256(msb) - 128) << 64;\r\n\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(63, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(62, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(61, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(60, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(59, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(58, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(57, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(56, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(55, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(54, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(53, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(52, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(51, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(50, f))\r\n        }\r\n\r\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\r\n\r\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\r\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\r\n\r\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\r\n    }\r\n}\r\n\r\nlibrary SqrtPriceMath {\r\n    using SafeCast for uint256;\r\n\r\n    function getAmount0Delta(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity,\r\n        bool roundUp\r\n    ) internal pure returns (uint256 amount0) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\r\n        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\r\n\r\n        require(sqrtRatioAX96 > 0);\r\n\r\n        return\r\n            roundUp\r\n                ? UnsafeMath.divRoundingUp(\r\n                    FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),\r\n                    sqrtRatioAX96\r\n                )\r\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\r\n    }\r\n\r\n    /// @notice Gets the amount1 delta between two prices\r\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\r\n    /// @param sqrtRatioAX96 A sqrt price\r\n    /// @param sqrtRatioBX96 Another sqrt price\r\n    /// @param liquidity The amount of usable liquidity\r\n    /// @param roundUp Whether to round the amount up, or down\r\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\r\n    function getAmount1Delta(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity,\r\n        bool roundUp\r\n    ) internal pure returns (uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return\r\n            roundUp\r\n                ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\r\n                : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\r\n    }\r\n\r\n    /// @notice Helper that gets signed token0 delta\r\n    /// @param sqrtRatioAX96 A sqrt price\r\n    /// @param sqrtRatioBX96 Another sqrt price\r\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\r\n    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\r\n    function getAmount0Delta(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        int128 liquidity\r\n    ) internal pure returns (int256 amount0) {\r\n        return\r\n            liquidity < 0\r\n                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\r\n                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\r\n    }\r\n\r\n    /// @notice Helper that gets signed token1 delta\r\n    /// @param sqrtRatioAX96 A sqrt price\r\n    /// @param sqrtRatioBX96 Another sqrt price\r\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\r\n    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\r\n    function getAmount1Delta(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        int128 liquidity\r\n    ) internal pure returns (int256 amount1) {\r\n        return\r\n            liquidity < 0\r\n                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\r\n                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\r\n    }\r\n}\r\n\r\nlibrary FullMath {\r\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = a * b\r\n        // Compute the product mod 2**256 and mod 2**256 - 1\r\n        // then use the Chinese Remainder Theorem to reconstruct\r\n        // the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2**256 + prod0\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(a, b, not(0))\r\n            prod0 := mul(a, b)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division\r\n        if (prod1 == 0) {\r\n            require(denominator > 0);\r\n            assembly {\r\n                result := div(prod0, denominator)\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2**256.\r\n        // Also prevents denominator == 0\r\n        require(denominator > prod1);\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0]\r\n        // Compute remainder using mulmod\r\n        uint256 remainder;\r\n        assembly {\r\n            remainder := mulmod(a, b, denominator)\r\n        }\r\n        // Subtract 256 bit number from 512 bit number\r\n        assembly {\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator\r\n        // Compute largest power of two divisor of denominator.\r\n        // Always >= 1.\r\n        // NOTE: this is modified from the original Full math implementation to work with solidity 8\r\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\r\n        // Divide denominator by power of two\r\n        assembly {\r\n            denominator := div(denominator, twos)\r\n        }\r\n\r\n        // Divide [prod1 prod0] by the factors of two\r\n        assembly {\r\n            prod0 := div(prod0, twos)\r\n        }\r\n        // Shift in bits from prod1 into prod0. For this we need\r\n        // to flip `twos` such that it is 2**256 / twos.\r\n        // If twos is zero, then it becomes one\r\n        assembly {\r\n            twos := add(div(sub(0, twos), twos), 1)\r\n        }\r\n        unchecked {\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2**256\r\n            // Now that denominator is an odd number, it has an inverse\r\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n            // Compute the inverse by starting with a seed that is correct\r\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n            uint256 inv = (3 * denominator) ^ 2;\r\n            // Now use Newton-Raphson iteration to improve the precision.\r\n            // Thanks to Hensel's lifting lemma, this also works in modular\r\n            // arithmetic, doubling the correct bits in each step.\r\n            // NOTE: this is modified from the original Full math implementation to work with solidity 8 with the unchecked syntax.\r\n            inv *= 2 - denominator * inv; // inverse mod 2**8\r\n            inv *= 2 - denominator * inv; // inverse mod 2**16\r\n            inv *= 2 - denominator * inv; // inverse mod 2**32\r\n            inv *= 2 - denominator * inv; // inverse mod 2**64\r\n            inv *= 2 - denominator * inv; // inverse mod 2**128\r\n            inv *= 2 - denominator * inv; // inverse mod 2**256\r\n            // Because the division is now exact we can divide by multiplying\r\n            // with the modular inverse of denominator. This will give us the\r\n            // correct result modulo 2**256. Since the precoditions guarantee\r\n            // that the outcome is less than 2**256, this is the final result.\r\n            // We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inv;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    function mulDivRoundingUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        result = mulDiv(a, b, denominator);\r\n        if (mulmod(a, b, denominator) > 0) {\r\n            require(result < type(uint256).max);\r\n            result++;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary FixedPoint96 {\r\n    uint8 internal constant RESOLUTION = 96;\r\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\r\n}\r\n"
    },
    "contracts/snapshot-helpers/SnapshotVotingPower.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title VotingInterface\r\n * @notice Minimum interface required to interact with VotingV2 contract.\r\n */\r\ninterface VotingInterface {\r\n    struct VoterStake {\r\n        uint128 stake;\r\n        uint128 pendingUnstake;\r\n        uint128 rewardsPaidPerToken;\r\n        uint128 outstandingRewards;\r\n        int128 unappliedSlash;\r\n        uint64 nextIndexToProcess;\r\n        uint64 unstakeTime;\r\n        address delegate;\r\n    }\r\n\r\n    function voterStakes(address) external view returns (VoterStake memory);\r\n\r\n    function getVoterFromDelegate(address) external view returns (address);\r\n}\r\n\r\n/**\r\n * @title SnapshotVotingPower\r\n * @notice Helper contract to support offchain voting with Snapshot.\r\n */\r\ncontract SnapshotVotingPower {\r\n    VotingInterface public immutable votingV2 = VotingInterface(0x004395edb43EFca9885CEdad51EC9fAf93Bd34ac);\r\n\r\n    /**\r\n     * @notice This is only used by Snapshot to calculate voting power and does not represent transferable tokens.\r\n     * @param user address of the user for whom to calculate voting power.\r\n     * @return uint256 value of user's voting power based on staked UMA at DVM2.0.\r\n     **/\r\n    function balanceOf(address user) external view returns (uint256) {\r\n        address voter = votingV2.getVoterFromDelegate(user);\r\n        VotingInterface.VoterStake memory voterStake = votingV2.voterStakes(voter);\r\n\r\n        // Avoid double counting in case of stake delegation.\r\n        if (voterStake.delegate != address(0) && user != voterStake.delegate) return 0;\r\n\r\n        return uint256(voterStake.stake);\r\n    }\r\n}\r\n"
    },
    "contracts/umip-helpers/OriginValidator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title An auxiliary contract that checks if the tx origin is the upgrader.\r\n * @dev Note: the validate function can be used as the first transaction in a governance proposals to block any other\r\n * transactions from being executed if the proposal is not initiated by the upgrader.\r\n */\r\ncontract OriginValidator {\r\n    /**\r\n     * @notice Checks if the caller is the upgrader.\r\n     * @dev This is used as the first transaction in the upgrade process to block any other transactions from being\r\n     * executed if the upgrade is not initiated by the upgrader.\r\n     */\r\n    function validate(address upgrader) public view {\r\n        require(tx.origin == upgrader);\r\n    }\r\n}\r\n"
    },
    "contracts/umip-helpers/Umip3Upgrader.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../data-verification-mechanism/implementation/Finder.sol\";\r\nimport \"../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../data-verification-mechanism/implementation/Voting.sol\";\r\n\r\n/**\r\n * @title A contract to track a whitelist of addresses.\r\n */\r\ncontract Umip3Upgrader {\r\n    // Existing governor is the only one who can initiate the upgrade.\r\n    address public existingGovernor;\r\n\r\n    // Existing Voting contract needs to be informed of the address of the new Voting contract.\r\n    Voting public existingVoting;\r\n\r\n    // New governor will be the new owner of the finder.\r\n    address public newGovernor;\r\n\r\n    // Finder contract to push upgrades to.\r\n    Finder public finder;\r\n\r\n    // Addresses to upgrade.\r\n    address public voting;\r\n    address public identifierWhitelist;\r\n    address public store;\r\n    address public financialContractsAdmin;\r\n    address public registry;\r\n\r\n    constructor(\r\n        address _existingGovernor,\r\n        address _existingVoting,\r\n        address _finder,\r\n        address _voting,\r\n        address _identifierWhitelist,\r\n        address _store,\r\n        address _financialContractsAdmin,\r\n        address _registry,\r\n        address _newGovernor\r\n    ) {\r\n        existingGovernor = _existingGovernor;\r\n        existingVoting = Voting(_existingVoting);\r\n        finder = Finder(_finder);\r\n        voting = _voting;\r\n        identifierWhitelist = _identifierWhitelist;\r\n        store = _store;\r\n        financialContractsAdmin = _financialContractsAdmin;\r\n        registry = _registry;\r\n        newGovernor = _newGovernor;\r\n    }\r\n\r\n    function upgrade() external {\r\n        require(msg.sender == existingGovernor, \"Upgrade can only be initiated by the existing governor.\");\r\n\r\n        // Change the addresses in the Finder.\r\n        finder.changeImplementationAddress(OracleInterfaces.Oracle, voting);\r\n        finder.changeImplementationAddress(OracleInterfaces.IdentifierWhitelist, identifierWhitelist);\r\n        finder.changeImplementationAddress(OracleInterfaces.Store, store);\r\n        finder.changeImplementationAddress(OracleInterfaces.FinancialContractsAdmin, financialContractsAdmin);\r\n        finder.changeImplementationAddress(OracleInterfaces.Registry, registry);\r\n\r\n        // Transfer the ownership of the Finder to the new Governor now that all the addresses have been updated.\r\n        finder.transferOwnership(newGovernor);\r\n\r\n        // Inform the existing Voting contract of the address of the new Voting contract and transfer its\r\n        // ownership to the new governor to allow for any future changes to the migrated contract.\r\n        existingVoting.setMigrated(voting);\r\n        existingVoting.transferOwnership(newGovernor);\r\n    }\r\n}\r\n"
    },
    "contracts/umip-helpers/VotingUpgrader.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../data-verification-mechanism/implementation/Finder.sol\";\r\nimport \"../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../data-verification-mechanism/implementation/Voting.sol\";\r\n\r\n/**\r\n * @title A contract that executes a short series of upgrade calls that must be performed atomically as a part of the\r\n * upgrade process for Voting.sol.\r\n * @dev Note: the complete upgrade process requires more than just the transactions in this contract. These are only\r\n * the ones that need to be performed atomically.\r\n */\r\ncontract VotingUpgrader {\r\n    // Existing governor is the only one who can initiate the upgrade.\r\n    address public governor;\r\n\r\n    // Existing Voting contract needs to be informed of the address of the new Voting contract.\r\n    Voting public existingVoting;\r\n\r\n    // New governor will be the new owner of the finder.\r\n\r\n    // Finder contract to push upgrades to.\r\n    Finder public finder;\r\n\r\n    // Addresses to upgrade.\r\n    address public newVoting;\r\n\r\n    // Address to call setMigrated on the old voting contract.\r\n    address public setMigratedAddress;\r\n\r\n    /**\r\n     * @notice Removes an address from the whitelist.\r\n     * @param _governor the Governor contract address.\r\n     * @param _existingVoting the current/existing Voting contract address.\r\n     * @param _newVoting the new Voting deployment address.\r\n     * @param _finder the Finder contract address.\r\n     * @param _setMigratedAddress the address to set migrated. This address will be able to continue making calls to\r\n     *                            old voting contract (used to claim rewards on others' behalf). Note: this address\r\n     *                            can always be changed by the voters.\r\n     */\r\n    constructor(\r\n        address _governor,\r\n        address _existingVoting,\r\n        address _newVoting,\r\n        address _finder,\r\n        address _setMigratedAddress\r\n    ) {\r\n        governor = _governor;\r\n        existingVoting = Voting(_existingVoting);\r\n        newVoting = _newVoting;\r\n        finder = Finder(_finder);\r\n        setMigratedAddress = _setMigratedAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Performs the atomic portion of the upgrade process.\r\n     * @dev This method updates the Voting address in the finder, sets the old voting contract to migrated state, and\r\n     * returns ownership of the existing Voting contract and Finder back to the Governor.\r\n     */\r\n    function upgrade() external {\r\n        require(msg.sender == governor, \"Upgrade can only be initiated by the existing governor.\");\r\n\r\n        // Change the addresses in the Finder.\r\n        finder.changeImplementationAddress(OracleInterfaces.Oracle, newVoting);\r\n\r\n        // Set the preset \"migrated\" address to allow this address to claim rewards on voters' behalf.\r\n        // This also effectively shuts down the existing voting contract so new votes cannot be triggered.\r\n        existingVoting.setMigrated(setMigratedAddress);\r\n\r\n        // Transfer back ownership of old voting contract and the finder to the governor.\r\n        existingVoting.transferOwnership(governor);\r\n        finder.transferOwnership(governor);\r\n    }\r\n}\r\n"
    },
    "contracts/umip-helpers/VotingUpgraderV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport \"../data-verification-mechanism/implementation/Finder.sol\";\r\nimport \"../data-verification-mechanism/implementation/Constants.sol\";\r\nimport \"../data-verification-mechanism/implementation/Voting.sol\";\r\n\r\nimport \"../common/implementation/MultiRole.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n// Ownable contracts to transfer ownership of\r\nstruct OwnableContracts {\r\n    Ownable identifierWhitelist;\r\n    Ownable financialContractsAdmin;\r\n    Ownable addressWhitelist;\r\n    Ownable governorRootTunnel;\r\n    Ownable arbitrumParentMessenger;\r\n    Ownable oracleHub;\r\n    Ownable governorHub;\r\n    Ownable bobaParentMessenger;\r\n    Ownable optimismParentMessenger;\r\n    Ownable optimisticOracleV3;\r\n}\r\n\r\n// Multirole contracts to transfer ownership of\r\nstruct MultiroleContracts {\r\n    MultiRole registry;\r\n    MultiRole store;\r\n}\r\n\r\n/**\r\n * @title A contract that executes a short series of upgrade calls that must be performed atomically as a part of the\r\n * upgrade process for VotingV2.sol, GovernorV2.sol and ProposerV2.sol.\r\n * @dev Note: the complete upgrade process requires more than just the transactions in this contract. These are only\r\n * the ones that need to be performed atomically.\r\n */\r\ncontract VotingUpgraderV2 {\r\n    // The only one who can initiate the upgrade.\r\n    address public immutable upgrader;\r\n\r\n    // Existing governor is the only one who can initiate the upgrade.\r\n    MultiRole public immutable existingGovernor;\r\n\r\n    // New governor contract, set to be the UMA DVM owner post upgrade.\r\n    address public immutable newGovernor;\r\n\r\n    // Existing Voting contract needs to be informed of the address of the new Voting contract.\r\n    Voting public immutable existingVoting;\r\n\r\n    // New governor will be the new owner of the finder.\r\n\r\n    // Finder contract to push upgrades to.\r\n    Finder public immutable finder;\r\n\r\n    // Address to upgrade to.\r\n    address public immutable newVoting;\r\n\r\n    // Proposer contract.\r\n    Ownable public immutable existingProposer;\r\n\r\n    // Additional ownable contracts to transfer ownership of.\r\n    OwnableContracts public ownableContracts;\r\n\r\n    // Additional multirole contracts to transfer ownership of.\r\n    MultiroleContracts public multiroleContracts;\r\n\r\n    /**\r\n     * @notice Constructs the voting upgrader to upgrade to the DVM V2. This upgrades the voting, governor and proposer\r\n     *  contracts.\r\n     * @param _existingGovernor the existing Governor contract address.\r\n     * @param _newGovernor the new Governor contract address.\r\n     * @param _existingVoting the current/existing Voting contract address.\r\n     * @param _newVoting the new Voting deployment address.\r\n     * @param _finder the Finder contract address.\r\n     * @param _ownableContracts additional ownable contracts to transfer ownership of.\r\n     * @param _multiroleContracts additional multirole contracts to transfer ownership of.\r\n     */\r\n    constructor(\r\n        address _upgrader,\r\n        address _existingGovernor,\r\n        address _newGovernor,\r\n        address _existingVoting,\r\n        address _newVoting,\r\n        address _existingProposer,\r\n        address _finder,\r\n        OwnableContracts memory _ownableContracts,\r\n        MultiroleContracts memory _multiroleContracts\r\n    ) {\r\n        upgrader = _upgrader;\r\n        existingGovernor = MultiRole(_existingGovernor);\r\n        newGovernor = _newGovernor;\r\n        existingVoting = Voting(_existingVoting);\r\n        newVoting = _newVoting;\r\n        existingProposer = Ownable(_existingProposer);\r\n        finder = Finder(_finder);\r\n        ownableContracts = _ownableContracts;\r\n        multiroleContracts = _multiroleContracts;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the caller is the upgrader.\r\n     * @dev This is used as the first transaction in the upgrade process to block any other transactions from being\r\n     * executed if the upgrade is not initiated by the upgrader.\r\n     */\r\n    function canRun() public view {\r\n        require(tx.origin == upgrader);\r\n    }\r\n\r\n    /**\r\n     * @notice Performs the atomic portion of the upgrade process.\r\n     * @dev This method updates the Voting address in the finder, sets the old voting contract to migrated state, and\r\n     * transfers the required ownership of the contracts to GovernorV2.\r\n     */\r\n    function upgrade() external {\r\n        require(msg.sender == address(existingGovernor), \"Upgrade can only be initiated by the existing governor.\");\r\n\r\n        // Change the addresses in the Finder.\r\n        finder.changeImplementationAddress(OracleInterfaces.Oracle, newVoting);\r\n\r\n        // Set the preset \"migrated\" address to allow this address to claim rewards on voters' behalf.\r\n        // This also effectively shuts down the existing voting contract so new votes cannot be triggered.\r\n        existingVoting.setMigrated(newVoting);\r\n\r\n        // Transfer back ownership of old voting contract and the finder to the governor.\r\n        existingVoting.transferOwnership(newGovernor);\r\n        finder.transferOwnership(newGovernor);\r\n\r\n        // Transfer ownership of existingProposer contract to the new governor.\r\n        existingProposer.transferOwnership(newGovernor);\r\n\r\n        // Additional ownable contracts\r\n        ownableContracts.identifierWhitelist.transferOwnership(newGovernor);\r\n        ownableContracts.financialContractsAdmin.transferOwnership(newGovernor);\r\n        ownableContracts.addressWhitelist.transferOwnership(newGovernor);\r\n        ownableContracts.governorRootTunnel.transferOwnership(newGovernor);\r\n        ownableContracts.arbitrumParentMessenger.transferOwnership(newGovernor);\r\n        ownableContracts.oracleHub.transferOwnership(newGovernor);\r\n        ownableContracts.governorHub.transferOwnership(newGovernor);\r\n        ownableContracts.bobaParentMessenger.transferOwnership(newGovernor);\r\n        ownableContracts.optimismParentMessenger.transferOwnership(newGovernor);\r\n        ownableContracts.optimisticOracleV3.transferOwnership(newGovernor);\r\n\r\n        // Set the new governor as the owner of the old governor\r\n        existingGovernor.resetMember(0, newGovernor);\r\n\r\n        // Set governor as the owner of governor\r\n        MultiRole(newGovernor).resetMember(0, newGovernor);\r\n\r\n        // Additional multirole contracts\r\n        multiroleContracts.registry.resetMember(0, newGovernor);\r\n        multiroleContracts.store.resetMember(0, newGovernor);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}