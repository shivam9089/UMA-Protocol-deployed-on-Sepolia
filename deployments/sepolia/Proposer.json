{
  "address": "0xAf2b10DF4f202E09012C171C828f72F44A70F483",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "_token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_bond",
          "type": "uint256"
        },
        {
          "internalType": "contract Governor",
          "name": "_governor",
          "type": "address"
        },
        {
          "internalType": "contract Finder",
          "name": "_finder",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_timer",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "bond",
          "type": "uint256"
        }
      ],
      "name": "BondSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "name": "ProposalResolved",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "bond",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "bondedProposals",
      "outputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "time",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "lockedBond",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "finder",
      "outputs": [
        {
          "internalType": "contract Finder",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "governor",
      "outputs": [
        {
          "internalType": "contract Governor",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Governor.Transaction[]",
          "name": "transactions",
          "type": "tuple[]"
        }
      ],
      "name": "propose",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "resolveProposal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_bond",
          "type": "uint256"
        }
      ],
      "name": "setBond",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "time",
          "type": "uint256"
        }
      ],
      "name": "setCurrentTime",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "timerAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "token",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x78d8c437f4417d177063e9af50ff1cb4002f0cc461f117d920cf10577e271fd0",
  "receipt": {
    "to": null,
    "from": "0x2d92211362AdAa7963De4609214282FFf44859F6",
    "contractAddress": "0xAf2b10DF4f202E09012C171C828f72F44A70F483",
    "transactionIndex": 88,
    "gasUsed": "1077965",
    "logsBloom": "0x00400000000000000000000080000000000000000810000000800000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000001000000080000000000000000000000000000020000000000000000000800000010000000000000000000000000400000000000000000000000000000000000000000000000000004000000000000000000000000000000000002000000000000000000000000000000000000000000200000004000000000000020000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xac949dd452e3edddc68c49010dee76d77028e07c69fe7fc2b7def8392aef0fa6",
    "transactionHash": "0x78d8c437f4417d177063e9af50ff1cb4002f0cc461f117d920cf10577e271fd0",
    "logs": [
      {
        "transactionIndex": 88,
        "blockNumber": 6161530,
        "transactionHash": "0x78d8c437f4417d177063e9af50ff1cb4002f0cc461f117d920cf10577e271fd0",
        "address": "0xAf2b10DF4f202E09012C171C828f72F44A70F483",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000002d92211362adaa7963de4609214282fff44859f6"
        ],
        "data": "0x",
        "logIndex": 126,
        "blockHash": "0xac949dd452e3edddc68c49010dee76d77028e07c69fe7fc2b7def8392aef0fa6"
      },
      {
        "transactionIndex": 88,
        "blockNumber": 6161530,
        "transactionHash": "0x78d8c437f4417d177063e9af50ff1cb4002f0cc461f117d920cf10577e271fd0",
        "address": "0xAf2b10DF4f202E09012C171C828f72F44A70F483",
        "topics": [
          "0x1b44689fb73c0c9cdf591d534287488fc7959fd3647346821063a3e567ec9a99"
        ],
        "data": "0x00000000000000000000000000000000000000000000010f0cf064dd59200000",
        "logIndex": 127,
        "blockHash": "0xac949dd452e3edddc68c49010dee76d77028e07c69fe7fc2b7def8392aef0fa6"
      },
      {
        "transactionIndex": 88,
        "blockNumber": 6161530,
        "transactionHash": "0x78d8c437f4417d177063e9af50ff1cb4002f0cc461f117d920cf10577e271fd0",
        "address": "0xAf2b10DF4f202E09012C171C828f72F44A70F483",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000002d92211362adaa7963de4609214282fff44859f6",
          "0x000000000000000000000000baf49ab29d61f6a58dfc76d249ad3c20bc8f5487"
        ],
        "data": "0x",
        "logIndex": 128,
        "blockHash": "0xac949dd452e3edddc68c49010dee76d77028e07c69fe7fc2b7def8392aef0fa6"
      }
    ],
    "blockNumber": 6161530,
    "cumulativeGasUsed": "11764827",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x473411E26885aE3A291EF4F4eB430F33946EDAD7",
    "5000000000000000000000",
    "0xBaF49aB29D61F6A58dfC76D249aD3c20bc8F5487",
    "0xA969917A4dFaB07936dEc60f70FA5c736A1e2b9e",
    "0xf8815ce169E5450aa6908e76E1B970dBcEC11550"
  ],
  "solcInputHash": "864d61c65c789401ae17358a5af86557",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bond\",\"type\":\"uint256\"},{\"internalType\":\"contract Governor\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"contract Finder\",\"name\":\"_finder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"}],\"name\":\"BondSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"ProposalResolved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bondedProposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"lockedBond\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finder\",\"outputs\":[{\"internalType\":\"contract Finder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"contract Governor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Governor.Transaction[]\",\"name\":\"transactions\",\"type\":\"tuple[]\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"resolveProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bond\",\"type\":\"uint256\"}],\"name\":\"setBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setCurrentTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_bond\":\"the bond amount.\",\"_finder\":\"the finder contract used to look up addresses.\",\"_governor\":\"the governor contract that this contract makes proposals to.\",\"_timer\":\"the timer contract to control the output of getCurrentTime(). Set to 0x0 if in production.\",\"_token\":\"the ERC20 token that the bond is paid in.\"}},\"getCurrentTime()\":{\"returns\":{\"_0\":\"uint for the current Testable timestamp.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"propose((address,uint256,bytes)[])\":{\"details\":\"Pulls bond from the caller.\",\"params\":{\"transactions\":\"list of transactions for the governor to execute.\"},\"returns\":{\"id\":\"the id of the governor proposal.\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"resolveProposal(uint256)\":{\"details\":\"For the resolution to work correctly, this contract must be a registered contract in the DVM.\",\"params\":{\"id\":\"proposal id.\"}},\"setBond(uint256)\":{\"details\":\"Admin is intended to be the governance system, itself.\",\"params\":{\"_bond\":\"the new bond.\"}},\"setCurrentTime(uint256)\":{\"details\":\"Will revert if not running in test mode.\",\"params\":{\"time\":\"timestamp to set current Testable time to.\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"Proposer contract that allows anyone to make governance proposals with a bond.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Construct the Proposer contract.\"},\"getCurrentTime()\":{\"notice\":\"Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. Otherwise, it will return the block timestamp.\"},\"propose((address,uint256,bytes)[])\":{\"notice\":\"Propose a new set of governance transactions for vote.\"},\"resolveProposal(uint256)\":{\"notice\":\"Resolves a proposal by checking the status of the request in the Voting contract.\"},\"setBond(uint256)\":{\"notice\":\"Admin method to set the bond amount.\"},\"setCurrentTime(uint256)\":{\"notice\":\"Sets the current time.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/data-verification-mechanism/implementation/Proposer.sol\":\"Proposer\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\",\"keccak256\":\"0xa56ca923f70c1748830700250b19c61b70db9a683516dc5e216694a50445d99c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Snapshot.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Arrays.sol\\\";\\nimport \\\"../../../utils/Counters.sol\\\";\\n\\n/**\\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\\n * total supply at the time are recorded for later access.\\n *\\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\\n * In naive implementations it's possible to perform a \\\"double spend\\\" attack by reusing the same balance from different\\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\\n * used to create an efficient ERC20 forking mechanism.\\n *\\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\\n * and the account address.\\n *\\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\\n *\\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\\n * alternative consider {ERC20Votes}.\\n *\\n * ==== Gas Costs\\n *\\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\\n *\\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\\n * transfers will have normal cost until the next snapshot, and so on.\\n */\\n\\nabstract contract ERC20Snapshot is ERC20 {\\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\\n    // https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\\n\\n    using Arrays for uint256[];\\n    using Counters for Counters.Counter;\\n\\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\\n    // Snapshot struct, but that would impede usage of functions that work on an array.\\n    struct Snapshots {\\n        uint256[] ids;\\n        uint256[] values;\\n    }\\n\\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\\n    Snapshots private _totalSupplySnapshots;\\n\\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\\n    Counters.Counter private _currentSnapshotId;\\n\\n    /**\\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\\n     */\\n    event Snapshot(uint256 id);\\n\\n    /**\\n     * @dev Creates a new snapshot and returns its snapshot id.\\n     *\\n     * Emits a {Snapshot} event that contains the same id.\\n     *\\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\\n     *\\n     * [WARNING]\\n     * ====\\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\\n     * you must consider that it can potentially be used by attackers in two ways.\\n     *\\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\\n     * section above.\\n     *\\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\\n     * ====\\n     */\\n    function _snapshot() internal virtual returns (uint256) {\\n        _currentSnapshotId.increment();\\n\\n        uint256 currentId = _getCurrentSnapshotId();\\n        emit Snapshot(currentId);\\n        return currentId;\\n    }\\n\\n    /**\\n     * @dev Get the current snapshotId\\n     */\\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\\n        return _currentSnapshotId.current();\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\\n     */\\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\\n\\n        return snapshotted ? value : balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\\n     */\\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\\n\\n        return snapshotted ? value : totalSupply();\\n    }\\n\\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (from == address(0)) {\\n            // mint\\n            _updateAccountSnapshot(to);\\n            _updateTotalSupplySnapshot();\\n        } else if (to == address(0)) {\\n            // burn\\n            _updateAccountSnapshot(from);\\n            _updateTotalSupplySnapshot();\\n        } else {\\n            // transfer\\n            _updateAccountSnapshot(from);\\n            _updateAccountSnapshot(to);\\n        }\\n    }\\n\\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\\n        require(snapshotId > 0, \\\"ERC20Snapshot: id is 0\\\");\\n        require(snapshotId <= _getCurrentSnapshotId(), \\\"ERC20Snapshot: nonexistent id\\\");\\n\\n        // When a valid snapshot is queried, there are three possibilities:\\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\\n        //  to this id is the current one.\\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\\n        //  requested id, and its value is the one to return.\\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\\n        //  larger than the requested one.\\n        //\\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\\n        // exactly this.\\n\\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\\n\\n        if (index == snapshots.ids.length) {\\n            return (false, 0);\\n        } else {\\n            return (true, snapshots.values[index]);\\n        }\\n    }\\n\\n    function _updateAccountSnapshot(address account) private {\\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\\n    }\\n\\n    function _updateTotalSupplySnapshot() private {\\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\\n    }\\n\\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\\n        uint256 currentId = _getCurrentSnapshotId();\\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\\n            snapshots.ids.push(currentId);\\n            snapshots.values.push(currentValue);\\n        }\\n    }\\n\\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\\n        if (ids.length == 0) {\\n            return 0;\\n        } else {\\n            return ids[ids.length - 1];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb3718ef8e5a9d4b3a165319d86e75c4c197a5433dfd7c308393e659e8590c56d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xb264c03a3442eb37a68ad620cefd1182766b58bee6cec40343480392d6b14d69\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Arrays.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./StorageSlot.sol\\\";\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n    using StorageSlot for bytes32;\\n\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\\n        bytes32 slot;\\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getAddressSlot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\\n        bytes32 slot;\\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getBytes32Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\\n        bytes32 slot;\\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\\n        // following https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getUint256Slot();\\n    }\\n}\\n\",\"keccak256\":\"0x104a08fc99d01f2229044fe3db7b3e0375b5d93cd7203f11db6ecdc9c8c8b0b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xa92e4fa126feb6907daa0513ddd816b2eb91f30a808de54f63c17d0e162c3439\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf0018c2440fbe238dd3a8732fa8e17a0f9dce84d31451dc8a32f6d62b349c9f1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf09e68aa0dc6722a25bc46490e8d48ed864466d17313b8a0b254c36b54e49899\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x58b21219689909c4f8339af00813760337f7e2e7f169a97fe49e2896dcfb3b9a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SignedSafeMath {\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        return a + b;\\n    }\\n}\\n\",\"keccak256\":\"0x62f53f262fabbbc6d8ab49488d8fce36370351aff2b8d3898d499d68995a71c2\",\"license\":\"MIT\"},\"contracts/common/implementation/ExpandedERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"./MultiRole.sol\\\";\\r\\nimport \\\"../interfaces/ExpandedIERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title An ERC20 with permissioned burning and minting. The contract deployer will initially\\r\\n * be the owner who is capable of adding new roles.\\r\\n */\\r\\ncontract ExpandedERC20 is ExpandedIERC20, ERC20, MultiRole {\\r\\n    enum Roles {\\r\\n        // Can set the minter and burner.\\r\\n        Owner,\\r\\n        // Addresses that can mint new tokens.\\r\\n        Minter,\\r\\n        // Addresses that can burn tokens that address owns.\\r\\n        Burner\\r\\n    }\\r\\n\\r\\n    uint8 _decimals;\\r\\n\\r\\n    /**\\r\\n     * @notice Constructs the ExpandedERC20.\\r\\n     * @param _tokenName The name which describes the new token.\\r\\n     * @param _tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.\\r\\n     * @param _tokenDecimals The number of decimals to define token precision.\\r\\n     */\\r\\n    constructor(\\r\\n        string memory _tokenName,\\r\\n        string memory _tokenSymbol,\\r\\n        uint8 _tokenDecimals\\r\\n    ) ERC20(_tokenName, _tokenSymbol) {\\r\\n        _decimals = _tokenDecimals;\\r\\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\\r\\n        _createSharedRole(uint256(Roles.Minter), uint256(Roles.Owner), new address[](0));\\r\\n        _createSharedRole(uint256(Roles.Burner), uint256(Roles.Owner), new address[](0));\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual override(ERC20) returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints `value` tokens to `recipient`, returning true on success.\\r\\n     * @param recipient address to mint to.\\r\\n     * @param value amount of tokens to mint.\\r\\n     * @return True if the mint succeeded, or False.\\r\\n     */\\r\\n    function mint(address recipient, uint256 value)\\r\\n        external\\r\\n        override\\r\\n        onlyRoleHolder(uint256(Roles.Minter))\\r\\n        returns (bool)\\r\\n    {\\r\\n        _mint(recipient, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Burns `value` tokens owned by `msg.sender`.\\r\\n     * @param value amount of tokens to burn.\\r\\n     */\\r\\n    function burn(uint256 value) external override onlyRoleHolder(uint256(Roles.Burner)) {\\r\\n        _burn(msg.sender, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Burns `value` tokens owned by `recipient`.\\r\\n     * @param recipient address to burn tokens from.\\r\\n     * @param value amount of tokens to burn.\\r\\n     * @return True if the burn succeeded, or False.\\r\\n     */\\r\\n    function burnFrom(address recipient, uint256 value)\\r\\n        external\\r\\n        override\\r\\n        onlyRoleHolder(uint256(Roles.Burner))\\r\\n        returns (bool)\\r\\n    {\\r\\n        _burn(recipient, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add Minter role to account.\\r\\n     * @dev The caller must have the Owner role.\\r\\n     * @param account The address to which the Minter role is added.\\r\\n     */\\r\\n    function addMinter(address account) external virtual override {\\r\\n        addMember(uint256(Roles.Minter), account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add Burner role to account.\\r\\n     * @dev The caller must have the Owner role.\\r\\n     * @param account The address to which the Burner role is added.\\r\\n     */\\r\\n    function addBurner(address account) external virtual override {\\r\\n        addMember(uint256(Roles.Burner), account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reset Owner role to account.\\r\\n     * @dev The caller must have the Owner role.\\r\\n     * @param account The new holder of the Owner role.\\r\\n     */\\r\\n    function resetOwner(address account) external virtual override {\\r\\n        resetMember(uint256(Roles.Owner), account);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xd5ad65b24455d06323ae045e0998a08a36d52bc12644cf667ad3a0e8d92ef734\",\"license\":\"AGPL-3.0-only\"},\"contracts/common/implementation/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Library for fixed point arithmetic on uints\\r\\n */\\r\\nlibrary FixedPoint {\\r\\n    using SafeMath for uint256;\\r\\n    using SignedSafeMath for int256;\\r\\n\\r\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\r\\n    // For unsigned values:\\r\\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\\r\\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\\r\\n\\r\\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\\r\\n    struct Unsigned {\\r\\n        uint256 rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\\r\\n     * @param a uint to convert into a FixedPoint.\\r\\n     * @return the converted FixedPoint.\\r\\n     */\\r\\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue == fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue == b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue > fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue < fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The minimum of `a` and `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the minimum of `a` and `b`.\\r\\n     */\\r\\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return a.rawValue < b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The maximum of `a` and `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the maximum of `a` and `b`.\\r\\n     */\\r\\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return a.rawValue > b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds two `Unsigned`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.add(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return add(a, fromUnscaledUint(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.sub(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return sub(a, fromUnscaledUint(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return sub(fromUnscaledUint(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\r\\n        // stored internally as a uint256 ~10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\r\\n        // would round to 3, but this computation produces the result 2.\\r\\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\\r\\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Unsigned`s and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\\r\\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\r\\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\r\\n        if (mod != 0) {\\r\\n            return Unsigned(mulFloor.add(1));\\r\\n        } else {\\r\\n            return Unsigned(mulFloor);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        // Since b is an uint, there is no risk of truncation and we can just mul it normally\\r\\n        return Unsigned(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\r\\n        // 10^41 is stored internally as a uint256 10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\r\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\r\\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a uint256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.div(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a uint256 numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return div(fromUnscaledUint(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an `Unsigned` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\r\\n        uint256 divFloor = aScaled.div(b.rawValue);\\r\\n        uint256 mod = aScaled.mod(b.rawValue);\\r\\n        if (mod != 0) {\\r\\n            return Unsigned(divFloor.add(1));\\r\\n        } else {\\r\\n            return Unsigned(divFloor);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a uint256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Unsigned(a.rawValue.div(b))\\\"\\r\\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\\r\\n        // This creates the possibility of overflow if b is very large.\\r\\n        return divCeil(a, fromUnscaledUint(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\r\\n     * @dev This will \\\"floor\\\" the result.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a uint256 denominator.\\r\\n     * @return output is `a` to the power of `b`.\\r\\n     */\\r\\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\\r\\n        output = fromUnscaledUint(1);\\r\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\r\\n            output = mul(output, a);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\\r\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\r\\n    // For signed values:\\r\\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\\r\\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\\r\\n\\r\\n    struct Signed {\\r\\n        int256 rawValue;\\r\\n    }\\r\\n\\r\\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\r\\n        require(a.rawValue >= 0, \\\"Negative value provided\\\");\\r\\n        return Unsigned(uint256(a.rawValue));\\r\\n    }\\r\\n\\r\\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\\r\\n        require(a.rawValue <= uint256(type(int256).max), \\\"Unsigned too large\\\");\\r\\n        return Signed(int256(a.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\\r\\n     * @param a int to convert into a FixedPoint.Signed.\\r\\n     * @return the converted FixedPoint.Signed.\\r\\n     */\\r\\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\r\\n        return Signed(a.mul(SFP_SCALING_FACTOR));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a int256.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue == fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue == b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue > fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue < fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The minimum of `a` and `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the minimum of `a` and `b`.\\r\\n     */\\r\\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return a.rawValue < b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The maximum of `a` and `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the maximum of `a` and `b`.\\r\\n     */\\r\\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return a.rawValue > b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds two `Signed`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.add(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return add(a, fromUnscaledInt(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts two `Signed`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.sub(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return sub(a, fromUnscaledInt(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return sub(fromUnscaledInt(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Signed`s, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\r\\n        // stored internally as an int256 ~10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\r\\n        // would round to 3, but this computation produces the result 2.\\r\\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\\r\\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Signed`s and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\\r\\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\r\\n        // Manual mod because SignedSafeMath doesn't support it.\\r\\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\\r\\n        if (mod != 0) {\\r\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\r\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\r\\n            return Signed(mulTowardsZero.add(valueToAdd));\\r\\n        } else {\\r\\n            return Signed(mulTowardsZero);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Signed` and an unscaled int256 and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\\r\\n        return Signed(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\r\\n        // 10^41 is stored internally as an int256 10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\r\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\r\\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b an int256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.div(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a an int256 numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return div(fromUnscaledInt(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an `Signed` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\r\\n        int256 divTowardsZero = aScaled.div(b.rawValue);\\r\\n        // Manual mod because SignedSafeMath doesn't support it.\\r\\n        int256 mod = aScaled % b.rawValue;\\r\\n        if (mod != 0) {\\r\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\r\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\r\\n            return Signed(divTowardsZero.add(valueToAdd));\\r\\n        } else {\\r\\n            return Signed(divTowardsZero);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an unscaled int256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b an int256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Signed(a.rawValue.div(b))\\\"\\r\\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\\r\\n        // This creates the possibility of overflow if b is very large.\\r\\n        return divAwayFromZero(a, fromUnscaledInt(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\r\\n     * @dev This will \\\"floor\\\" the result.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a uint256 (negative exponents are not allowed).\\r\\n     * @return output is `a` to the power of `b`.\\r\\n     */\\r\\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\\r\\n        output = fromUnscaledInt(1);\\r\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\r\\n            output = mul(output, a);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xd32e845210e20d367e4deaffbfd6115876e9bbd934ea073a1802f8bcb9c2b166\",\"license\":\"AGPL-3.0-only\"},\"contracts/common/implementation/Lockable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\\r\\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\\r\\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\\r\\n */\\r\\ncontract Lockable {\\r\\n    bool private _notEntered;\\r\\n\\r\\n    constructor() {\\r\\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\\r\\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\\r\\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\\r\\n        // refund coming into effect.\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\\r\\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\\r\\n     * function that does the actual state modification.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _preEntranceCheck();\\r\\n        _preEntranceSet();\\r\\n        _;\\r\\n        _postEntranceReset();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\\r\\n     */\\r\\n    modifier nonReentrantView() {\\r\\n        _preEntranceCheck();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\\r\\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\\r\\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\\r\\n    // then call `_postEntranceReset()`.\\r\\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\\r\\n    function _preEntranceCheck() internal view {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n    }\\r\\n\\r\\n    function _preEntranceSet() internal {\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _notEntered = false;\\r\\n    }\\r\\n\\r\\n    function _postEntranceReset() internal {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    // These functions are intended to be used by child contracts to temporarily disable and re-enable the guard.\\r\\n    // Intended use:\\r\\n    // _startReentrantGuardDisabled();\\r\\n    // ...\\r\\n    // _endReentrantGuardDisabled();\\r\\n    //\\r\\n    // IMPORTANT: these should NEVER be used in a method that isn't inside a nonReentrant block. Otherwise, it's\\r\\n    // possible to permanently lock your contract.\\r\\n    function _startReentrantGuardDisabled() internal {\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    function _endReentrantGuardDisabled() internal {\\r\\n        _notEntered = false;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x0d2de08951d2be32ceb242649e4b248508f43ce9184ee9ac69eedcef9f6afd8b\",\"license\":\"AGPL-3.0-only\"},\"contracts/common/implementation/MultiRole.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Exclusive {\\r\\n    struct RoleMembership {\\r\\n        address member;\\r\\n    }\\r\\n\\r\\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\\r\\n        return roleMembership.member == memberToCheck;\\r\\n    }\\r\\n\\r\\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\\r\\n        require(newMember != address(0x0), \\\"Cannot set an exclusive role to 0x0\\\");\\r\\n        roleMembership.member = newMember;\\r\\n    }\\r\\n\\r\\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\\r\\n        return roleMembership.member;\\r\\n    }\\r\\n\\r\\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\\r\\n        resetMember(roleMembership, initialMember);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Shared {\\r\\n    struct RoleMembership {\\r\\n        mapping(address => bool) members;\\r\\n    }\\r\\n\\r\\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\\r\\n        return roleMembership.members[memberToCheck];\\r\\n    }\\r\\n\\r\\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\\r\\n        require(memberToAdd != address(0x0), \\\"Cannot add 0x0 to a shared role\\\");\\r\\n        roleMembership.members[memberToAdd] = true;\\r\\n    }\\r\\n\\r\\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\\r\\n        roleMembership.members[memberToRemove] = false;\\r\\n    }\\r\\n\\r\\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\\r\\n        for (uint256 i = 0; i < initialMembers.length; i++) {\\r\\n            addMember(roleMembership, initialMembers[i]);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Base class to manage permissions for the derived class.\\r\\n */\\r\\nabstract contract MultiRole {\\r\\n    using Exclusive for Exclusive.RoleMembership;\\r\\n    using Shared for Shared.RoleMembership;\\r\\n\\r\\n    enum RoleType { Invalid, Exclusive, Shared }\\r\\n\\r\\n    struct Role {\\r\\n        uint256 managingRole;\\r\\n        RoleType roleType;\\r\\n        Exclusive.RoleMembership exclusiveRoleMembership;\\r\\n        Shared.RoleMembership sharedRoleMembership;\\r\\n    }\\r\\n\\r\\n    mapping(uint256 => Role) private roles;\\r\\n\\r\\n    event ResetExclusiveMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\\r\\n    event AddedSharedMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\\r\\n    event RemovedSharedMember(uint256 indexed roleId, address indexed oldMember, address indexed manager);\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts unless the caller is a member of the specified roleId.\\r\\n     */\\r\\n    modifier onlyRoleHolder(uint256 roleId) {\\r\\n        require(holdsRole(roleId, msg.sender), \\\"Sender does not hold required role\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\\r\\n     */\\r\\n    modifier onlyRoleManager(uint256 roleId) {\\r\\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \\\"Can only be called by a role manager\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\\r\\n     */\\r\\n    modifier onlyExclusive(uint256 roleId) {\\r\\n        require(roles[roleId].roleType == RoleType.Exclusive, \\\"Must be called on an initialized Exclusive role\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\\r\\n     */\\r\\n    modifier onlyShared(uint256 roleId) {\\r\\n        require(roles[roleId].roleType == RoleType.Shared, \\\"Must be called on an initialized Shared role\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `memberToCheck` is a member of roleId.\\r\\n     * @dev Reverts if roleId does not correspond to an initialized role.\\r\\n     * @param roleId the Role to check.\\r\\n     * @param memberToCheck the address to check.\\r\\n     * @return True if `memberToCheck` is a member of `roleId`.\\r\\n     */\\r\\n    function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\\r\\n        Role storage role = roles[roleId];\\r\\n        if (role.roleType == RoleType.Exclusive) {\\r\\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\\r\\n        } else if (role.roleType == RoleType.Shared) {\\r\\n            return role.sharedRoleMembership.isMember(memberToCheck);\\r\\n        }\\r\\n        revert(\\\"Invalid roleId\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\\r\\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\\r\\n     * initialized, ExclusiveRole.\\r\\n     * @param roleId the ExclusiveRole membership to modify.\\r\\n     * @param newMember the new ExclusiveRole member.\\r\\n     */\\r\\n    function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\\r\\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\\r\\n        emit ResetExclusiveMember(roleId, newMember, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the current holder of the exclusive role, `roleId`.\\r\\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\\r\\n     * @param roleId the ExclusiveRole membership to check.\\r\\n     * @return the address of the current ExclusiveRole member.\\r\\n     */\\r\\n    function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\\r\\n        return roles[roleId].exclusiveRoleMembership.getMember();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds `newMember` to the shared role, `roleId`.\\r\\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\\r\\n     * managing role for `roleId`.\\r\\n     * @param roleId the SharedRole membership to modify.\\r\\n     * @param newMember the new SharedRole member.\\r\\n     */\\r\\n    function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\\r\\n        roles[roleId].sharedRoleMembership.addMember(newMember);\\r\\n        emit AddedSharedMember(roleId, newMember, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\\r\\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\\r\\n     * managing role for `roleId`.\\r\\n     * @param roleId the SharedRole membership to modify.\\r\\n     * @param memberToRemove the current SharedRole member to remove.\\r\\n     */\\r\\n    function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\\r\\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\\r\\n        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Removes caller from the role, `roleId`.\\r\\n     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\\r\\n     * initialized, SharedRole.\\r\\n     * @param roleId the SharedRole membership to modify.\\r\\n     */\\r\\n    function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\\r\\n        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\\r\\n        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts if `roleId` is not initialized.\\r\\n     */\\r\\n    modifier onlyValidRole(uint256 roleId) {\\r\\n        require(roles[roleId].roleType != RoleType.Invalid, \\\"Attempted to use an invalid roleId\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts if `roleId` is initialized.\\r\\n     */\\r\\n    modifier onlyInvalidRole(uint256 roleId) {\\r\\n        require(roles[roleId].roleType == RoleType.Invalid, \\\"Cannot use a pre-existing role\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\\r\\n     * `initialMembers` will be immediately added to the role.\\r\\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\\r\\n     * initialized.\\r\\n     */\\r\\n    function _createSharedRole(\\r\\n        uint256 roleId,\\r\\n        uint256 managingRoleId,\\r\\n        address[] memory initialMembers\\r\\n    ) internal onlyInvalidRole(roleId) {\\r\\n        Role storage role = roles[roleId];\\r\\n        role.roleType = RoleType.Shared;\\r\\n        role.managingRole = managingRoleId;\\r\\n        role.sharedRoleMembership.init(initialMembers);\\r\\n        require(\\r\\n            roles[managingRoleId].roleType != RoleType.Invalid,\\r\\n            \\\"Attempted to use an invalid role to manage a shared role\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal method to initialize an exclusive role, `roleId`, which will be managed by `managingRoleId`.\\r\\n     * `initialMember` will be immediately added to the role.\\r\\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\\r\\n     * initialized.\\r\\n     */\\r\\n    function _createExclusiveRole(\\r\\n        uint256 roleId,\\r\\n        uint256 managingRoleId,\\r\\n        address initialMember\\r\\n    ) internal onlyInvalidRole(roleId) {\\r\\n        Role storage role = roles[roleId];\\r\\n        role.roleType = RoleType.Exclusive;\\r\\n        role.managingRole = managingRoleId;\\r\\n        role.exclusiveRoleMembership.init(initialMember);\\r\\n        require(\\r\\n            roles[managingRoleId].roleType != RoleType.Invalid,\\r\\n            \\\"Attempted to use an invalid role to manage an exclusive role\\\"\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xbec581749786ec3a2b56d74331914d03fd7a0bf0e853c6f8a3e778b39417606a\",\"license\":\"AGPL-3.0-only\"},\"contracts/common/implementation/Testable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Timer.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Base class that provides time overrides, but only if being run in test mode.\\r\\n */\\r\\nabstract contract Testable {\\r\\n    // If the contract is being run in production, then `timerAddress` will be the 0x0 address.\\r\\n    // Note: this variable should be set on construction and never modified.\\r\\n    address public timerAddress;\\r\\n\\r\\n    /**\\r\\n     * @notice Constructs the Testable contract. Called by child contracts.\\r\\n     * @param _timerAddress Contract that stores the current time in a testing environment.\\r\\n     * Must be set to 0x0 for production environments that use live time.\\r\\n     */\\r\\n    constructor(address _timerAddress) {\\r\\n        timerAddress = _timerAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts if not running in test mode.\\r\\n     */\\r\\n    modifier onlyIfTest {\\r\\n        require(timerAddress != address(0x0));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the current time.\\r\\n     * @dev Will revert if not running in test mode.\\r\\n     * @param time timestamp to set current Testable time to.\\r\\n     */\\r\\n    function setCurrentTime(uint256 time) external onlyIfTest {\\r\\n        Timer(timerAddress).setCurrentTime(time);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\\r\\n     * Otherwise, it will return the block timestamp.\\r\\n     * @return uint for the current Testable timestamp.\\r\\n     */\\r\\n    function getCurrentTime() public view virtual returns (uint256) {\\r\\n        if (timerAddress != address(0x0)) {\\r\\n            return Timer(timerAddress).getCurrentTime();\\r\\n        } else {\\r\\n            return block.timestamp; // solhint-disable-line not-rely-on-time\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xcd0943490d2b65b1f76a2532924dc8e28c1e29c7e788e825944a234fbadb511c\",\"license\":\"AGPL-3.0-only\"},\"contracts/common/implementation/Timer.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Universal store of current contract time for testing environments.\\r\\n */\\r\\ncontract Timer {\\r\\n    uint256 private currentTime;\\r\\n\\r\\n    constructor() {\\r\\n        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the current time.\\r\\n     * @dev Will revert if not running in test mode.\\r\\n     * @param time timestamp to set `currentTime` to.\\r\\n     */\\r\\n    function setCurrentTime(uint256 time) external {\\r\\n        currentTime = time;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the currentTime variable set in the Timer.\\r\\n     * @return uint256 for the current Testable timestamp.\\r\\n     */\\r\\n    function getCurrentTime() public view returns (uint256) {\\r\\n        return currentTime;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x4e0d9be5ba1850756eb638cff475080811dd1ca14ba9c99c8b8056f2ad75984f\",\"license\":\"AGPL-3.0-only\"},\"contracts/common/interfaces/ExpandedIERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC20 interface that includes burn and mint methods.\\r\\n */\\r\\nabstract contract ExpandedIERC20 is IERC20 {\\r\\n    /**\\r\\n     * @notice Burns a specific amount of the caller's tokens.\\r\\n     * @dev Only burns the caller's tokens, so it is safe to leave this method permissionless.\\r\\n     */\\r\\n    function burn(uint256 value) external virtual;\\r\\n\\r\\n    /**\\r\\n     * @dev Burns `value` tokens owned by `recipient`.\\r\\n     * @param recipient address to burn tokens from.\\r\\n     * @param value amount of tokens to burn.\\r\\n     */\\r\\n    function burnFrom(address recipient, uint256 value) external virtual returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Mints tokens and adds them to the balance of the `to` address.\\r\\n     * @dev This method should be permissioned to only allow designated parties to mint tokens.\\r\\n     */\\r\\n    function mint(address to, uint256 value) external virtual returns (bool);\\r\\n\\r\\n    function addMinter(address account) external virtual;\\r\\n\\r\\n    function addBurner(address account) external virtual;\\r\\n\\r\\n    function resetOwner(address account) external virtual;\\r\\n}\\r\\n\",\"keccak256\":\"0xb3e81268dc3417f29f6047fab4fa03d5b1fc23f280485ba81b90769c971293fc\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/implementation/AdminIdentifierLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity 0.8.16;\\r\\n\\r\\n/**\\r\\n * @title Library to construct admin identifiers.\\r\\n */\\r\\nlibrary AdminIdentifierLib {\\r\\n    // Returns a UTF-8 identifier representing a particular admin proposal.\\r\\n    // The identifier is of the form \\\"Admin n\\\", where n is the proposal id provided.\\r\\n    function _constructIdentifier(uint256 id) internal pure returns (bytes32) {\\r\\n        bytes32 bytesId = _uintToUtf8(id);\\r\\n        return _addPrefix(bytesId, \\\"Admin \\\", 6);\\r\\n    }\\r\\n\\r\\n    // This method converts the integer `v` into a base-10, UTF-8 representation stored in a `bytes32` type.\\r\\n    // If the input cannot be represented by 32 base-10 digits, it returns only the highest 32 digits.\\r\\n    // This method is based off of this code: https://ethereum.stackexchange.com/a/6613/47801.\\r\\n    function _uintToUtf8(uint256 v) internal pure returns (bytes32) {\\r\\n        bytes32 ret;\\r\\n        if (v == 0) {\\r\\n            // Handle 0 case explicitly.\\r\\n            ret = \\\"0\\\";\\r\\n        } else {\\r\\n            // Constants.\\r\\n            uint256 bitsPerByte = 8;\\r\\n            uint256 base = 10; // Note: the output should be base-10. The below implementation will not work for bases > 10.\\r\\n            uint256 utf8NumberOffset = 48;\\r\\n            while (v > 0) {\\r\\n                // Downshift the entire bytes32 to allow the new digit to be added at the \\\"front\\\" of the bytes32, which\\r\\n                // translates to the beginning of the UTF-8 representation.\\r\\n                ret = ret >> bitsPerByte;\\r\\n\\r\\n                // Separate the last digit that remains in v by modding by the base of desired output representation.\\r\\n                uint256 leastSignificantDigit = v % base;\\r\\n\\r\\n                // Digits 0-9 are represented by 48-57 in UTF-8, so an offset must be added to create the character.\\r\\n                bytes32 utf8Digit = bytes32(leastSignificantDigit + utf8NumberOffset);\\r\\n\\r\\n                // The top byte of ret has already been cleared to make room for the new digit.\\r\\n                // Upshift by 31 bytes to put it in position, and OR it with ret to leave the other characters untouched.\\r\\n                ret |= utf8Digit << (31 * bitsPerByte);\\r\\n\\r\\n                // Divide v by the base to remove the digit that was just added.\\r\\n                v /= base;\\r\\n            }\\r\\n        }\\r\\n        return ret;\\r\\n    }\\r\\n\\r\\n    // This method takes two UTF-8 strings represented as bytes32 and outputs one as a prefixed by the other.\\r\\n    // `input` is the UTF-8 that should have the prefix prepended.\\r\\n    // `prefix` is the UTF-8 that should be prepended onto input.\\r\\n    // `prefixLength` is number of UTF-8 characters represented by `prefix`.\\r\\n    // Notes:\\r\\n    // 1. If the resulting UTF-8 is larger than 32 characters, then only the first 32 characters will be represented\\r\\n    //    by the bytes32 output.\\r\\n    // 2. If `prefix` has more characters than `prefixLength`, the function will produce an invalid result.\\r\\n    function _addPrefix(\\r\\n        bytes32 input,\\r\\n        bytes32 prefix,\\r\\n        uint256 prefixLength\\r\\n    ) internal pure returns (bytes32) {\\r\\n        // Downshift `input` to open space at the \\\"front\\\" of the bytes32\\r\\n        bytes32 shiftedInput = input >> (prefixLength * 8);\\r\\n        return shiftedInput | prefix;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xa5dab9093cc4ffca70452f79f867fa9b29110210508f81a2ebcb872952009b59\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/implementation/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Stores common interface names used throughout the DVM by registration in the Finder.\\r\\n */\\r\\nlibrary OracleInterfaces {\\r\\n    bytes32 public constant Oracle = \\\"Oracle\\\";\\r\\n    bytes32 public constant IdentifierWhitelist = \\\"IdentifierWhitelist\\\";\\r\\n    bytes32 public constant Store = \\\"Store\\\";\\r\\n    bytes32 public constant FinancialContractsAdmin = \\\"FinancialContractsAdmin\\\";\\r\\n    bytes32 public constant Registry = \\\"Registry\\\";\\r\\n    bytes32 public constant CollateralWhitelist = \\\"CollateralWhitelist\\\";\\r\\n    bytes32 public constant OptimisticOracle = \\\"OptimisticOracle\\\";\\r\\n    bytes32 public constant OptimisticOracleV2 = \\\"OptimisticOracleV2\\\";\\r\\n    bytes32 public constant OptimisticOracleV3 = \\\"OptimisticOracleV3\\\";\\r\\n    bytes32 public constant Bridge = \\\"Bridge\\\";\\r\\n    bytes32 public constant GenericHandler = \\\"GenericHandler\\\";\\r\\n    bytes32 public constant SkinnyOptimisticOracle = \\\"SkinnyOptimisticOracle\\\";\\r\\n    bytes32 public constant ChildMessenger = \\\"ChildMessenger\\\";\\r\\n    bytes32 public constant OracleHub = \\\"OracleHub\\\";\\r\\n    bytes32 public constant OracleSpoke = \\\"OracleSpoke\\\";\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Commonly re-used values for contracts associated with the OptimisticOracle.\\r\\n */\\r\\nlibrary OptimisticOracleConstraints {\\r\\n    // Any price request submitted to the OptimisticOracle must contain ancillary data no larger than this value.\\r\\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` constant value otherwise it is possible\\r\\n    // that a price can be requested to the OptimisticOracle successfully, but cannot be resolved by the DVM which\\r\\n    // refuses to accept a price request made with ancillary data length over a certain size.\\r\\n    uint256 public constant ancillaryBytesLimit = 8192;\\r\\n}\\r\\n\",\"keccak256\":\"0xc91adf0214524d001e7d5eadc61c8e8406a62c97362e9c72fff121ff68676c00\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/implementation/Finder.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"../interfaces/FinderInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Provides addresses of the live contracts implementing certain interfaces.\\r\\n * @dev Examples of interfaces with implementations that Finder locates are the Oracle and Store interfaces.\\r\\n */\\r\\ncontract Finder is FinderInterface, Ownable {\\r\\n    mapping(bytes32 => address) public interfacesImplemented;\\r\\n\\r\\n    event InterfaceImplementationChanged(bytes32 indexed interfaceName, address indexed newImplementationAddress);\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the address of the contract that implements `interfaceName`.\\r\\n     * @param interfaceName bytes32 of the interface name that is either changed or registered.\\r\\n     * @param implementationAddress address of the implementation contract.\\r\\n     */\\r\\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress)\\r\\n        external\\r\\n        override\\r\\n        onlyOwner\\r\\n    {\\r\\n        interfacesImplemented[interfaceName] = implementationAddress;\\r\\n\\r\\n        emit InterfaceImplementationChanged(interfaceName, implementationAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\\r\\n     * @param interfaceName queried interface.\\r\\n     * @return implementationAddress address of the defined interface.\\r\\n     */\\r\\n    function getImplementationAddress(bytes32 interfaceName) external view override returns (address) {\\r\\n        address implementationAddress = interfacesImplemented[interfaceName];\\r\\n        require(implementationAddress != address(0x0), \\\"Implementation not found\\\");\\r\\n        return implementationAddress;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x95b0b75931ae158b99727e71c40f1a4ab55496c7663b17a6f679819149316fa5\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/implementation/Governor.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../common/implementation/MultiRole.sol\\\";\\r\\nimport \\\"../../common/implementation/FixedPoint.sol\\\";\\r\\nimport \\\"../../common/implementation/Testable.sol\\\";\\r\\nimport \\\"../interfaces/FinderInterface.sol\\\";\\r\\nimport \\\"../interfaces/IdentifierWhitelistInterface.sol\\\";\\r\\nimport \\\"../interfaces/OracleInterface.sol\\\";\\r\\nimport \\\"./Constants.sol\\\";\\r\\nimport \\\"./AdminIdentifierLib.sol\\\";\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Takes proposals for certain governance actions and allows UMA token holders to vote on them.\\r\\n */\\r\\ncontract Governor is MultiRole, Testable {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    /****************************************\\r\\n     *     INTERNAL VARIABLES AND STORAGE   *\\r\\n     ****************************************/\\r\\n\\r\\n    enum Roles {\\r\\n        Owner, // Can set the proposer.\\r\\n        Proposer // Address that can make proposals.\\r\\n    }\\r\\n\\r\\n    struct Transaction {\\r\\n        address to;\\r\\n        uint256 value;\\r\\n        bytes data;\\r\\n    }\\r\\n\\r\\n    struct Proposal {\\r\\n        Transaction[] transactions;\\r\\n        uint256 requestTime;\\r\\n    }\\r\\n\\r\\n    FinderInterface private finder;\\r\\n    Proposal[] public proposals;\\r\\n\\r\\n    /****************************************\\r\\n     *                EVENTS                *\\r\\n     ****************************************/\\r\\n\\r\\n    // Emitted when a new proposal is created.\\r\\n    event NewProposal(uint256 indexed id, Transaction[] transactions);\\r\\n\\r\\n    // Emitted when an existing proposal is executed.\\r\\n    event ProposalExecuted(uint256 indexed id, uint256 transactionIndex);\\r\\n\\r\\n    /**\\r\\n     * @notice Construct the Governor contract.\\r\\n     * @param _finderAddress keeps track of all contracts within the system based on their interfaceName.\\r\\n     * @param _startingId the initial proposal id that the contract will begin incrementing from.\\r\\n     * @param _timerAddress Contract that stores the current time in a testing environment.\\r\\n     * Must be set to 0x0 for production environments that use live time.\\r\\n     */\\r\\n    constructor(\\r\\n        address _finderAddress,\\r\\n        uint256 _startingId,\\r\\n        address _timerAddress\\r\\n    ) Testable(_timerAddress) {\\r\\n        finder = FinderInterface(_finderAddress);\\r\\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\\r\\n        _createExclusiveRole(uint256(Roles.Proposer), uint256(Roles.Owner), msg.sender);\\r\\n\\r\\n        // Ensure the startingId is not set unreasonably high to avoid it being set such that new proposals overwrite\\r\\n        // other storage slots in the contract.\\r\\n        uint256 maxStartingId = 10**18;\\r\\n        require(_startingId <= maxStartingId, \\\"Cannot set startingId larger than 10^18\\\");\\r\\n\\r\\n        // This just sets the initial length of the array to the startingId since modifying length directly has been\\r\\n        // disallowed in solidity 0.6.\\r\\n        assembly {\\r\\n            sstore(proposals.slot, _startingId)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *          PROPOSAL ACTIONS            *\\r\\n     ****************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Proposes a new governance action. Can only be called by the holder of the Proposer role.\\r\\n     * @param transactions list of transactions that are being proposed.\\r\\n     * @dev You can create the data portion of each transaction by doing the following:\\r\\n     * ```\\r\\n     * const truffleContractInstance = await TruffleContract.deployed()\\r\\n     * const data = truffleContractInstance.methods.methodToCall(arg1, arg2).encodeABI()\\r\\n     * ```\\r\\n     * Note: this method must be public because of a solidity limitation that\\r\\n     * disallows structs arrays to be passed to external functions.\\r\\n     */\\r\\n    function propose(Transaction[] memory transactions) public onlyRoleHolder(uint256(Roles.Proposer)) {\\r\\n        uint256 id = proposals.length;\\r\\n        uint256 time = getCurrentTime();\\r\\n\\r\\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\\r\\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\\r\\n\\r\\n        // Add a zero-initialized element to the proposals array.\\r\\n        proposals.push();\\r\\n\\r\\n        // Initialize the new proposal.\\r\\n        Proposal storage proposal = proposals[id];\\r\\n        proposal.requestTime = time;\\r\\n\\r\\n        // Initialize the transaction array.\\r\\n        for (uint256 i = 0; i < transactions.length; i++) {\\r\\n            require(transactions[i].to != address(0), \\\"The `to` address cannot be 0x0\\\");\\r\\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\\r\\n            if (transactions[i].data.length > 0) {\\r\\n                require(transactions[i].to.isContract(), \\\"EOA can't accept tx with data\\\");\\r\\n            }\\r\\n            proposal.transactions.push(transactions[i]);\\r\\n        }\\r\\n\\r\\n        bytes32 identifier = AdminIdentifierLib._constructIdentifier(id);\\r\\n\\r\\n        // Request a vote on this proposal in the DVM.\\r\\n        OracleInterface oracle = _getOracle();\\r\\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\\r\\n        supportedIdentifiers.addSupportedIdentifier(identifier);\\r\\n\\r\\n        oracle.requestPrice(identifier, time);\\r\\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\\r\\n\\r\\n        emit NewProposal(id, transactions);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Executes a proposed governance action that has been approved by voters.\\r\\n     * @dev This can be called by any address. Caller is expected to send enough ETH to execute payable transactions.\\r\\n     * @param id unique id for the executed proposal.\\r\\n     * @param transactionIndex unique transaction index for the executed proposal.\\r\\n     */\\r\\n    function executeProposal(uint256 id, uint256 transactionIndex) external payable {\\r\\n        Proposal storage proposal = proposals[id];\\r\\n        int256 price = _getOracle().getPrice(AdminIdentifierLib._constructIdentifier(id), proposal.requestTime);\\r\\n\\r\\n        Transaction memory transaction = proposal.transactions[transactionIndex];\\r\\n\\r\\n        require(\\r\\n            transactionIndex == 0 || proposal.transactions[transactionIndex.sub(1)].to == address(0),\\r\\n            \\\"Previous tx not yet executed\\\"\\r\\n        );\\r\\n        require(transaction.to != address(0), \\\"Tx already executed\\\");\\r\\n        require(price != 0, \\\"Proposal was rejected\\\");\\r\\n        require(msg.value == transaction.value, \\\"Must send exact amount of ETH\\\");\\r\\n\\r\\n        // Delete the transaction before execution to avoid any potential re-entrancy issues.\\r\\n        delete proposal.transactions[transactionIndex];\\r\\n\\r\\n        require(_executeCall(transaction.to, transaction.value, transaction.data), \\\"Tx execution failed\\\");\\r\\n\\r\\n        emit ProposalExecuted(id, transactionIndex);\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *       GOVERNOR STATE GETTERS         *\\r\\n     ****************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the total number of proposals (includes executed and non-executed).\\r\\n     * @return uint256 representing the current number of proposals.\\r\\n     */\\r\\n    function numProposals() external view returns (uint256) {\\r\\n        return proposals.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the proposal data for a particular id.\\r\\n     * @dev after a proposal is executed, its data will be zeroed out, except for the request time.\\r\\n     * @param id uniquely identify the identity of the proposal.\\r\\n     * @return proposal struct containing transactions[] and requestTime.\\r\\n     */\\r\\n    function getProposal(uint256 id) external view returns (Proposal memory) {\\r\\n        return proposals[id];\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *      PRIVATE GETTERS AND FUNCTIONS   *\\r\\n     ****************************************/\\r\\n\\r\\n    function _executeCall(\\r\\n        address to,\\r\\n        uint256 value,\\r\\n        bytes memory data\\r\\n    ) private returns (bool) {\\r\\n        // Mostly copied from:\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        // https://github.com/gnosis/safe-contracts/blob/59cfdaebcd8b87a0a32f87b50fead092c10d3a05/contracts/base/Executor.sol#L23-L31\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n\\r\\n        bool success;\\r\\n        assembly {\\r\\n            let inputData := add(data, 0x20)\\r\\n            let inputDataSize := mload(data)\\r\\n            success := call(gas(), to, value, inputData, inputDataSize, 0, 0)\\r\\n        }\\r\\n        return success;\\r\\n    }\\r\\n\\r\\n    function _getOracle() private view returns (OracleInterface) {\\r\\n        return OracleInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\\r\\n    }\\r\\n\\r\\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface supportedIdentifiers) {\\r\\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xc58a4a5ed94fc5d9288754312b4e5cc8d2b4dcba0b7234a7674eb17900309dc5\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/implementation/Proposer.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Finder.sol\\\";\\r\\nimport \\\"./Governor.sol\\\";\\r\\nimport \\\"./Constants.sol\\\";\\r\\nimport \\\"./Voting.sol\\\";\\r\\nimport \\\"./AdminIdentifierLib.sol\\\";\\r\\nimport \\\"../../common/implementation/Lockable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Proposer contract that allows anyone to make governance proposals with a bond.\\r\\n */\\r\\ncontract Proposer is Ownable, Testable, Lockable {\\r\\n    using SafeERC20 for IERC20;\\r\\n    IERC20 public token;\\r\\n    uint256 public bond;\\r\\n    Governor public governor;\\r\\n    Finder public finder;\\r\\n\\r\\n    struct BondedProposal {\\r\\n        address sender;\\r\\n        // 64 bits to save a storage slot.\\r\\n        uint64 time;\\r\\n        uint256 lockedBond;\\r\\n    }\\r\\n    mapping(uint256 => BondedProposal) public bondedProposals;\\r\\n\\r\\n    event BondSet(uint256 bond);\\r\\n    event ProposalResolved(uint256 indexed id, bool success);\\r\\n\\r\\n    /**\\r\\n     * @notice Construct the Proposer contract.\\r\\n     * @param _token the ERC20 token that the bond is paid in.\\r\\n     * @param _bond the bond amount.\\r\\n     * @param _governor the governor contract that this contract makes proposals to.\\r\\n     * @param _finder the finder contract used to look up addresses.\\r\\n     * @param _timer the timer contract to control the output of getCurrentTime(). Set to 0x0 if in production.\\r\\n     */\\r\\n    constructor(\\r\\n        IERC20 _token,\\r\\n        uint256 _bond,\\r\\n        Governor _governor,\\r\\n        Finder _finder,\\r\\n        address _timer\\r\\n    ) Testable(_timer) {\\r\\n        token = _token;\\r\\n        governor = _governor;\\r\\n        finder = _finder;\\r\\n        setBond(_bond);\\r\\n        transferOwnership(address(_governor));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Propose a new set of governance transactions for vote.\\r\\n     * @dev Pulls bond from the caller.\\r\\n     * @param transactions list of transactions for the governor to execute.\\r\\n     * @return id the id of the governor proposal.\\r\\n     */\\r\\n    function propose(Governor.Transaction[] memory transactions) external nonReentrant() returns (uint256 id) {\\r\\n        id = governor.numProposals();\\r\\n        token.safeTransferFrom(msg.sender, address(this), bond);\\r\\n        bondedProposals[id] = BondedProposal({ sender: msg.sender, lockedBond: bond, time: uint64(getCurrentTime()) });\\r\\n        governor.propose(transactions);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Resolves a proposal by checking the status of the request in the Voting contract.\\r\\n     * @dev For the resolution to work correctly, this contract must be a registered contract in the DVM.\\r\\n     * @param id proposal id.\\r\\n     */\\r\\n    function resolveProposal(uint256 id) external nonReentrant() {\\r\\n        BondedProposal storage bondedProposal = bondedProposals[id];\\r\\n        Voting voting = Voting(finder.getImplementationAddress(OracleInterfaces.Oracle));\\r\\n        require(\\r\\n            voting.hasPrice(AdminIdentifierLib._constructIdentifier(id), bondedProposal.time, \\\"\\\"),\\r\\n            \\\"No price resolved\\\"\\r\\n        );\\r\\n        if (voting.getPrice(AdminIdentifierLib._constructIdentifier(id), bondedProposal.time, \\\"\\\") != 0) {\\r\\n            token.safeTransfer(bondedProposal.sender, bondedProposal.lockedBond);\\r\\n            emit ProposalResolved(id, true);\\r\\n        } else {\\r\\n            token.safeTransfer(finder.getImplementationAddress(OracleInterfaces.Store), bondedProposal.lockedBond);\\r\\n            emit ProposalResolved(id, false);\\r\\n        }\\r\\n        delete bondedProposals[id];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin method to set the bond amount.\\r\\n     * @dev Admin is intended to be the governance system, itself.\\r\\n     * @param _bond the new bond.\\r\\n     */\\r\\n    function setBond(uint256 _bond) public nonReentrant() onlyOwner() {\\r\\n        bond = _bond;\\r\\n        emit BondSet(_bond);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x0b78f5123fce37c327a06ef2f3b9baf154b7821860169974694004aef8fb365e\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/implementation/Registry.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../common/implementation/MultiRole.sol\\\";\\r\\nimport \\\"../interfaces/RegistryInterface.sol\\\";\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Registry for financial contracts and approved financial contract creators.\\r\\n * @dev Maintains a whitelist of financial contract creators that are allowed\\r\\n * to register new financial contracts and stores party members of a financial contract.\\r\\n */\\r\\ncontract Registry is RegistryInterface, MultiRole {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /****************************************\\r\\n     *    INTERNAL VARIABLES AND STORAGE    *\\r\\n     ****************************************/\\r\\n\\r\\n    enum Roles {\\r\\n        Owner, // The owner manages the set of ContractCreators.\\r\\n        ContractCreator // Can register financial contracts.\\r\\n    }\\r\\n\\r\\n    // This enum is required because a `WasValid` state is required\\r\\n    // to ensure that financial contracts cannot be re-registered.\\r\\n    enum Validity { Invalid, Valid }\\r\\n\\r\\n    // Local information about a contract.\\r\\n    struct FinancialContract {\\r\\n        Validity valid;\\r\\n        uint128 index;\\r\\n    }\\r\\n\\r\\n    struct Party {\\r\\n        address[] contracts; // Each financial contract address is stored in this array.\\r\\n        // The address of each financial contract is mapped to its index for constant time look up and deletion.\\r\\n        mapping(address => uint256) contractIndex;\\r\\n    }\\r\\n\\r\\n    // Array of all contracts that are approved to use the UMA Oracle.\\r\\n    address[] public registeredContracts;\\r\\n\\r\\n    // Map of financial contract contracts to the associated FinancialContract struct.\\r\\n    mapping(address => FinancialContract) public contractMap;\\r\\n\\r\\n    // Map each party member to their their associated Party struct.\\r\\n    mapping(address => Party) private partyMap;\\r\\n\\r\\n    /****************************************\\r\\n     *                EVENTS                *\\r\\n     ****************************************/\\r\\n\\r\\n    event NewContractRegistered(address indexed contractAddress, address indexed creator, address[] parties);\\r\\n    event PartyAdded(address indexed contractAddress, address indexed party);\\r\\n    event PartyRemoved(address indexed contractAddress, address indexed party);\\r\\n\\r\\n    /**\\r\\n     * @notice Construct the Registry contract.\\r\\n     */\\r\\n    constructor() {\\r\\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\\r\\n        // Start with no contract creators registered.\\r\\n        _createSharedRole(uint256(Roles.ContractCreator), uint256(Roles.Owner), new address[](0));\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *        REGISTRATION FUNCTIONS        *\\r\\n     ****************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Registers a new financial contract.\\r\\n     * @dev Only authorized contract creators can call this method.\\r\\n     * @param parties array of addresses who become parties in the contract.\\r\\n     * @param contractAddress address of the contract against which the parties are registered.\\r\\n     */\\r\\n    function registerContract(address[] calldata parties, address contractAddress)\\r\\n        external\\r\\n        override\\r\\n        onlyRoleHolder(uint256(Roles.ContractCreator))\\r\\n    {\\r\\n        FinancialContract storage financialContract = contractMap[contractAddress];\\r\\n        require(contractMap[contractAddress].valid == Validity.Invalid, \\\"Can only register once\\\");\\r\\n\\r\\n        // Store contract address as a registered contract.\\r\\n        registeredContracts.push(contractAddress);\\r\\n\\r\\n        // No length check necessary because we should never hit (2^127 - 1) contracts.\\r\\n        financialContract.index = uint128(registeredContracts.length.sub(1));\\r\\n\\r\\n        // For all parties in the array add them to the contract's parties.\\r\\n        financialContract.valid = Validity.Valid;\\r\\n        for (uint256 i = 0; i < parties.length; i = i.add(1)) {\\r\\n            _addPartyToContract(parties[i], contractAddress);\\r\\n        }\\r\\n\\r\\n        emit NewContractRegistered(contractAddress, msg.sender, parties);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a party member to the calling contract.\\r\\n     * @dev msg.sender will be used to determine the contract that this party is added to.\\r\\n     * @param party new party for the calling contract.\\r\\n     */\\r\\n    function addPartyToContract(address party) external override {\\r\\n        address contractAddress = msg.sender;\\r\\n        require(contractMap[contractAddress].valid == Validity.Valid, \\\"Can only add to valid contract\\\");\\r\\n\\r\\n        _addPartyToContract(party, contractAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Removes a party member from the calling contract.\\r\\n     * @dev msg.sender will be used to determine the contract that this party is removed from.\\r\\n     * @param partyAddress address to be removed from the calling contract.\\r\\n     */\\r\\n    function removePartyFromContract(address partyAddress) external override {\\r\\n        address contractAddress = msg.sender;\\r\\n        Party storage party = partyMap[partyAddress];\\r\\n        uint256 numberOfContracts = party.contracts.length;\\r\\n\\r\\n        require(numberOfContracts != 0, \\\"Party has no contracts\\\");\\r\\n        require(contractMap[contractAddress].valid == Validity.Valid, \\\"Remove only from valid contract\\\");\\r\\n        require(isPartyMemberOfContract(partyAddress, contractAddress), \\\"Can only remove existing party\\\");\\r\\n\\r\\n        // Index of the current location of the contract to remove.\\r\\n        uint256 deleteIndex = party.contractIndex[contractAddress];\\r\\n\\r\\n        // Store the last contract's address to update the lookup map.\\r\\n        address lastContractAddress = party.contracts[numberOfContracts - 1];\\r\\n\\r\\n        // Swap the contract to be removed with the last contract.\\r\\n        party.contracts[deleteIndex] = lastContractAddress;\\r\\n\\r\\n        // Update the lookup index with the new location.\\r\\n        party.contractIndex[lastContractAddress] = deleteIndex;\\r\\n\\r\\n        // Pop the last contract from the array and update the lookup map.\\r\\n        party.contracts.pop();\\r\\n        delete party.contractIndex[contractAddress];\\r\\n\\r\\n        emit PartyRemoved(contractAddress, partyAddress);\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *         REGISTRY STATE GETTERS       *\\r\\n     ****************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Returns whether the contract has been registered with the registry.\\r\\n     * @dev If it is registered, it is an authorized participant in the UMA system.\\r\\n     * @param contractAddress address of the financial contract.\\r\\n     * @return bool indicates whether the contract is registered.\\r\\n     */\\r\\n    function isContractRegistered(address contractAddress) external view override returns (bool) {\\r\\n        return contractMap[contractAddress].valid == Validity.Valid;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns a list of all contracts that are associated with a particular party.\\r\\n     * @param party address of the party.\\r\\n     * @return an array of the contracts the party is registered to.\\r\\n     */\\r\\n    function getRegisteredContracts(address party) external view override returns (address[] memory) {\\r\\n        return partyMap[party].contracts;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns all registered contracts.\\r\\n     * @return all registered contract addresses within the system.\\r\\n     */\\r\\n    function getAllRegisteredContracts() external view override returns (address[] memory) {\\r\\n        return registeredContracts;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice checks if an address is a party of a contract.\\r\\n     * @param party party to check.\\r\\n     * @param contractAddress address to check against the party.\\r\\n     * @return bool indicating if the address is a party of the contract.\\r\\n     */\\r\\n    function isPartyMemberOfContract(address party, address contractAddress) public view override returns (bool) {\\r\\n        uint256 index = partyMap[party].contractIndex[contractAddress];\\r\\n        return partyMap[party].contracts.length > index && partyMap[party].contracts[index] == contractAddress;\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *           INTERNAL FUNCTIONS         *\\r\\n     ****************************************/\\r\\n\\r\\n    function _addPartyToContract(address party, address contractAddress) internal {\\r\\n        require(!isPartyMemberOfContract(party, contractAddress), \\\"Can only register a party once\\\");\\r\\n        uint256 contractIndex = partyMap[party].contracts.length;\\r\\n        partyMap[party].contracts.push(contractAddress);\\r\\n        partyMap[party].contractIndex[contractAddress] = contractIndex;\\r\\n\\r\\n        emit PartyAdded(contractAddress, party);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x0f2261642d37630d06cbb588571a3f2de39f5eef787e38d81833cf4d45bb6e10\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/implementation/ResultComputation.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../common/implementation/FixedPoint.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Computes vote results.\\r\\n * @dev The result is the mode of the added votes. Otherwise, the vote is unresolved.\\r\\n */\\r\\nlibrary ResultComputation {\\r\\n    using FixedPoint for FixedPoint.Unsigned;\\r\\n\\r\\n    /****************************************\\r\\n     *   INTERNAL LIBRARY DATA STRUCTURE    *\\r\\n     ****************************************/\\r\\n\\r\\n    struct Data {\\r\\n        // Maps price to number of tokens that voted for that price.\\r\\n        mapping(int256 => FixedPoint.Unsigned) voteFrequency;\\r\\n        // The total votes that have been added.\\r\\n        FixedPoint.Unsigned totalVotes;\\r\\n        // The price that is the current mode, i.e., the price with the highest frequency in `voteFrequency`.\\r\\n        int256 currentMode;\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *            VOTING FUNCTIONS          *\\r\\n     ****************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new vote to be used when computing the result.\\r\\n     * @param data contains information to which the vote is applied.\\r\\n     * @param votePrice value specified in the vote for the given `numberTokens`.\\r\\n     * @param numberTokens number of tokens that voted on the `votePrice`.\\r\\n     */\\r\\n    function addVote(\\r\\n        Data storage data,\\r\\n        int256 votePrice,\\r\\n        FixedPoint.Unsigned memory numberTokens\\r\\n    ) internal {\\r\\n        data.totalVotes = data.totalVotes.add(numberTokens);\\r\\n        data.voteFrequency[votePrice] = data.voteFrequency[votePrice].add(numberTokens);\\r\\n        if (\\r\\n            votePrice != data.currentMode &&\\r\\n            data.voteFrequency[votePrice].isGreaterThan(data.voteFrequency[data.currentMode])\\r\\n        ) data.currentMode = votePrice;\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *        VOTING STATE GETTERS          *\\r\\n     ****************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Returns whether the result is resolved, and if so, what value it resolved to.\\r\\n     * @dev `price` should be ignored if `isResolved` is false.\\r\\n     * @param data contains information against which the `minVoteThreshold` is applied.\\r\\n     * @param minVoteThreshold min (exclusive) number of tokens that must have voted for the result to be valid. Can be\\r\\n     * used to enforce a minimum voter participation rate, regardless of how the votes are distributed.\\r\\n     * @return isResolved indicates if the price has been resolved correctly.\\r\\n     * @return price the price that the dvm resolved to.\\r\\n     */\\r\\n    function getResolvedPrice(Data storage data, FixedPoint.Unsigned memory minVoteThreshold)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool isResolved, int256 price)\\r\\n    {\\r\\n        FixedPoint.Unsigned memory modeThreshold = FixedPoint.fromUnscaledUint(50).div(100);\\r\\n\\r\\n        if (\\r\\n            data.totalVotes.isGreaterThan(minVoteThreshold) &&\\r\\n            data.voteFrequency[data.currentMode].div(data.totalVotes).isGreaterThan(modeThreshold)\\r\\n        ) {\\r\\n            // `modeThreshold` and `minVoteThreshold` are exceeded, so the current mode is the resolved price.\\r\\n            isResolved = true;\\r\\n            price = data.currentMode;\\r\\n        } else isResolved = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks whether a `voteHash` is considered correct.\\r\\n     * @dev Should only be called after a vote is resolved, i.e., via `getResolvedPrice`.\\r\\n     * @param data contains information against which the `voteHash` is checked.\\r\\n     * @param voteHash committed hash submitted by the voter.\\r\\n     * @return bool true if the vote was correct.\\r\\n     */\\r\\n    function wasVoteCorrect(Data storage data, bytes32 voteHash) internal view returns (bool) {\\r\\n        return voteHash == keccak256(abi.encode(data.currentMode));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the total number of tokens whose votes are considered correct.\\r\\n     * @dev Should only be called after a vote is resolved, i.e., via `getResolvedPrice`.\\r\\n     * @param data contains all votes against which the correctly voted tokens are counted.\\r\\n     * @return FixedPoint.Unsigned which indicates the frequency of the correctly voted tokens.\\r\\n     */\\r\\n    function getTotalCorrectlyVotedTokens(Data storage data) internal view returns (FixedPoint.Unsigned memory) {\\r\\n        return data.voteFrequency[data.currentMode];\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x696b4c11b686987597005d85e60c576e4cb8b4e2f39c7d502bc6338869f32650\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/implementation/VoteTiming.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/VotingInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Library to compute rounds and phases for an equal length commit-reveal voting cycle.\\r\\n */\\r\\nlibrary VoteTiming {\\r\\n    struct Data {\\r\\n        uint256 phaseLength;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the data object. Sets the phase length based on the input.\\r\\n     * @param data reference to the this library's data object.\\r\\n     * @param phaseLength length of voting phase in seconds.\\r\\n     */\\r\\n    function init(Data storage data, uint256 phaseLength) internal {\\r\\n        // This should have a require message but this results in an internal Solidity error.\\r\\n        require(phaseLength > 0);\\r\\n        data.phaseLength = phaseLength;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the roundID based off the current time as floor(timestamp/roundLength).\\r\\n     * @dev The round ID depends on the global timestamp but not on the lifetime of the system.\\r\\n     * The consequence is that the initial round ID starts at an arbitrary number (that increments, as expected, for subsequent rounds) instead of zero or one.\\r\\n     * @param data input data object.\\r\\n     * @param currentTime input unix timestamp used to compute the current roundId.\\r\\n     * @return roundId defined as a function of the currentTime and `phaseLength` from `data`.\\r\\n     */\\r\\n    function computeCurrentRoundId(Data storage data, uint256 currentTime) internal view returns (uint256) {\\r\\n        uint256 roundLength = data.phaseLength * uint256(VotingAncillaryInterface.Phase.NUM_PHASES);\\r\\n        return currentTime / roundLength;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice compute the round end time as a function of the round Id.\\r\\n     * @param data input data object.\\r\\n     * @param roundId uniquely identifies the current round.\\r\\n     * @return timestamp unix time of when the current round will end.\\r\\n     */\\r\\n    function computeRoundEndTime(Data storage data, uint256 roundId) internal view returns (uint256) {\\r\\n        uint256 roundLength = data.phaseLength * uint256(VotingAncillaryInterface.Phase.NUM_PHASES);\\r\\n        return roundLength * (roundId + 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the current phase based only on the current time.\\r\\n     * @param data input data object.\\r\\n     * @param currentTime input unix timestamp used to compute the current roundId.\\r\\n     * @return current voting phase based on current time and vote phases configuration.\\r\\n     */\\r\\n    function computeCurrentPhase(Data storage data, uint256 currentTime)\\r\\n        internal\\r\\n        view\\r\\n        returns (VotingAncillaryInterface.Phase)\\r\\n    {\\r\\n        // This employs some hacky casting. We could make this an if-statement if we're worried about type safety.\\r\\n        return\\r\\n            VotingAncillaryInterface.Phase(\\r\\n                (currentTime / data.phaseLength) % uint256(VotingAncillaryInterface.Phase.NUM_PHASES)\\r\\n            );\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x2fed5ae911ef4d9a01895768e058998642c23a0aa293b5655d3425a0fedc8879\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/implementation/Voting.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../common/implementation/FixedPoint.sol\\\";\\r\\nimport \\\"../../common/implementation/Testable.sol\\\";\\r\\nimport \\\"../interfaces/FinderInterface.sol\\\";\\r\\nimport \\\"../interfaces/OracleInterface.sol\\\";\\r\\nimport \\\"../interfaces/OracleAncillaryInterface.sol\\\";\\r\\nimport \\\"../interfaces/VotingInterface.sol\\\";\\r\\nimport \\\"../interfaces/VotingAncillaryInterface.sol\\\";\\r\\nimport \\\"../interfaces/IdentifierWhitelistInterface.sol\\\";\\r\\nimport \\\"./Registry.sol\\\";\\r\\nimport \\\"./ResultComputation.sol\\\";\\r\\nimport \\\"./VoteTiming.sol\\\";\\r\\nimport \\\"./VotingToken.sol\\\";\\r\\nimport \\\"./Constants.sol\\\";\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Voting system for Oracle.\\r\\n * @dev Handles receiving and resolving price requests via a commit-reveal voting scheme.\\r\\n */\\r\\ncontract Voting is\\r\\n    Testable,\\r\\n    Ownable,\\r\\n    OracleInterface,\\r\\n    OracleAncillaryInterface, // Interface to support ancillary data with price requests.\\r\\n    VotingInterface,\\r\\n    VotingAncillaryInterface // Interface to support ancillary data with voting rounds.\\r\\n{\\r\\n    using FixedPoint for FixedPoint.Unsigned;\\r\\n    using SafeMath for uint256;\\r\\n    using VoteTiming for VoteTiming.Data;\\r\\n    using ResultComputation for ResultComputation.Data;\\r\\n\\r\\n    /****************************************\\r\\n     *        VOTING DATA STRUCTURES        *\\r\\n     ****************************************/\\r\\n\\r\\n    // Identifies a unique price request for which the Oracle will always return the same value.\\r\\n    // Tracks ongoing votes as well as the result of the vote.\\r\\n    struct PriceRequest {\\r\\n        bytes32 identifier;\\r\\n        uint256 time;\\r\\n        // A map containing all votes for this price in various rounds.\\r\\n        mapping(uint256 => VoteInstance) voteInstances;\\r\\n        // If in the past, this was the voting round where this price was resolved. If current or the upcoming round,\\r\\n        // this is the voting round where this price will be voted on, but not necessarily resolved.\\r\\n        uint256 lastVotingRound;\\r\\n        // The index in the `pendingPriceRequests` that references this PriceRequest. A value of UINT_MAX means that\\r\\n        // this PriceRequest is resolved and has been cleaned up from `pendingPriceRequests`.\\r\\n        uint256 index;\\r\\n        bytes ancillaryData;\\r\\n    }\\r\\n\\r\\n    struct VoteInstance {\\r\\n        // Maps (voterAddress) to their submission.\\r\\n        mapping(address => VoteSubmission) voteSubmissions;\\r\\n        // The data structure containing the computed voting results.\\r\\n        ResultComputation.Data resultComputation;\\r\\n    }\\r\\n\\r\\n    struct VoteSubmission {\\r\\n        // A bytes32 of `0` indicates no commit or a commit that was already revealed.\\r\\n        bytes32 commit;\\r\\n        // The hash of the value that was revealed.\\r\\n        // Note: this is only used for computation of rewards.\\r\\n        bytes32 revealHash;\\r\\n    }\\r\\n\\r\\n    struct Round {\\r\\n        uint256 snapshotId; // Voting token snapshot ID for this round.  0 if no snapshot has been taken.\\r\\n        FixedPoint.Unsigned inflationRate; // Inflation rate set for this round.\\r\\n        FixedPoint.Unsigned gatPercentage; // Gat rate set for this round.\\r\\n        uint256 rewardsExpirationTime; // Time that rewards for this round can be claimed until.\\r\\n    }\\r\\n\\r\\n    // Represents the status a price request has.\\r\\n    enum RequestStatus {\\r\\n        NotRequested, // Was never requested.\\r\\n        Active, // Is being voted on in the current round.\\r\\n        Resolved, // Was resolved in a previous round.\\r\\n        Future // Is scheduled to be voted on in a future round.\\r\\n    }\\r\\n\\r\\n    // Only used as a return value in view methods -- never stored in the contract.\\r\\n    struct RequestState {\\r\\n        RequestStatus status;\\r\\n        uint256 lastVotingRound;\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *          INTERNAL TRACKING           *\\r\\n     ****************************************/\\r\\n\\r\\n    // Maps round numbers to the rounds.\\r\\n    mapping(uint256 => Round) public rounds;\\r\\n\\r\\n    // Maps price request IDs to the PriceRequest struct.\\r\\n    mapping(bytes32 => PriceRequest) private priceRequests;\\r\\n\\r\\n    // Price request ids for price requests that haven't yet been marked as resolved.\\r\\n    // These requests may be for future rounds.\\r\\n    bytes32[] internal pendingPriceRequests;\\r\\n\\r\\n    VoteTiming.Data public voteTiming;\\r\\n\\r\\n    // Percentage of the total token supply that must be used in a vote to\\r\\n    // create a valid price resolution. 1 == 100%.\\r\\n    FixedPoint.Unsigned public gatPercentage;\\r\\n\\r\\n    // Global setting for the rate of inflation per vote. This is the percentage of the snapshotted total supply that\\r\\n    // should be split among the correct voters.\\r\\n    // Note: this value is used to set per-round inflation at the beginning of each round. 1 = 100%.\\r\\n    FixedPoint.Unsigned public inflationRate;\\r\\n\\r\\n    // Time in seconds from the end of the round in which a price request is\\r\\n    // resolved that voters can still claim their rewards.\\r\\n    uint256 public rewardsExpirationTimeout;\\r\\n\\r\\n    // Reference to the voting token.\\r\\n    VotingToken public votingToken;\\r\\n\\r\\n    // Reference to the Finder.\\r\\n    FinderInterface private finder;\\r\\n\\r\\n    // If non-zero, this contract has been migrated to this address. All voters and\\r\\n    // financial contracts should query the new address only.\\r\\n    address public migratedAddress;\\r\\n\\r\\n    // Max value of an unsigned integer.\\r\\n    uint256 private constant UINT_MAX = ~uint256(0);\\r\\n\\r\\n    // Max length in bytes of ancillary data that can be appended to a price request.\\r\\n    // As of December 2020, the current Ethereum gas limit is 12.5 million. This requestPrice function's gas primarily\\r\\n    // comes from computing a Keccak-256 hash in _encodePriceRequest and writing a new PriceRequest to\\r\\n    // storage. We have empirically determined an ancillary data limit of 8192 bytes that keeps this function\\r\\n    // well within the gas limit at ~8 million gas. To learn more about the gas limit and EVM opcode costs go here:\\r\\n    // - https://etherscan.io/chart/gaslimit\\r\\n    // - https://github.com/djrtwo/evm-opcode-gas-costs\\r\\n    uint256 public constant ancillaryBytesLimit = 8192;\\r\\n\\r\\n    bytes32 public snapshotMessageHash = ECDSA.toEthSignedMessageHash(keccak256(bytes(\\\"Sign For Snapshot\\\")));\\r\\n\\r\\n    /***************************************\\r\\n     *                EVENTS                *\\r\\n     ****************************************/\\r\\n\\r\\n    event VoteCommitted(\\r\\n        address indexed voter,\\r\\n        uint256 indexed roundId,\\r\\n        bytes32 indexed identifier,\\r\\n        uint256 time,\\r\\n        bytes ancillaryData\\r\\n    );\\r\\n\\r\\n    event EncryptedVote(\\r\\n        address indexed voter,\\r\\n        uint256 indexed roundId,\\r\\n        bytes32 indexed identifier,\\r\\n        uint256 time,\\r\\n        bytes ancillaryData,\\r\\n        bytes encryptedVote\\r\\n    );\\r\\n\\r\\n    event VoteRevealed(\\r\\n        address indexed voter,\\r\\n        uint256 indexed roundId,\\r\\n        bytes32 indexed identifier,\\r\\n        uint256 time,\\r\\n        int256 price,\\r\\n        bytes ancillaryData,\\r\\n        uint256 numTokens\\r\\n    );\\r\\n\\r\\n    event RewardsRetrieved(\\r\\n        address indexed voter,\\r\\n        uint256 indexed roundId,\\r\\n        bytes32 indexed identifier,\\r\\n        uint256 time,\\r\\n        bytes ancillaryData,\\r\\n        uint256 numTokens\\r\\n    );\\r\\n\\r\\n    event PriceRequestAdded(uint256 indexed roundId, bytes32 indexed identifier, uint256 time);\\r\\n\\r\\n    event PriceResolved(\\r\\n        uint256 indexed roundId,\\r\\n        bytes32 indexed identifier,\\r\\n        uint256 time,\\r\\n        int256 price,\\r\\n        bytes ancillaryData\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Construct the Voting contract.\\r\\n     * @param _phaseLength length of the commit and reveal phases in seconds.\\r\\n     * @param _gatPercentage of the total token supply that must be used in a vote to create a valid price resolution.\\r\\n     * @param _inflationRate percentage inflation per round used to increase token supply of correct voters.\\r\\n     * @param _rewardsExpirationTimeout timeout, in seconds, within which rewards must be claimed.\\r\\n     * @param _votingToken address of the UMA token contract used to commit votes.\\r\\n     * @param _finder keeps track of all contracts within the system based on their interfaceName.\\r\\n     * @param _timerAddress Contract that stores the current time in a testing environment.\\r\\n     * Must be set to 0x0 for production environments that use live time.\\r\\n     */\\r\\n    constructor(\\r\\n        uint256 _phaseLength,\\r\\n        FixedPoint.Unsigned memory _gatPercentage,\\r\\n        FixedPoint.Unsigned memory _inflationRate,\\r\\n        uint256 _rewardsExpirationTimeout,\\r\\n        address _votingToken,\\r\\n        address _finder,\\r\\n        address _timerAddress\\r\\n    ) Testable(_timerAddress) {\\r\\n        voteTiming.init(_phaseLength);\\r\\n        require(_gatPercentage.isLessThanOrEqual(1), \\\"GAT percentage must be <= 100%\\\");\\r\\n        gatPercentage = _gatPercentage;\\r\\n        inflationRate = _inflationRate;\\r\\n        votingToken = VotingToken(_votingToken);\\r\\n        finder = FinderInterface(_finder);\\r\\n        rewardsExpirationTimeout = _rewardsExpirationTimeout;\\r\\n    }\\r\\n\\r\\n    /***************************************\\r\\n                    MODIFIERS\\r\\n    ****************************************/\\r\\n\\r\\n    modifier onlyRegisteredContract() {\\r\\n        if (migratedAddress != address(0)) {\\r\\n            require(msg.sender == migratedAddress, \\\"Caller must be migrated address\\\");\\r\\n        } else {\\r\\n            Registry registry = Registry(finder.getImplementationAddress(OracleInterfaces.Registry));\\r\\n            require(registry.isContractRegistered(msg.sender), \\\"Called must be registered\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyIfNotMigrated() {\\r\\n        require(migratedAddress == address(0), \\\"Only call this if not migrated\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *  PRICE REQUEST AND ACCESS FUNCTIONS  *\\r\\n     ****************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\\r\\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data\\r\\n     * is limited such that this method abides by the EVM transaction gas limit.\\r\\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\\r\\n     * @param time unix timestamp for the price request.\\r\\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\r\\n     */\\r\\n    function requestPrice(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData\\r\\n    ) public override onlyRegisteredContract() {\\r\\n        uint256 blockTime = getCurrentTime();\\r\\n        require(time <= blockTime, \\\"Can only request in past\\\");\\r\\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \\\"Unsupported identifier request\\\");\\r\\n        require(ancillaryData.length <= ancillaryBytesLimit, \\\"Invalid ancillary data\\\");\\r\\n\\r\\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\\r\\n        PriceRequest storage priceRequest = priceRequests[priceRequestId];\\r\\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\\r\\n\\r\\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\\r\\n\\r\\n        if (requestStatus == RequestStatus.NotRequested) {\\r\\n            // Price has never been requested.\\r\\n            // Price requests always go in the next round, so add 1 to the computed current round.\\r\\n            uint256 nextRoundId = currentRoundId.add(1);\\r\\n\\r\\n            PriceRequest storage newPriceRequest = priceRequests[priceRequestId];\\r\\n            newPriceRequest.identifier = identifier;\\r\\n            newPriceRequest.time = time;\\r\\n            newPriceRequest.lastVotingRound = nextRoundId;\\r\\n            newPriceRequest.index = pendingPriceRequests.length;\\r\\n            newPriceRequest.ancillaryData = ancillaryData;\\r\\n\\r\\n            pendingPriceRequests.push(priceRequestId);\\r\\n            emit PriceRequestAdded(nextRoundId, identifier, time);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\r\\n    function requestPrice(bytes32 identifier, uint256 time) public override {\\r\\n        requestPrice(identifier, time, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether the price for `identifier` and `time` is available.\\r\\n     * @dev Time must be in the past and the identifier must be supported.\\r\\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\\r\\n     * @param time unix timestamp of for the price request.\\r\\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\r\\n     * @return _hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.\\r\\n     */\\r\\n    function hasPrice(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData\\r\\n    ) public view override onlyRegisteredContract() returns (bool) {\\r\\n        (bool _hasPrice, , ) = _getPriceOrError(identifier, time, ancillaryData);\\r\\n        return _hasPrice;\\r\\n    }\\r\\n\\r\\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\r\\n    function hasPrice(bytes32 identifier, uint256 time) public view override returns (bool) {\\r\\n        return hasPrice(identifier, time, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\\r\\n     * @dev If the price is not available, the method reverts.\\r\\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\\r\\n     * @param time unix timestamp of for the price request.\\r\\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\r\\n     * @return int256 representing the resolved price for the given identifier and timestamp.\\r\\n     */\\r\\n    function getPrice(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData\\r\\n    ) public view override onlyRegisteredContract() returns (int256) {\\r\\n        (bool _hasPrice, int256 price, string memory message) = _getPriceOrError(identifier, time, ancillaryData);\\r\\n\\r\\n        // If the price wasn't available, revert with the provided message.\\r\\n        require(_hasPrice, message);\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\r\\n    function getPrice(bytes32 identifier, uint256 time) public view override returns (int256) {\\r\\n        return getPrice(identifier, time, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the status of a list of price requests, identified by their identifier and time.\\r\\n     * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.\\r\\n     * @param requests array of type PendingRequest which includes an identifier and timestamp for each request.\\r\\n     * @return requestStates a list, in the same order as the input list, giving the status of each of the specified price requests.\\r\\n     */\\r\\n    function getPriceRequestStatuses(PendingRequestAncillary[] memory requests)\\r\\n        public\\r\\n        view\\r\\n        returns (RequestState[] memory)\\r\\n    {\\r\\n        RequestState[] memory requestStates = new RequestState[](requests.length);\\r\\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\\r\\n        for (uint256 i = 0; i < requests.length; i++) {\\r\\n            PriceRequest storage priceRequest =\\r\\n                _getPriceRequest(requests[i].identifier, requests[i].time, requests[i].ancillaryData);\\r\\n\\r\\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\\r\\n\\r\\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\\r\\n            if (status == RequestStatus.Active) {\\r\\n                requestStates[i].lastVotingRound = currentRoundId;\\r\\n            } else {\\r\\n                requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\\r\\n            }\\r\\n            requestStates[i].status = status;\\r\\n        }\\r\\n        return requestStates;\\r\\n    }\\r\\n\\r\\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\r\\n    function getPriceRequestStatuses(PendingRequest[] memory requests) public view returns (RequestState[] memory) {\\r\\n        PendingRequestAncillary[] memory requestsAncillary = new PendingRequestAncillary[](requests.length);\\r\\n\\r\\n        for (uint256 i = 0; i < requests.length; i++) {\\r\\n            requestsAncillary[i].identifier = requests[i].identifier;\\r\\n            requestsAncillary[i].time = requests[i].time;\\r\\n            requestsAncillary[i].ancillaryData = \\\"\\\";\\r\\n        }\\r\\n        return getPriceRequestStatuses(requestsAncillary);\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *            VOTING FUNCTIONS          *\\r\\n     ****************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Commit a vote for a price request for `identifier` at `time`.\\r\\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\\r\\n     * Commits can be changed.\\r\\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the system\\u2019s expected behavior,\\r\\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\\r\\n     * they can determine the vote pre-reveal.\\r\\n     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\\r\\n     * @param time unix timestamp of the price being voted on.\\r\\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\r\\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\\r\\n     */\\r\\n    function commitVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData,\\r\\n        bytes32 hash\\r\\n    ) public override onlyIfNotMigrated() {\\r\\n        require(hash != bytes32(0), \\\"Invalid provided hash\\\");\\r\\n        // Current time is required for all vote timing queries.\\r\\n        uint256 blockTime = getCurrentTime();\\r\\n        require(\\r\\n            voteTiming.computeCurrentPhase(blockTime) == VotingAncillaryInterface.Phase.Commit,\\r\\n            \\\"Cannot commit in reveal phase\\\"\\r\\n        );\\r\\n\\r\\n        // At this point, the computed and last updated round ID should be equal.\\r\\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\\r\\n\\r\\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\\r\\n        require(\\r\\n            _getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active,\\r\\n            \\\"Cannot commit inactive request\\\"\\r\\n        );\\r\\n\\r\\n        priceRequest.lastVotingRound = currentRoundId;\\r\\n        VoteInstance storage voteInstance = priceRequest.voteInstances[currentRoundId];\\r\\n        voteInstance.voteSubmissions[msg.sender].commit = hash;\\r\\n\\r\\n        emit VoteCommitted(msg.sender, currentRoundId, identifier, time, ancillaryData);\\r\\n    }\\r\\n\\r\\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\r\\n    function commitVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes32 hash\\r\\n    ) public override onlyIfNotMigrated() {\\r\\n        commitVote(identifier, time, \\\"\\\", hash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Snapshot the current round's token balances and lock in the inflation rate and GAT.\\r\\n     * @dev This function can be called multiple times, but only the first call per round into this function or `revealVote`\\r\\n     * will create the round snapshot. Any later calls will be a no-op. Will revert unless called during reveal period.\\r\\n     * @param signature  signature required to prove caller is an EOA to prevent flash loans from being included in the\\r\\n     * snapshot.\\r\\n     */\\r\\n    function snapshotCurrentRound(bytes calldata signature)\\r\\n        external\\r\\n        override(VotingInterface, VotingAncillaryInterface)\\r\\n        onlyIfNotMigrated()\\r\\n    {\\r\\n        uint256 blockTime = getCurrentTime();\\r\\n        require(voteTiming.computeCurrentPhase(blockTime) == Phase.Reveal, \\\"Only snapshot in reveal phase\\\");\\r\\n        // Require public snapshot require signature to ensure caller is an EOA.\\r\\n        require(ECDSA.recover(snapshotMessageHash, signature) == msg.sender, \\\"Signature must match sender\\\");\\r\\n        uint256 roundId = voteTiming.computeCurrentRoundId(blockTime);\\r\\n        _freezeRoundVariables(roundId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\\r\\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\\r\\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\\r\\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\\r\\n     * @param time specifies the unix timestamp of the price being voted on.\\r\\n     * @param price voted on during the commit phase.\\r\\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\r\\n     * @param salt value used to hide the commitment price during the commit phase.\\r\\n     */\\r\\n    function revealVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        int256 price,\\r\\n        bytes memory ancillaryData,\\r\\n        int256 salt\\r\\n    ) public override onlyIfNotMigrated() {\\r\\n        require(voteTiming.computeCurrentPhase(getCurrentTime()) == Phase.Reveal, \\\"Cannot reveal in commit phase\\\");\\r\\n        // Note: computing the current round is required to disallow people from revealing an old commit after the round is over.\\r\\n        uint256 roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\\r\\n\\r\\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\\r\\n        VoteInstance storage voteInstance = priceRequest.voteInstances[roundId];\\r\\n        VoteSubmission storage voteSubmission = voteInstance.voteSubmissions[msg.sender];\\r\\n\\r\\n        // Scoping to get rid of a stack too deep error.\\r\\n        {\\r\\n            // 0 hashes are disallowed in the commit phase, so they indicate a different error.\\r\\n            // Cannot reveal an uncommitted or previously revealed hash\\r\\n            require(voteSubmission.commit != bytes32(0), \\\"Invalid hash reveal\\\");\\r\\n            require(\\r\\n                keccak256(abi.encodePacked(price, salt, msg.sender, time, ancillaryData, roundId, identifier)) ==\\r\\n                    voteSubmission.commit,\\r\\n                \\\"Revealed data != commit hash\\\"\\r\\n            );\\r\\n            // To protect against flash loans, we require snapshot be validated as EOA.\\r\\n            require(rounds[roundId].snapshotId != 0, \\\"Round has no snapshot\\\");\\r\\n        }\\r\\n\\r\\n        // Get the frozen snapshotId\\r\\n        uint256 snapshotId = rounds[roundId].snapshotId;\\r\\n\\r\\n        delete voteSubmission.commit;\\r\\n\\r\\n        // Get the voter's snapshotted balance. Since balances are returned pre-scaled by 10**18, we can directly\\r\\n        // initialize the Unsigned value with the returned uint.\\r\\n        FixedPoint.Unsigned memory balance = FixedPoint.Unsigned(votingToken.balanceOfAt(msg.sender, snapshotId));\\r\\n\\r\\n        // Set the voter's submission.\\r\\n        voteSubmission.revealHash = keccak256(abi.encode(price));\\r\\n\\r\\n        // Add vote to the results.\\r\\n        voteInstance.resultComputation.addVote(price, balance);\\r\\n\\r\\n        emit VoteRevealed(msg.sender, roundId, identifier, time, price, ancillaryData, balance.rawValue);\\r\\n    }\\r\\n\\r\\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\r\\n    function revealVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        int256 price,\\r\\n        int256 salt\\r\\n    ) public override {\\r\\n        revealVote(identifier, time, price, \\\"\\\", salt);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\\r\\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\\r\\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\\r\\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\\r\\n     * @param time unix timestamp of for the price request.\\r\\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\r\\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\\r\\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\\r\\n     */\\r\\n    function commitAndEmitEncryptedVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData,\\r\\n        bytes32 hash,\\r\\n        bytes memory encryptedVote\\r\\n    ) public override {\\r\\n        commitVote(identifier, time, ancillaryData, hash);\\r\\n\\r\\n        uint256 roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\\r\\n        emit EncryptedVote(msg.sender, roundId, identifier, time, ancillaryData, encryptedVote);\\r\\n    }\\r\\n\\r\\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\r\\n    function commitAndEmitEncryptedVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes32 hash,\\r\\n        bytes memory encryptedVote\\r\\n    ) public override {\\r\\n        commitVote(identifier, time, \\\"\\\", hash);\\r\\n\\r\\n        commitAndEmitEncryptedVote(identifier, time, \\\"\\\", hash, encryptedVote);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Submit a batch of commits in a single transaction.\\r\\n     * @dev Using `encryptedVote` is optional. If included then commitment is emitted in an event.\\r\\n     * Look at `project-root/common/Constants.js` for the tested maximum number of\\r\\n     * commitments that can fit in one transaction.\\r\\n     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\\r\\n     */\\r\\n    function batchCommit(CommitmentAncillary[] memory commits) public override {\\r\\n        for (uint256 i = 0; i < commits.length; i++) {\\r\\n            if (commits[i].encryptedVote.length == 0) {\\r\\n                commitVote(commits[i].identifier, commits[i].time, commits[i].ancillaryData, commits[i].hash);\\r\\n            } else {\\r\\n                commitAndEmitEncryptedVote(\\r\\n                    commits[i].identifier,\\r\\n                    commits[i].time,\\r\\n                    commits[i].ancillaryData,\\r\\n                    commits[i].hash,\\r\\n                    commits[i].encryptedVote\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\r\\n    function batchCommit(Commitment[] memory commits) public override {\\r\\n        CommitmentAncillary[] memory commitsAncillary = new CommitmentAncillary[](commits.length);\\r\\n\\r\\n        for (uint256 i = 0; i < commits.length; i++) {\\r\\n            commitsAncillary[i].identifier = commits[i].identifier;\\r\\n            commitsAncillary[i].time = commits[i].time;\\r\\n            commitsAncillary[i].ancillaryData = \\\"\\\";\\r\\n            commitsAncillary[i].hash = commits[i].hash;\\r\\n            commitsAncillary[i].encryptedVote = commits[i].encryptedVote;\\r\\n        }\\r\\n        batchCommit(commitsAncillary);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reveal multiple votes in a single transaction.\\r\\n     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\\r\\n     * that can fit in one transaction.\\r\\n     * @dev For more info on reveals, review the comment for `revealVote`.\\r\\n     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\\r\\n     */\\r\\n    function batchReveal(RevealAncillary[] memory reveals) public override {\\r\\n        for (uint256 i = 0; i < reveals.length; i++) {\\r\\n            revealVote(\\r\\n                reveals[i].identifier,\\r\\n                reveals[i].time,\\r\\n                reveals[i].price,\\r\\n                reveals[i].ancillaryData,\\r\\n                reveals[i].salt\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\r\\n    function batchReveal(Reveal[] memory reveals) public override {\\r\\n        RevealAncillary[] memory revealsAncillary = new RevealAncillary[](reveals.length);\\r\\n\\r\\n        for (uint256 i = 0; i < reveals.length; i++) {\\r\\n            revealsAncillary[i].identifier = reveals[i].identifier;\\r\\n            revealsAncillary[i].time = reveals[i].time;\\r\\n            revealsAncillary[i].price = reveals[i].price;\\r\\n            revealsAncillary[i].ancillaryData = \\\"\\\";\\r\\n            revealsAncillary[i].salt = reveals[i].salt;\\r\\n        }\\r\\n        batchReveal(revealsAncillary);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves rewards owed for a set of resolved price requests.\\r\\n     * @dev Can only retrieve rewards if calling for a valid round and if the call is done within the timeout threshold\\r\\n     * (not expired). Note that a named return value is used here to avoid a stack to deep error.\\r\\n     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\\r\\n     * @param roundId the round from which voting rewards will be retrieved from.\\r\\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\\r\\n     * @return totalRewardToIssue total amount of rewards returned to the voter.\\r\\n     */\\r\\n    function retrieveRewards(\\r\\n        address voterAddress,\\r\\n        uint256 roundId,\\r\\n        PendingRequestAncillary[] memory toRetrieve\\r\\n    ) public override returns (FixedPoint.Unsigned memory totalRewardToIssue) {\\r\\n        if (migratedAddress != address(0)) {\\r\\n            require(msg.sender == migratedAddress, \\\"Can only call from migrated\\\");\\r\\n        }\\r\\n        require(roundId < voteTiming.computeCurrentRoundId(getCurrentTime()), \\\"Invalid roundId\\\");\\r\\n\\r\\n        Round storage round = rounds[roundId];\\r\\n        bool isExpired = getCurrentTime() > round.rewardsExpirationTime;\\r\\n        FixedPoint.Unsigned memory snapshotBalance =\\r\\n            FixedPoint.Unsigned(votingToken.balanceOfAt(voterAddress, round.snapshotId));\\r\\n\\r\\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\\r\\n        FixedPoint.Unsigned memory snapshotTotalSupply =\\r\\n            FixedPoint.Unsigned(votingToken.totalSupplyAt(round.snapshotId));\\r\\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\\r\\n\\r\\n        // Keep track of the voter's accumulated token reward.\\r\\n        totalRewardToIssue = FixedPoint.Unsigned(0);\\r\\n\\r\\n        for (uint256 i = 0; i < toRetrieve.length; i++) {\\r\\n            PriceRequest storage priceRequest =\\r\\n                _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time, toRetrieve[i].ancillaryData);\\r\\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\\r\\n            // Only retrieve rewards for votes resolved in same round\\r\\n            require(priceRequest.lastVotingRound == roundId, \\\"Retrieve for votes same round\\\");\\r\\n\\r\\n            _resolvePriceRequest(priceRequest, voteInstance);\\r\\n\\r\\n            if (voteInstance.voteSubmissions[voterAddress].revealHash == 0) {\\r\\n                continue;\\r\\n            } else if (isExpired) {\\r\\n                // Emit a 0 token retrieval on expired rewards.\\r\\n                emit RewardsRetrieved(\\r\\n                    voterAddress,\\r\\n                    roundId,\\r\\n                    toRetrieve[i].identifier,\\r\\n                    toRetrieve[i].time,\\r\\n                    toRetrieve[i].ancillaryData,\\r\\n                    0\\r\\n                );\\r\\n            } else if (\\r\\n                voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)\\r\\n            ) {\\r\\n                // The price was successfully resolved during the voter's last voting round, the voter revealed\\r\\n                // and was correct, so they are eligible for a reward.\\r\\n                // Compute the reward and add to the cumulative reward.\\r\\n\\r\\n                FixedPoint.Unsigned memory reward =\\r\\n                    snapshotBalance.mul(totalRewardPerVote).div(\\r\\n                        voteInstance.resultComputation.getTotalCorrectlyVotedTokens()\\r\\n                    );\\r\\n                totalRewardToIssue = totalRewardToIssue.add(reward);\\r\\n\\r\\n                // Emit reward retrieval for this vote.\\r\\n                emit RewardsRetrieved(\\r\\n                    voterAddress,\\r\\n                    roundId,\\r\\n                    toRetrieve[i].identifier,\\r\\n                    toRetrieve[i].time,\\r\\n                    toRetrieve[i].ancillaryData,\\r\\n                    reward.rawValue\\r\\n                );\\r\\n            } else {\\r\\n                // Emit a 0 token retrieval on incorrect votes.\\r\\n                emit RewardsRetrieved(\\r\\n                    voterAddress,\\r\\n                    roundId,\\r\\n                    toRetrieve[i].identifier,\\r\\n                    toRetrieve[i].time,\\r\\n                    toRetrieve[i].ancillaryData,\\r\\n                    0\\r\\n                );\\r\\n            }\\r\\n\\r\\n            // Delete the submission to capture any refund and clean up storage.\\r\\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\\r\\n        }\\r\\n\\r\\n        // Issue any accumulated rewards.\\r\\n        if (totalRewardToIssue.isGreaterThan(0)) {\\r\\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue), \\\"Voting token issuance failed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\\r\\n    function retrieveRewards(\\r\\n        address voterAddress,\\r\\n        uint256 roundId,\\r\\n        PendingRequest[] memory toRetrieve\\r\\n    ) public override returns (FixedPoint.Unsigned memory) {\\r\\n        PendingRequestAncillary[] memory toRetrieveAncillary = new PendingRequestAncillary[](toRetrieve.length);\\r\\n\\r\\n        for (uint256 i = 0; i < toRetrieve.length; i++) {\\r\\n            toRetrieveAncillary[i].identifier = toRetrieve[i].identifier;\\r\\n            toRetrieveAncillary[i].time = toRetrieve[i].time;\\r\\n            toRetrieveAncillary[i].ancillaryData = \\\"\\\";\\r\\n        }\\r\\n\\r\\n        return retrieveRewards(voterAddress, roundId, toRetrieveAncillary);\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *        VOTING GETTER FUNCTIONS       *\\r\\n     ****************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the queries that are being voted on this round.\\r\\n     * @return pendingRequests array containing identifiers of type `PendingRequest`.\\r\\n     * and timestamps for all pending requests.\\r\\n     */\\r\\n    function getPendingRequests()\\r\\n        external\\r\\n        view\\r\\n        override(VotingInterface, VotingAncillaryInterface)\\r\\n        returns (PendingRequestAncillary[] memory)\\r\\n    {\\r\\n        uint256 blockTime = getCurrentTime();\\r\\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\\r\\n\\r\\n        // Solidity memory arrays aren't resizable (and reading storage is expensive). Hence this hackery to filter\\r\\n        // `pendingPriceRequests` only to those requests that have an Active RequestStatus.\\r\\n        PendingRequestAncillary[] memory unresolved = new PendingRequestAncillary[](pendingPriceRequests.length);\\r\\n        uint256 numUnresolved = 0;\\r\\n\\r\\n        for (uint256 i = 0; i < pendingPriceRequests.length; i++) {\\r\\n            PriceRequest storage priceRequest = priceRequests[pendingPriceRequests[i]];\\r\\n            if (_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active) {\\r\\n                unresolved[numUnresolved] = PendingRequestAncillary({\\r\\n                    identifier: priceRequest.identifier,\\r\\n                    time: priceRequest.time,\\r\\n                    ancillaryData: priceRequest.ancillaryData\\r\\n                });\\r\\n                numUnresolved++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        PendingRequestAncillary[] memory pendingRequests = new PendingRequestAncillary[](numUnresolved);\\r\\n        for (uint256 i = 0; i < numUnresolved; i++) {\\r\\n            pendingRequests[i] = unresolved[i];\\r\\n        }\\r\\n        return pendingRequests;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current voting phase, as a function of the current time.\\r\\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES_PLACEHOLDER }.\\r\\n     */\\r\\n    function getVotePhase() external view override(VotingInterface, VotingAncillaryInterface) returns (Phase) {\\r\\n        return voteTiming.computeCurrentPhase(getCurrentTime());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current round ID, as a function of the current time.\\r\\n     * @return uint256 representing the unique round ID.\\r\\n     */\\r\\n    function getCurrentRoundId() external view override(VotingInterface, VotingAncillaryInterface) returns (uint256) {\\r\\n        return voteTiming.computeCurrentRoundId(getCurrentTime());\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *        OWNER ADMIN FUNCTIONS         *\\r\\n     ****************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Disables this Voting contract in favor of the migrated one.\\r\\n     * @dev Can only be called by the contract owner.\\r\\n     * @param newVotingAddress the newly migrated contract address.\\r\\n     */\\r\\n    function setMigrated(address newVotingAddress)\\r\\n        external\\r\\n        override(VotingInterface, VotingAncillaryInterface)\\r\\n        onlyOwner\\r\\n    {\\r\\n        migratedAddress = newVotingAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\\r\\n     * @dev This method is public because calldata structs are not currently supported by solidity.\\r\\n     * @param newInflationRate sets the next round's inflation rate.\\r\\n     */\\r\\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate)\\r\\n        public\\r\\n        override(VotingInterface, VotingAncillaryInterface)\\r\\n        onlyOwner\\r\\n    {\\r\\n        inflationRate = newInflationRate;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\\r\\n     * @dev This method is public because calldata structs are not currently supported by solidity.\\r\\n     * @param newGatPercentage sets the next round's Gat percentage.\\r\\n     */\\r\\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage)\\r\\n        public\\r\\n        override(VotingInterface, VotingAncillaryInterface)\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(newGatPercentage.isLessThan(1), \\\"GAT percentage must be < 100%\\\");\\r\\n        gatPercentage = newGatPercentage;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Resets the rewards expiration timeout.\\r\\n     * @dev This change only applies to rounds that have not yet begun.\\r\\n     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\\r\\n     */\\r\\n    function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout)\\r\\n        public\\r\\n        override(VotingInterface, VotingAncillaryInterface)\\r\\n        onlyOwner\\r\\n    {\\r\\n        rewardsExpirationTimeout = NewRewardsExpirationTimeout;\\r\\n    }\\r\\n\\r\\n    /****************************************\\r\\n     *    PRIVATE AND INTERNAL FUNCTIONS    *\\r\\n     ****************************************/\\r\\n\\r\\n    // Returns the price for a given identifer. Three params are returns: bool if there was an error, int to represent\\r\\n    // the resolved price and a string which is filled with an error message, if there was an error or \\\"\\\".\\r\\n    function _getPriceOrError(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (\\r\\n            bool,\\r\\n            int256,\\r\\n            string memory\\r\\n        )\\r\\n    {\\r\\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\\r\\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\\r\\n\\r\\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\\r\\n        if (requestStatus == RequestStatus.Active) {\\r\\n            return (false, 0, \\\"Current voting round not ended\\\");\\r\\n        } else if (requestStatus == RequestStatus.Resolved) {\\r\\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\\r\\n            (, int256 resolvedPrice) =\\r\\n                voteInstance.resultComputation.getResolvedPrice(_computeGat(priceRequest.lastVotingRound));\\r\\n            return (true, resolvedPrice, \\\"\\\");\\r\\n        } else if (requestStatus == RequestStatus.Future) {\\r\\n            return (false, 0, \\\"Price is still to be voted on\\\");\\r\\n        } else {\\r\\n            return (false, 0, \\\"Price was never requested\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getPriceRequest(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData\\r\\n    ) private view returns (PriceRequest storage) {\\r\\n        return priceRequests[_encodePriceRequest(identifier, time, ancillaryData)];\\r\\n    }\\r\\n\\r\\n    function _encodePriceRequest(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData\\r\\n    ) private pure returns (bytes32) {\\r\\n        return keccak256(abi.encode(identifier, time, ancillaryData));\\r\\n    }\\r\\n\\r\\n    function _freezeRoundVariables(uint256 roundId) private {\\r\\n        Round storage round = rounds[roundId];\\r\\n        // Only on the first reveal should the snapshot be captured for that round.\\r\\n        if (round.snapshotId == 0) {\\r\\n            // There is no snapshot ID set, so create one.\\r\\n            round.snapshotId = votingToken.snapshot();\\r\\n\\r\\n            // Set the round inflation rate to the current global inflation rate.\\r\\n            rounds[roundId].inflationRate = inflationRate;\\r\\n\\r\\n            // Set the round gat percentage to the current global gat rate.\\r\\n            rounds[roundId].gatPercentage = gatPercentage;\\r\\n\\r\\n            // Set the rewards expiration time based on end of time of this round and the current global timeout.\\r\\n            rounds[roundId].rewardsExpirationTime = voteTiming.computeRoundEndTime(roundId).add(\\r\\n                rewardsExpirationTimeout\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _resolvePriceRequest(PriceRequest storage priceRequest, VoteInstance storage voteInstance) private {\\r\\n        if (priceRequest.index == UINT_MAX) {\\r\\n            return;\\r\\n        }\\r\\n        (bool isResolved, int256 resolvedPrice) =\\r\\n            voteInstance.resultComputation.getResolvedPrice(_computeGat(priceRequest.lastVotingRound));\\r\\n        require(isResolved, \\\"Can't resolve unresolved request\\\");\\r\\n\\r\\n        // Delete the resolved price request from pendingPriceRequests.\\r\\n        uint256 lastIndex = pendingPriceRequests.length - 1;\\r\\n        PriceRequest storage lastPriceRequest = priceRequests[pendingPriceRequests[lastIndex]];\\r\\n        lastPriceRequest.index = priceRequest.index;\\r\\n        pendingPriceRequests[priceRequest.index] = pendingPriceRequests[lastIndex];\\r\\n        pendingPriceRequests.pop();\\r\\n\\r\\n        priceRequest.index = UINT_MAX;\\r\\n        emit PriceResolved(\\r\\n            priceRequest.lastVotingRound,\\r\\n            priceRequest.identifier,\\r\\n            priceRequest.time,\\r\\n            resolvedPrice,\\r\\n            priceRequest.ancillaryData\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _computeGat(uint256 roundId) private view returns (FixedPoint.Unsigned memory) {\\r\\n        uint256 snapshotId = rounds[roundId].snapshotId;\\r\\n        if (snapshotId == 0) {\\r\\n            // No snapshot - return max value to err on the side of caution.\\r\\n            return FixedPoint.Unsigned(UINT_MAX);\\r\\n        }\\r\\n\\r\\n        // Grab the snapshotted supply from the voting token. It's already scaled by 10**18, so we can directly\\r\\n        // initialize the Unsigned value with the returned uint.\\r\\n        FixedPoint.Unsigned memory snapshottedSupply = FixedPoint.Unsigned(votingToken.totalSupplyAt(snapshotId));\\r\\n\\r\\n        // Multiply the total supply at the snapshot by the gatPercentage to get the GAT in number of tokens.\\r\\n        return snapshottedSupply.mul(rounds[roundId].gatPercentage);\\r\\n    }\\r\\n\\r\\n    function _getRequestStatus(PriceRequest storage priceRequest, uint256 currentRoundId)\\r\\n        private\\r\\n        view\\r\\n        returns (RequestStatus)\\r\\n    {\\r\\n        if (priceRequest.lastVotingRound == 0) {\\r\\n            return RequestStatus.NotRequested;\\r\\n        } else if (priceRequest.lastVotingRound < currentRoundId) {\\r\\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\\r\\n            (bool isResolved, ) =\\r\\n                voteInstance.resultComputation.getResolvedPrice(_computeGat(priceRequest.lastVotingRound));\\r\\n            return isResolved ? RequestStatus.Resolved : RequestStatus.Active;\\r\\n        } else if (priceRequest.lastVotingRound == currentRoundId) {\\r\\n            return RequestStatus.Active;\\r\\n        } else {\\r\\n            // Means than priceRequest.lastVotingRound > currentRoundId\\r\\n            return RequestStatus.Future;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface supportedIdentifiers) {\\r\\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x21e3d2839bb5b7383c7346483f4d20a393594e4d2df2fbe87b70f4d42ce2db19\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/implementation/VotingToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../common/implementation/ExpandedERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Ownership of this token allows a voter to respond to price requests.\\r\\n * @dev Supports snapshotting and allows the Oracle to mint new tokens as rewards.\\r\\n */\\r\\ncontract VotingToken is ExpandedERC20, ERC20Snapshot {\\r\\n    /**\\r\\n     * @notice Constructs the VotingToken.\\r\\n     */\\r\\n    constructor() ExpandedERC20(\\\"UMA Voting Token v1\\\", \\\"UMA\\\", 18) ERC20Snapshot() {}\\r\\n\\r\\n    function decimals() public view virtual override(ERC20, ExpandedERC20) returns (uint8) {\\r\\n        return super.decimals();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Creates a new snapshot ID.\\r\\n     * @return uint256 Thew new snapshot ID.\\r\\n     */\\r\\n    function snapshot() external returns (uint256) {\\r\\n        return _snapshot();\\r\\n    }\\r\\n\\r\\n    // _transfer, _mint and _burn are ERC20 internal methods that are overridden by ERC20Snapshot,\\r\\n    // therefore the compiler will complain that VotingToken must override these methods\\r\\n    // because the two base classes (ERC20 and ERC20Snapshot) both define the same functions\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal override(ERC20) {\\r\\n        super._transfer(from, to, value);\\r\\n    }\\r\\n\\r\\n    function _mint(address account, uint256 value) internal virtual override(ERC20) {\\r\\n        super._mint(account, value);\\r\\n    }\\r\\n\\r\\n    function _burn(address account, uint256 value) internal virtual override(ERC20) {\\r\\n        super._burn(account, value);\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual override(ERC20, ERC20Snapshot) {\\r\\n        super._beforeTokenTransfer(from, to, amount);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x4707515b6e776a1a31b8b38c0e3d15d7337da7f2cc80b34b984aa8252690e95c\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/interfaces/FinderInterface.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Provides addresses of the live contracts implementing certain interfaces.\\r\\n * @dev Examples are the Oracle or Store interfaces.\\r\\n */\\r\\ninterface FinderInterface {\\r\\n    /**\\r\\n     * @notice Updates the address of the contract that implements `interfaceName`.\\r\\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\\r\\n     * @param implementationAddress address of the deployed contract that implements the interface.\\r\\n     */\\r\\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\\r\\n     * @param interfaceName queried interface.\\r\\n     * @return implementationAddress address of the deployed contract that implements the interface.\\r\\n     */\\r\\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\\r\\n}\\r\\n\",\"keccak256\":\"0xad6668a10f243739d0bf5d077954119434f7b2cda129cb484ad6d359d158e5ec\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Interface for whitelists of supported identifiers that the oracle can provide prices for.\\r\\n */\\r\\ninterface IdentifierWhitelistInterface {\\r\\n    /**\\r\\n     * @notice Adds the provided identifier as a supported identifier.\\r\\n     * @dev Price requests using this identifier will succeed after this call.\\r\\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\\r\\n     */\\r\\n    function addSupportedIdentifier(bytes32 identifier) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Removes the identifier from the whitelist.\\r\\n     * @dev Price requests using this identifier will no longer succeed after this call.\\r\\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\\r\\n     */\\r\\n    function removeSupportedIdentifier(bytes32 identifier) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Checks whether an identifier is on the whitelist.\\r\\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\\r\\n     * @return bool if the identifier is supported (or not).\\r\\n     */\\r\\n    function isIdentifierSupported(bytes32 identifier) external view returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x811cd273221c05eb94521f808a5603e3d12020336e4021c4ab93d188973fcee9\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Financial contract facing Oracle interface.\\r\\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\\r\\n */\\r\\nabstract contract OracleAncillaryInterface {\\r\\n    /**\\r\\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\\r\\n     * @dev Time must be in the past and the identifier must be supported.\\r\\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\\r\\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\r\\n     * @param time unix timestamp for the price request.\\r\\n     */\\r\\n\\r\\n    function requestPrice(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData\\r\\n    ) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Whether the price for `identifier` and `time` is available.\\r\\n     * @dev Time must be in the past and the identifier must be supported.\\r\\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\\r\\n     * @param time unix timestamp for the price request.\\r\\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\r\\n     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\\r\\n     */\\r\\n    function hasPrice(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData\\r\\n    ) public view virtual returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\\r\\n     * @dev If the price is not available, the method reverts.\\r\\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\\r\\n     * @param time unix timestamp for the price request.\\r\\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\\r\\n     * @return int256 representing the resolved price for the given identifier and timestamp.\\r\\n     */\\r\\n\\r\\n    function getPrice(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData\\r\\n    ) public view virtual returns (int256);\\r\\n}\\r\\n\",\"keccak256\":\"0x527e51a47c25f533cee60d7e2e2410b3d6a16b8dbdeca7d3fd734fabf76a109a\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/interfaces/OracleInterface.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Financial contract facing Oracle interface.\\r\\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\\r\\n */\\r\\nabstract contract OracleInterface {\\r\\n    /**\\r\\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\\r\\n     * @dev Time must be in the past and the identifier must be supported.\\r\\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\\r\\n     * @param time unix timestamp for the price request.\\r\\n     */\\r\\n    function requestPrice(bytes32 identifier, uint256 time) external virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Whether the price for `identifier` and `time` is available.\\r\\n     * @dev Time must be in the past and the identifier must be supported.\\r\\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\\r\\n     * @param time unix timestamp for the price request.\\r\\n     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\\r\\n     */\\r\\n    function hasPrice(bytes32 identifier, uint256 time) external view virtual returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\\r\\n     * @dev If the price is not available, the method reverts.\\r\\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\\r\\n     * @param time unix timestamp for the price request.\\r\\n     * @return int256 representing the resolved price for the given identifier and timestamp.\\r\\n     */\\r\\n    function getPrice(bytes32 identifier, uint256 time) external view virtual returns (int256);\\r\\n}\\r\\n\",\"keccak256\":\"0xa135756eabf06899395052031d8a2f617ef504477dc3037585f2b4ce0e3da22a\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/interfaces/RegistryInterface.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Interface for a registry of contracts and contract creators.\\r\\n */\\r\\ninterface RegistryInterface {\\r\\n    /**\\r\\n     * @notice Registers a new contract.\\r\\n     * @dev Only authorized contract creators can call this method.\\r\\n     * @param parties an array of addresses who become parties in the contract.\\r\\n     * @param contractAddress defines the address of the deployed contract.\\r\\n     */\\r\\n    function registerContract(address[] calldata parties, address contractAddress) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns whether the contract has been registered with the registry.\\r\\n     * @dev If it is registered, it is an authorized participant in the UMA system.\\r\\n     * @param contractAddress address of the contract.\\r\\n     * @return bool indicates whether the contract is registered.\\r\\n     */\\r\\n    function isContractRegistered(address contractAddress) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns a list of all contracts that are associated with a particular party.\\r\\n     * @param party address of the party.\\r\\n     * @return an array of the contracts the party is registered to.\\r\\n     */\\r\\n    function getRegisteredContracts(address party) external view returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns all registered contracts.\\r\\n     * @return all registered contract addresses within the system.\\r\\n     */\\r\\n    function getAllRegisteredContracts() external view returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a party to the calling contract.\\r\\n     * @dev msg.sender must be the contract to which the party member is added.\\r\\n     * @param party address to be added to the contract.\\r\\n     */\\r\\n    function addPartyToContract(address party) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Removes a party member to the calling contract.\\r\\n     * @dev msg.sender must be the contract to which the party member is added.\\r\\n     * @param party address to be removed from the contract.\\r\\n     */\\r\\n    function removePartyFromContract(address party) external;\\r\\n\\r\\n    /**\\r\\n     * @notice checks if an address is a party in a contract.\\r\\n     * @param party party to check.\\r\\n     * @param contractAddress address to check against the party.\\r\\n     * @return bool indicating if the address is a party of the contract.\\r\\n     */\\r\\n    function isPartyMemberOfContract(address party, address contractAddress) external view returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0xea7f5a5abd024662fa3a79a23823710b36ce5b9e72381716bdd4697d4b9cb403\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/interfaces/VotingAncillaryInterface.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../common/implementation/FixedPoint.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Interface that voters must use to Vote on price request resolutions.\\r\\n */\\r\\nabstract contract VotingAncillaryInterface {\\r\\n    struct PendingRequestAncillary {\\r\\n        bytes32 identifier;\\r\\n        uint256 time;\\r\\n        bytes ancillaryData;\\r\\n    }\\r\\n\\r\\n    // Captures the necessary data for making a commitment.\\r\\n    // Used as a parameter when making batch commitments.\\r\\n    // Not used as a data structure for storage.\\r\\n    struct CommitmentAncillary {\\r\\n        bytes32 identifier;\\r\\n        uint256 time;\\r\\n        bytes ancillaryData;\\r\\n        bytes32 hash;\\r\\n        bytes encryptedVote;\\r\\n    }\\r\\n\\r\\n    // Captures the necessary data for revealing a vote.\\r\\n    // Used as a parameter when making batch reveals.\\r\\n    // Not used as a data structure for storage.\\r\\n    struct RevealAncillary {\\r\\n        bytes32 identifier;\\r\\n        uint256 time;\\r\\n        int256 price;\\r\\n        bytes ancillaryData;\\r\\n        int256 salt;\\r\\n    }\\r\\n\\r\\n    // Note: the phases must be in order. Meaning the first enum value must be the first phase, etc.\\r\\n    // `NUM_PHASES` is to get the number of phases. It isn't an actual phase, and it should always be last.\\r\\n    enum Phase { Commit, Reveal, NUM_PHASES }\\r\\n\\r\\n    /**\\r\\n     * @notice Commit a vote for a price request for `identifier` at `time`.\\r\\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\\r\\n     * Commits can be changed.\\r\\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the system\\u2019s expected behavior,\\r\\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\\r\\n     * they can determine the vote pre-reveal.\\r\\n     * @param identifier uniquely identifies the committed vote. E.G. BTC/USD price pair.\\r\\n     * @param time unix timestamp of the price being voted on.\\r\\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\\r\\n     */\\r\\n    function commitVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData,\\r\\n        bytes32 hash\\r\\n    ) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Submit a batch of commits in a single transaction.\\r\\n     * @dev Using `encryptedVote` is optional. If included then commitment is stored on chain.\\r\\n     * Look at `project-root/common/Constants.js` for the tested maximum number of\\r\\n     * commitments that can fit in one transaction.\\r\\n     * @param commits array of structs that encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\\r\\n     */\\r\\n    function batchCommit(CommitmentAncillary[] memory commits) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\\r\\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\\r\\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\\r\\n     * @param identifier unique price pair identifier. E.g. BTC/USD price pair.\\r\\n     * @param time unix timestamp of for the price request.\\r\\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\\r\\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\\r\\n     */\\r\\n    function commitAndEmitEncryptedVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes memory ancillaryData,\\r\\n        bytes32 hash,\\r\\n        bytes memory encryptedVote\\r\\n    ) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice snapshot the current round's token balances and lock in the inflation rate and GAT.\\r\\n     * @dev This function can be called multiple times but each round will only every have one snapshot at the\\r\\n     * time of calling `_freezeRoundVariables`.\\r\\n     * @param signature  signature required to prove caller is an EOA to prevent flash loans from being included in the\\r\\n     * snapshot.\\r\\n     */\\r\\n    function snapshotCurrentRound(bytes calldata signature) external virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\\r\\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\\r\\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\\r\\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\\r\\n     * @param time specifies the unix timestamp of the price is being voted on.\\r\\n     * @param price voted on during the commit phase.\\r\\n     * @param salt value used to hide the commitment price during the commit phase.\\r\\n     */\\r\\n    function revealVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        int256 price,\\r\\n        bytes memory ancillaryData,\\r\\n        int256 salt\\r\\n    ) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Reveal multiple votes in a single transaction.\\r\\n     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\\r\\n     * that can fit in one transaction.\\r\\n     * @dev For more information on reveals, review the comment for `revealVote`.\\r\\n     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\\r\\n     */\\r\\n    function batchReveal(RevealAncillary[] memory reveals) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the queries that are being voted on this round.\\r\\n     * @return pendingRequests `PendingRequest` array containing identifiers\\r\\n     * and timestamps for all pending requests.\\r\\n     */\\r\\n    function getPendingRequests() external view virtual returns (PendingRequestAncillary[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current voting phase, as a function of the current time.\\r\\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES }.\\r\\n     */\\r\\n    function getVotePhase() external view virtual returns (Phase);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current round ID, as a function of the current time.\\r\\n     * @return uint256 representing the unique round ID.\\r\\n     */\\r\\n    function getCurrentRoundId() external view virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves rewards owed for a set of resolved price requests.\\r\\n     * @dev Can only retrieve rewards if calling for a valid round and if the\\r\\n     * call is done within the timeout threshold (not expired).\\r\\n     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\\r\\n     * @param roundId the round from which voting rewards will be retrieved from.\\r\\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\\r\\n     * @return total amount of rewards returned to the voter.\\r\\n     */\\r\\n    function retrieveRewards(\\r\\n        address voterAddress,\\r\\n        uint256 roundId,\\r\\n        PendingRequestAncillary[] memory toRetrieve\\r\\n    ) public virtual returns (FixedPoint.Unsigned memory);\\r\\n\\r\\n    // Voting Owner functions.\\r\\n\\r\\n    /**\\r\\n     * @notice Disables this Voting contract in favor of the migrated one.\\r\\n     * @dev Can only be called by the contract owner.\\r\\n     * @param newVotingAddress the newly migrated contract address.\\r\\n     */\\r\\n    function setMigrated(address newVotingAddress) external virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\\r\\n     * @dev This method is public because calldata structs are not currently supported by solidity.\\r\\n     * @param newInflationRate sets the next round's inflation rate.\\r\\n     */\\r\\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\\r\\n     * @dev This method is public because calldata structs are not currently supported by solidity.\\r\\n     * @param newGatPercentage sets the next round's Gat percentage.\\r\\n     */\\r\\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Resets the rewards expiration timeout.\\r\\n     * @dev This change only applies to rounds that have not yet begun.\\r\\n     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\\r\\n     */\\r\\n    function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout) public virtual;\\r\\n}\\r\\n\",\"keccak256\":\"0x975892765f628db8ba5904ec9f02ae98ea9d3e01258122d0014e36e8dfa843d1\",\"license\":\"AGPL-3.0-only\"},\"contracts/data-verification-mechanism/interfaces/VotingInterface.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../common/implementation/FixedPoint.sol\\\";\\r\\nimport \\\"./VotingAncillaryInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Interface that voters must use to Vote on price request resolutions.\\r\\n */\\r\\nabstract contract VotingInterface {\\r\\n    struct PendingRequest {\\r\\n        bytes32 identifier;\\r\\n        uint256 time;\\r\\n    }\\r\\n\\r\\n    // Captures the necessary data for making a commitment.\\r\\n    // Used as a parameter when making batch commitments.\\r\\n    // Not used as a data structure for storage.\\r\\n    struct Commitment {\\r\\n        bytes32 identifier;\\r\\n        uint256 time;\\r\\n        bytes32 hash;\\r\\n        bytes encryptedVote;\\r\\n    }\\r\\n\\r\\n    // Captures the necessary data for revealing a vote.\\r\\n    // Used as a parameter when making batch reveals.\\r\\n    // Not used as a data structure for storage.\\r\\n    struct Reveal {\\r\\n        bytes32 identifier;\\r\\n        uint256 time;\\r\\n        int256 price;\\r\\n        int256 salt;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Commit a vote for a price request for `identifier` at `time`.\\r\\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\\r\\n     * Commits can be changed.\\r\\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the system\\u2019s expected behavior,\\r\\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\\r\\n     * they can determine the vote pre-reveal.\\r\\n     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\\r\\n     * @param time unix timestamp of the price being voted on.\\r\\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\\r\\n     */\\r\\n    function commitVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes32 hash\\r\\n    ) external virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Submit a batch of commits in a single transaction.\\r\\n     * @dev Using `encryptedVote` is optional. If included then commitment is stored on chain.\\r\\n     * Look at `project-root/common/Constants.js` for the tested maximum number of\\r\\n     * commitments that can fit in one transaction.\\r\\n     * @param commits array of structs that encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\\r\\n     */\\r\\n    function batchCommit(Commitment[] memory commits) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\\r\\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\\r\\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\\r\\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\\r\\n     * @param time unix timestamp of for the price request.\\r\\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\\r\\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\\r\\n     */\\r\\n    function commitAndEmitEncryptedVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        bytes32 hash,\\r\\n        bytes memory encryptedVote\\r\\n    ) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice snapshot the current round's token balances and lock in the inflation rate and GAT.\\r\\n     * @dev This function can be called multiple times but each round will only every have one snapshot at the\\r\\n     * time of calling `_freezeRoundVariables`.\\r\\n     * @param signature  signature required to prove caller is an EOA to prevent flash loans from being included in the\\r\\n     * snapshot.\\r\\n     */\\r\\n    function snapshotCurrentRound(bytes calldata signature) external virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\\r\\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\\r\\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\\r\\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\\r\\n     * @param time specifies the unix timestamp of the price is being voted on.\\r\\n     * @param price voted on during the commit phase.\\r\\n     * @param salt value used to hide the commitment price during the commit phase.\\r\\n     */\\r\\n    function revealVote(\\r\\n        bytes32 identifier,\\r\\n        uint256 time,\\r\\n        int256 price,\\r\\n        int256 salt\\r\\n    ) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Reveal multiple votes in a single transaction.\\r\\n     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\\r\\n     * that can fit in one transaction.\\r\\n     * @dev For more information on reveals, review the comment for `revealVote`.\\r\\n     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\\r\\n     */\\r\\n    function batchReveal(Reveal[] memory reveals) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the queries that are being voted on this round.\\r\\n     * @return pendingRequests `PendingRequest` array containing identifiers\\r\\n     * and timestamps for all pending requests.\\r\\n     */\\r\\n    function getPendingRequests()\\r\\n        external\\r\\n        view\\r\\n        virtual\\r\\n        returns (VotingAncillaryInterface.PendingRequestAncillary[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current voting phase, as a function of the current time.\\r\\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES }.\\r\\n     */\\r\\n    function getVotePhase() external view virtual returns (VotingAncillaryInterface.Phase);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current round ID, as a function of the current time.\\r\\n     * @return uint256 representing the unique round ID.\\r\\n     */\\r\\n    function getCurrentRoundId() external view virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves rewards owed for a set of resolved price requests.\\r\\n     * @dev Can only retrieve rewards if calling for a valid round and if the\\r\\n     * call is done within the timeout threshold (not expired).\\r\\n     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\\r\\n     * @param roundId the round from which voting rewards will be retrieved from.\\r\\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\\r\\n     * @return total amount of rewards returned to the voter.\\r\\n     */\\r\\n    function retrieveRewards(\\r\\n        address voterAddress,\\r\\n        uint256 roundId,\\r\\n        PendingRequest[] memory toRetrieve\\r\\n    ) public virtual returns (FixedPoint.Unsigned memory);\\r\\n\\r\\n    // Voting Owner functions.\\r\\n\\r\\n    /**\\r\\n     * @notice Disables this Voting contract in favor of the migrated one.\\r\\n     * @dev Can only be called by the contract owner.\\r\\n     * @param newVotingAddress the newly migrated contract address.\\r\\n     */\\r\\n    function setMigrated(address newVotingAddress) external virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\\r\\n     * @dev This method is public because calldata structs are not currently supported by solidity.\\r\\n     * @param newInflationRate sets the next round's inflation rate.\\r\\n     */\\r\\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\\r\\n     * @dev This method is public because calldata structs are not currently supported by solidity.\\r\\n     * @param newGatPercentage sets the next round's Gat percentage.\\r\\n     */\\r\\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage) public virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Resets the rewards expiration timeout.\\r\\n     * @dev This change only applies to rounds that have not yet begun.\\r\\n     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\\r\\n     */\\r\\n    function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout) public virtual;\\r\\n}\\r\\n\",\"keccak256\":\"0x724237fe6b7495b24d558f11d76855ad18729262fbd68be2e59d2773a08a5c15\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x608034620001f057601f6200127f38819003918201601f191683019291906001600160401b03841183851017620001f5578160a09284926040968752833981010312620001f05780516001600160a01b039081811690819003620001f0576020830151908484015193838516809503620001f057606081015190848216809203620001f05760800151938416809403620001f0576200009e3362000264565b600160a01b809460018060a81b03196001541617179160018060a01b03199081600254161760025585816004541617600455600554161760055560ff8160a01c1615620001ac5760ff60a01b19166001819055907f1b44689fb73c0c9cdf591d534287488fc7959fd3647346821063a3e567ec9a9990602090620001216200020b565b806003558651908152a117600155620001396200020b565b801562000159576200014b9062000264565b51610fce9081620002b18239f35b815162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608490fd5b845162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b600080fd5b634e487b7160e01b600052604160045260246000fd5b6000546001600160a01b031633036200022057565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b600080546001600160a01b039283166001600160a01b03198216811783556040519093909116917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a356fe6040608081526004908136101561001557600080fd5b600091823560e01c90816262804e146107e55781630c340a24146107bd57816311a9b77b1461076e5781631c39c38d1461074557816322f8e566146106d2578163259bd9201461066657816329cb924d1461064257816364c9ec6f14610623578163715018a6146105c65781638da5cb5b1461059e578163b9a3c84c14610575578163c62fdef7146101bf578163f2fde38b146100e7575063fc0c546a146100bc57600080fd5b346100e357816003193601126100e35760025490516001600160a01b039091168152602090f35b5080fd5b9050346101bb5760203660031901126101bb576001600160a01b03813581811692908390036101b657610118610b83565b8215610164575060005492826bffffffffffffffffffffffff60a01b8516176000555192167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600084a3f35b608490602085519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152fd5b600080fd5b8280fd5b919050346101bb57602092836003193601126103c357823567ffffffffffffffff918282116103c357366023830112156103c35781850135838111610562578060051b9085519061021289840183610b45565b81528781019384602480948301019136831161055e57848101915b8383106104895750505050610240610e66565b60ff60a01b19938760019686885416885560018060a01b038b818454168b519c8d809263400e394960e01b82525afa9a8b1561047f57879b610450575b508b81600254166003548c51926323b872dd60e01b90840152338984015230604484015260648301526064825260a082018281108582111761043c578c526102c59190610cae565b600354826102d1610bdb565b16908b51916060948584019084821090821117610428578d52338352828f01908152828d019182528d8a5260068f528c8a209251835491516001600160e01b03199092169085161760a09190911b67ffffffffffffffff60a01b1617825551908a01558254811694853b1561042457928a8d9795939288938a989683519a8b9963c62fdef760e01b8b528a01958a01525180945260448801918d60448660051b8b010197968b955b8787106103d0575050505050505050508383809203925af180156103c6576103af575b5050815416600160a01b17905551908152f35b6103b98291610b1b565b6103c3578061039c565b80fd5b85513d84823e3d90fd5b909380979a9c508493969981838b9e9b61040b96999c604319908503018d52518a815116845287810151888501520151938201520190610c56565b9801940194019093899795928f958d8f978c9a98610379565b8780fd5b89604188634e487b7160e01b600052526000fd5b88604187634e487b7160e01b600052526000fd5b909a508b81813d8311610478575b6104688183610b45565b810103126101b65751993861027d565b503d61045e565b8a513d89823e3d90fd5b8235898111610424578201606090816023198236030112610542578b519182018281108c82111761054a578c52808801356001600160a01b03811681036101b657825260448101358e8301526064810135908b82116105465701366043820112156105425780888d9201359061050a61050183610b67565b93519384610b45565b818352366044838301011161053e57918f9492858381969460448f940183860137830101528d82015281520192019161022d565b8a80fd5b8880fd5b8980fd5b8860418f634e487b7160e01b600052526000fd5b8580fd5b634e487b7160e01b825260418652602482fd5b5050346100e357816003193601126100e35760055490516001600160a01b039091168152602090f35b5050346100e357816003193601126100e357905490516001600160a01b039091168152602090f35b5050346100e357816003193601126100e3576105e0610b83565b600080546001600160a01b0319811682559151916001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08284a3f35b5050346100e357816003193601126100e3576020906003549051908152f35b5050346100e357816003193601126100e35760209061065f610bdb565b9051908152f35b9050346101bb5760203660031901126101bb5735610682610e66565b7f1b44689fb73c0c9cdf591d534287488fc7959fd3647346821063a3e567ec9a99602060ff60a01b196001541692836001556106bc610b83565b806003558451908152a1600160a01b1760015551f35b839150346100e35760203660031901126100e3576001546001600160a01b03169081156101bb57813b156101bb578291602483928651948593849263117c72b360e11b84528035908401525af1801561073b5761072e57509051f35b61073790610b1b565b9051f35b83513d84823e3d90fd5b5050346100e357816003193601126100e35760015490516001600160a01b039091168152602090f35b9050346101bb5760203660031901126101bb57606092829135815260066020522090600182549201549067ffffffffffffffff81519360018060a01b038116855260a01c166020840152820152f35b9050346101bb57826003193601126101bb575490516001600160a01b03909116815260209150f35b9050346101bb57602080600319360112610b1757813591610804610e66565b6001805460ff60a01b1990811682558487526006845285872060055487516302abf57960e61b808252654f7261636c6560d01b82880152949793966001600160a01b0396909592871692918a908c908881602481895afa90811561073b578a9291610afa575b50168c6108c88961087a8a610f2c565b9467ffffffffffffffff8a5460a01c16958691519384928392630b551cd560e41b84528a84019060809267ffffffffffffffff91835216602082015260606040820152600060608201520190565b0381865afa918215610aef5791610ac2575b5015610a8b5761092d9188918d6108f08a610f2c565b90518095819482936338ce36ab60e11b84528984019060809267ffffffffffffffff91835216602082015260606040820152600060608201520190565b03915afa908115610a81578c91610a50575b50156109a857505050836109629187600696600254169282541691015491610eda565b807fdb53c862706d03ae7c85dcaa4fd1aa1df7fa8914c2b999a15b37e280bf5a207c838851888152a25b8652528284208481558201849055815416600160a01b17905551f35b60248692939760025416938b51988993849283526453746f726560d81b908301525afa8015610a4657876109e9936006978c93610a17575b50015491610eda565b807fdb53c862706d03ae7c85dcaa4fd1aa1df7fa8914c2b999a15b37e280bf5a207c8388518a8152a261098c565b610a38919350873d8911610a3f575b610a308183610b45565b810190610ebb565b91386109e0565b503d610a26565b88513d8b823e3d90fd5b90508681813d8311610a7a575b610a678183610b45565b81010312610a7657513861093f565b8b80fd5b503d610a5d565b8b513d8e823e3d90fd5b8b5162461bcd60e51b81528084018990526011602482015270139bc81c1c9a58d9481c995cdbdb1d9959607a1b6044820152606490fd5b610ae29150893d8b11610ae8575b610ada8183610b45565b810190610c96565b386108da565b503d610ad0565b8e51903d90823e3d90fd5b610b119150893d8b11610a3f57610a308183610b45565b3861086a565b8380fd5b67ffffffffffffffff8111610b2f57604052565b634e487b7160e01b600052604160045260246000fd5b90601f8019910116810190811067ffffffffffffffff821117610b2f57604052565b67ffffffffffffffff8111610b2f57601f01601f191660200190565b6000546001600160a01b03163303610b9757565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b6001546001600160a01b03168015610c51576020600491604051928380926329cb924d60e01b82525afa908115610c4557600091610c17575090565b906020823d8211610c3d575b81610c3060209383610b45565b810103126103c357505190565b3d9150610c23565b6040513d6000823e3d90fd5b504290565b919082519283825260005b848110610c82575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201610c61565b908160209103126101b6575180151581036101b65790565b60408051908101916001600160a01b031667ffffffffffffffff831182841017610b2f57610d3d926040526000806020958685527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656487860152868151910182855af13d15610dc5573d91610d2183610b67565b92610d2f6040519485610b45565b83523d60008785013e610dc9565b805190828215928315610dad575b50505015610d565750565b6084906040519062461bcd60e51b82526004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152fd5b610dbd9350820181019101610c96565b388281610d4b565b6060915b91929015610e2b5750815115610ddd575090565b3b15610de65790565b60405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606490fd5b825190915015610e3e5750805190602001fd5b60405162461bcd60e51b815260206004820152908190610e62906024830190610c56565b0390fd5b60ff60015460a01c1615610e7657565b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b908160209103126101b657516001600160a01b03811681036101b65790565b60405163a9059cbb60e01b60208201526001600160a01b039092166024830152604480830193909352918152608081019167ffffffffffffffff831182841017610b2f57610f2a92604052610cae565b565b600090819080610f515750600360fc1b9150505b60301c65020b236b4b7160d51b1790565b90815b610f5f575050610f40565b9091600a9081840660308101809111610f845760f81b9060081c179204809190610f54565b634e487b7160e01b84526011600452602484fdfea2646970667358221220ca86359fc6da32228ba85f684c1045223cd676b09343afb8e3eb37aaaf8526a764736f6c63430008100033",
  "deployedBytecode": "0x6040608081526004908136101561001557600080fd5b600091823560e01c90816262804e146107e55781630c340a24146107bd57816311a9b77b1461076e5781631c39c38d1461074557816322f8e566146106d2578163259bd9201461066657816329cb924d1461064257816364c9ec6f14610623578163715018a6146105c65781638da5cb5b1461059e578163b9a3c84c14610575578163c62fdef7146101bf578163f2fde38b146100e7575063fc0c546a146100bc57600080fd5b346100e357816003193601126100e35760025490516001600160a01b039091168152602090f35b5080fd5b9050346101bb5760203660031901126101bb576001600160a01b03813581811692908390036101b657610118610b83565b8215610164575060005492826bffffffffffffffffffffffff60a01b8516176000555192167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600084a3f35b608490602085519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152fd5b600080fd5b8280fd5b919050346101bb57602092836003193601126103c357823567ffffffffffffffff918282116103c357366023830112156103c35781850135838111610562578060051b9085519061021289840183610b45565b81528781019384602480948301019136831161055e57848101915b8383106104895750505050610240610e66565b60ff60a01b19938760019686885416885560018060a01b038b818454168b519c8d809263400e394960e01b82525afa9a8b1561047f57879b610450575b508b81600254166003548c51926323b872dd60e01b90840152338984015230604484015260648301526064825260a082018281108582111761043c578c526102c59190610cae565b600354826102d1610bdb565b16908b51916060948584019084821090821117610428578d52338352828f01908152828d019182528d8a5260068f528c8a209251835491516001600160e01b03199092169085161760a09190911b67ffffffffffffffff60a01b1617825551908a01558254811694853b1561042457928a8d9795939288938a989683519a8b9963c62fdef760e01b8b528a01958a01525180945260448801918d60448660051b8b010197968b955b8787106103d0575050505050505050508383809203925af180156103c6576103af575b5050815416600160a01b17905551908152f35b6103b98291610b1b565b6103c3578061039c565b80fd5b85513d84823e3d90fd5b909380979a9c508493969981838b9e9b61040b96999c604319908503018d52518a815116845287810151888501520151938201520190610c56565b9801940194019093899795928f958d8f978c9a98610379565b8780fd5b89604188634e487b7160e01b600052526000fd5b88604187634e487b7160e01b600052526000fd5b909a508b81813d8311610478575b6104688183610b45565b810103126101b65751993861027d565b503d61045e565b8a513d89823e3d90fd5b8235898111610424578201606090816023198236030112610542578b519182018281108c82111761054a578c52808801356001600160a01b03811681036101b657825260448101358e8301526064810135908b82116105465701366043820112156105425780888d9201359061050a61050183610b67565b93519384610b45565b818352366044838301011161053e57918f9492858381969460448f940183860137830101528d82015281520192019161022d565b8a80fd5b8880fd5b8980fd5b8860418f634e487b7160e01b600052526000fd5b8580fd5b634e487b7160e01b825260418652602482fd5b5050346100e357816003193601126100e35760055490516001600160a01b039091168152602090f35b5050346100e357816003193601126100e357905490516001600160a01b039091168152602090f35b5050346100e357816003193601126100e3576105e0610b83565b600080546001600160a01b0319811682559151916001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08284a3f35b5050346100e357816003193601126100e3576020906003549051908152f35b5050346100e357816003193601126100e35760209061065f610bdb565b9051908152f35b9050346101bb5760203660031901126101bb5735610682610e66565b7f1b44689fb73c0c9cdf591d534287488fc7959fd3647346821063a3e567ec9a99602060ff60a01b196001541692836001556106bc610b83565b806003558451908152a1600160a01b1760015551f35b839150346100e35760203660031901126100e3576001546001600160a01b03169081156101bb57813b156101bb578291602483928651948593849263117c72b360e11b84528035908401525af1801561073b5761072e57509051f35b61073790610b1b565b9051f35b83513d84823e3d90fd5b5050346100e357816003193601126100e35760015490516001600160a01b039091168152602090f35b9050346101bb5760203660031901126101bb57606092829135815260066020522090600182549201549067ffffffffffffffff81519360018060a01b038116855260a01c166020840152820152f35b9050346101bb57826003193601126101bb575490516001600160a01b03909116815260209150f35b9050346101bb57602080600319360112610b1757813591610804610e66565b6001805460ff60a01b1990811682558487526006845285872060055487516302abf57960e61b808252654f7261636c6560d01b82880152949793966001600160a01b0396909592871692918a908c908881602481895afa90811561073b578a9291610afa575b50168c6108c88961087a8a610f2c565b9467ffffffffffffffff8a5460a01c16958691519384928392630b551cd560e41b84528a84019060809267ffffffffffffffff91835216602082015260606040820152600060608201520190565b0381865afa918215610aef5791610ac2575b5015610a8b5761092d9188918d6108f08a610f2c565b90518095819482936338ce36ab60e11b84528984019060809267ffffffffffffffff91835216602082015260606040820152600060608201520190565b03915afa908115610a81578c91610a50575b50156109a857505050836109629187600696600254169282541691015491610eda565b807fdb53c862706d03ae7c85dcaa4fd1aa1df7fa8914c2b999a15b37e280bf5a207c838851888152a25b8652528284208481558201849055815416600160a01b17905551f35b60248692939760025416938b51988993849283526453746f726560d81b908301525afa8015610a4657876109e9936006978c93610a17575b50015491610eda565b807fdb53c862706d03ae7c85dcaa4fd1aa1df7fa8914c2b999a15b37e280bf5a207c8388518a8152a261098c565b610a38919350873d8911610a3f575b610a308183610b45565b810190610ebb565b91386109e0565b503d610a26565b88513d8b823e3d90fd5b90508681813d8311610a7a575b610a678183610b45565b81010312610a7657513861093f565b8b80fd5b503d610a5d565b8b513d8e823e3d90fd5b8b5162461bcd60e51b81528084018990526011602482015270139bc81c1c9a58d9481c995cdbdb1d9959607a1b6044820152606490fd5b610ae29150893d8b11610ae8575b610ada8183610b45565b810190610c96565b386108da565b503d610ad0565b8e51903d90823e3d90fd5b610b119150893d8b11610a3f57610a308183610b45565b3861086a565b8380fd5b67ffffffffffffffff8111610b2f57604052565b634e487b7160e01b600052604160045260246000fd5b90601f8019910116810190811067ffffffffffffffff821117610b2f57604052565b67ffffffffffffffff8111610b2f57601f01601f191660200190565b6000546001600160a01b03163303610b9757565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b6001546001600160a01b03168015610c51576020600491604051928380926329cb924d60e01b82525afa908115610c4557600091610c17575090565b906020823d8211610c3d575b81610c3060209383610b45565b810103126103c357505190565b3d9150610c23565b6040513d6000823e3d90fd5b504290565b919082519283825260005b848110610c82575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201610c61565b908160209103126101b6575180151581036101b65790565b60408051908101916001600160a01b031667ffffffffffffffff831182841017610b2f57610d3d926040526000806020958685527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656487860152868151910182855af13d15610dc5573d91610d2183610b67565b92610d2f6040519485610b45565b83523d60008785013e610dc9565b805190828215928315610dad575b50505015610d565750565b6084906040519062461bcd60e51b82526004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152fd5b610dbd9350820181019101610c96565b388281610d4b565b6060915b91929015610e2b5750815115610ddd575090565b3b15610de65790565b60405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606490fd5b825190915015610e3e5750805190602001fd5b60405162461bcd60e51b815260206004820152908190610e62906024830190610c56565b0390fd5b60ff60015460a01c1615610e7657565b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b908160209103126101b657516001600160a01b03811681036101b65790565b60405163a9059cbb60e01b60208201526001600160a01b039092166024830152604480830193909352918152608081019167ffffffffffffffff831182841017610b2f57610f2a92604052610cae565b565b600090819080610f515750600360fc1b9150505b60301c65020b236b4b7160d51b1790565b90815b610f5f575050610f40565b9091600a9081840660308101809111610f845760f81b9060081c179204809190610f54565b634e487b7160e01b84526011600452602484fdfea2646970667358221220ca86359fc6da32228ba85f684c1045223cd676b09343afb8e3eb37aaaf8526a764736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_bond": "the bond amount.",
          "_finder": "the finder contract used to look up addresses.",
          "_governor": "the governor contract that this contract makes proposals to.",
          "_timer": "the timer contract to control the output of getCurrentTime(). Set to 0x0 if in production.",
          "_token": "the ERC20 token that the bond is paid in."
        }
      },
      "getCurrentTime()": {
        "returns": {
          "_0": "uint for the current Testable timestamp."
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "propose((address,uint256,bytes)[])": {
        "details": "Pulls bond from the caller.",
        "params": {
          "transactions": "list of transactions for the governor to execute."
        },
        "returns": {
          "id": "the id of the governor proposal."
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "resolveProposal(uint256)": {
        "details": "For the resolution to work correctly, this contract must be a registered contract in the DVM.",
        "params": {
          "id": "proposal id."
        }
      },
      "setBond(uint256)": {
        "details": "Admin is intended to be the governance system, itself.",
        "params": {
          "_bond": "the new bond."
        }
      },
      "setCurrentTime(uint256)": {
        "details": "Will revert if not running in test mode.",
        "params": {
          "time": "timestamp to set current Testable time to."
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "title": "Proposer contract that allows anyone to make governance proposals with a bond.",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Construct the Proposer contract."
      },
      "getCurrentTime()": {
        "notice": "Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. Otherwise, it will return the block timestamp."
      },
      "propose((address,uint256,bytes)[])": {
        "notice": "Propose a new set of governance transactions for vote."
      },
      "resolveProposal(uint256)": {
        "notice": "Resolves a proposal by checking the status of the request in the Voting contract."
      },
      "setBond(uint256)": {
        "notice": "Admin method to set the bond amount."
      },
      "setCurrentTime(uint256)": {
        "notice": "Sets the current time."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 4304,
        "contract": "contracts/data-verification-mechanism/implementation/Proposer.sol:Proposer",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 17751,
        "contract": "contracts/data-verification-mechanism/implementation/Proposer.sol:Proposer",
        "label": "timerAddress",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 16304,
        "contract": "contracts/data-verification-mechanism/implementation/Proposer.sol:Proposer",
        "label": "_notEntered",
        "offset": 20,
        "slot": "1",
        "type": "t_bool"
      },
      {
        "astId": 27499,
        "contract": "contracts/data-verification-mechanism/implementation/Proposer.sol:Proposer",
        "label": "token",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IERC20)5182"
      },
      {
        "astId": 27501,
        "contract": "contracts/data-verification-mechanism/implementation/Proposer.sol:Proposer",
        "label": "bond",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 27504,
        "contract": "contracts/data-verification-mechanism/implementation/Proposer.sol:Proposer",
        "label": "governor",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(Governor)26874"
      },
      {
        "astId": 27507,
        "contract": "contracts/data-verification-mechanism/implementation/Proposer.sol:Proposer",
        "label": "finder",
        "offset": 0,
        "slot": "5",
        "type": "t_contract(Finder)26292"
      },
      {
        "astId": 27519,
        "contract": "contracts/data-verification-mechanism/implementation/Proposer.sol:Proposer",
        "label": "bondedProposals",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_struct(BondedProposal)27514_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(Finder)26292": {
        "encoding": "inplace",
        "label": "contract Finder",
        "numberOfBytes": "20"
      },
      "t_contract(Governor)26874": {
        "encoding": "inplace",
        "label": "contract Governor",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20)5182": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_mapping(t_uint256,t_struct(BondedProposal)27514_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Proposer.BondedProposal)",
        "numberOfBytes": "32",
        "value": "t_struct(BondedProposal)27514_storage"
      },
      "t_struct(BondedProposal)27514_storage": {
        "encoding": "inplace",
        "label": "struct Proposer.BondedProposal",
        "members": [
          {
            "astId": 27509,
            "contract": "contracts/data-verification-mechanism/implementation/Proposer.sol:Proposer",
            "label": "sender",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 27511,
            "contract": "contracts/data-verification-mechanism/implementation/Proposer.sol:Proposer",
            "label": "time",
            "offset": 20,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 27513,
            "contract": "contracts/data-verification-mechanism/implementation/Proposer.sol:Proposer",
            "label": "lockedBond",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}