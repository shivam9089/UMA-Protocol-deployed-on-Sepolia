{
  "address": "0xbFD46999D8917Db397fe88F9b8bBfAc6d692be7E",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "longShortPairStrikePrices",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "expiryPrice",
          "type": "int256"
        }
      ],
      "name": "percentageLongCollateralAtExpiry",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "longShortPair",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "strikePrice",
          "type": "uint256"
        }
      ],
      "name": "setLongShortPairParameters",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xafebfc9238553ee98f4dedfbe04025178d4b419821320608f70563a61007d08a",
  "receipt": {
    "to": null,
    "from": "0x2d92211362AdAa7963De4609214282FFf44859F6",
    "contractAddress": "0xbFD46999D8917Db397fe88F9b8bBfAc6d692be7E",
    "transactionIndex": 29,
    "gasUsed": "388761",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf16cb3b05ca1b5880bf26a7cf107c5f6d7097dab19d86ebe4f127b572ccab048",
    "transactionHash": "0xafebfc9238553ee98f4dedfbe04025178d4b419821320608f70563a61007d08a",
    "logs": [],
    "blockNumber": 6161322,
    "cumulativeGasUsed": "6085778",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "864d61c65c789401ae17358a5af86557",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"longShortPairStrikePrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"expiryPrice\",\"type\":\"int256\"}],\"name\":\"percentageLongCollateralAtExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"longShortPair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"}],\"name\":\"setLongShortPairParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"percentageLongCollateralAtExpiry(int256)\":{\"params\":{\"expiryPrice\":\"price from the optimistic oracle for the LSP price identifier.\"},\"returns\":{\"_0\":\"expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\"}},\"setLongShortPairParameters(address,uint256)\":{\"details\":\"Note: a) Any address can set the initial strike price b) A strike price cannot be 0. c) A strike price can only be set once to prevent the deployer from changing the strike after the fact. d) For safety, a strike price should be set before depositing any synthetic tokens in a liquidity pool. e) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\",\"params\":{\"longShortPair\":\"address of the LSP.\",\"strikePrice\":\"the strike price for the covered call for the associated LSP.\"}}},\"title\":\"Simple Success Token Long Short Pair Financial Product Library.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"percentageLongCollateralAtExpiry(int256)\":{\"notice\":\"Returns a number between 0 and 1e18 to indicate how much collateral each long and short token are entitled to per collateralPerPair.\"},\"setLongShortPairParameters(address,uint256)\":{\"notice\":\"Enables any address to set the strike price for an associated LSP.\"}},\"notice\":\"Adds settlement logic to create success token LSPs. A success token pays out 50% of collateral as a floor, with the remaining 50% functioning like an embedded covered call. If the settlement is below the strike price then longs are worth 50% of collateral. If the settlement is above the strike then the payout is equal to: 0.5 + (0.5 * (expiryPrice - strikePrice) / expiryPrice) For example, consider a covered call option collateralized in SUSHI, with a strike a price of $20, and collateralPerPair of 2. - If the price is less than $20 then the each long is worth 0.5 collateralPerPair and each short is worth 0.5 collateralPerPair. i.e., each long is worth 1 SUSHI (calls expire worthless). - If the price is more than $20 then each long is worth 0.5 collateralPerPair plus 0.5 times the fraction of collateralPerPair that was in the money, and each short is worth the remaining collateralPerPair. - Say settlement price is $30.  Then expiryPercentLong = 0.5 + (0.5 * (30 - 20) / 30) = 0.6667. If the collateralPerPair is 2, that means the long payout is 0.6667*2 = 1.3333 $SUSHI, which at a settlement price of $30 is worth $40. This is equivalent to the value of 1 $SUSHI plus the value of the $20 strike embedded call.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/SimpleSuccessTokenLongShortPairFinancialProductLibrary.sol\":\"SimpleSuccessTokenLongShortPairFinancialProductLibrary\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x58b21219689909c4f8339af00813760337f7e2e7f169a97fe49e2896dcfb3b9a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SignedSafeMath {\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        return a + b;\\n    }\\n}\\n\",\"keccak256\":\"0x62f53f262fabbbc6d8ab49488d8fce36370351aff2b8d3898d499d68995a71c2\",\"license\":\"MIT\"},\"contracts/common/implementation/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Library for fixed point arithmetic on uints\\r\\n */\\r\\nlibrary FixedPoint {\\r\\n    using SafeMath for uint256;\\r\\n    using SignedSafeMath for int256;\\r\\n\\r\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\r\\n    // For unsigned values:\\r\\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\\r\\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\\r\\n\\r\\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\\r\\n    struct Unsigned {\\r\\n        uint256 rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\\r\\n     * @param a uint to convert into a FixedPoint.\\r\\n     * @return the converted FixedPoint.\\r\\n     */\\r\\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue == fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue == b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue > fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue < fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The minimum of `a` and `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the minimum of `a` and `b`.\\r\\n     */\\r\\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return a.rawValue < b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The maximum of `a` and `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the maximum of `a` and `b`.\\r\\n     */\\r\\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return a.rawValue > b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds two `Unsigned`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.add(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return add(a, fromUnscaledUint(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.sub(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return sub(a, fromUnscaledUint(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return sub(fromUnscaledUint(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\r\\n        // stored internally as a uint256 ~10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\r\\n        // would round to 3, but this computation produces the result 2.\\r\\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\\r\\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Unsigned`s and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\\r\\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\r\\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\r\\n        if (mod != 0) {\\r\\n            return Unsigned(mulFloor.add(1));\\r\\n        } else {\\r\\n            return Unsigned(mulFloor);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        // Since b is an uint, there is no risk of truncation and we can just mul it normally\\r\\n        return Unsigned(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\r\\n        // 10^41 is stored internally as a uint256 10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\r\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\r\\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a uint256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.div(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a uint256 numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return div(fromUnscaledUint(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an `Unsigned` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\r\\n        uint256 divFloor = aScaled.div(b.rawValue);\\r\\n        uint256 mod = aScaled.mod(b.rawValue);\\r\\n        if (mod != 0) {\\r\\n            return Unsigned(divFloor.add(1));\\r\\n        } else {\\r\\n            return Unsigned(divFloor);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a uint256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Unsigned(a.rawValue.div(b))\\\"\\r\\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\\r\\n        // This creates the possibility of overflow if b is very large.\\r\\n        return divCeil(a, fromUnscaledUint(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\r\\n     * @dev This will \\\"floor\\\" the result.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a uint256 denominator.\\r\\n     * @return output is `a` to the power of `b`.\\r\\n     */\\r\\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\\r\\n        output = fromUnscaledUint(1);\\r\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\r\\n            output = mul(output, a);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\\r\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\r\\n    // For signed values:\\r\\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\\r\\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\\r\\n\\r\\n    struct Signed {\\r\\n        int256 rawValue;\\r\\n    }\\r\\n\\r\\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\r\\n        require(a.rawValue >= 0, \\\"Negative value provided\\\");\\r\\n        return Unsigned(uint256(a.rawValue));\\r\\n    }\\r\\n\\r\\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\\r\\n        require(a.rawValue <= uint256(type(int256).max), \\\"Unsigned too large\\\");\\r\\n        return Signed(int256(a.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\\r\\n     * @param a int to convert into a FixedPoint.Signed.\\r\\n     * @return the converted FixedPoint.Signed.\\r\\n     */\\r\\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\r\\n        return Signed(a.mul(SFP_SCALING_FACTOR));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a int256.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue == fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue == b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue > fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue < fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The minimum of `a` and `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the minimum of `a` and `b`.\\r\\n     */\\r\\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return a.rawValue < b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The maximum of `a` and `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the maximum of `a` and `b`.\\r\\n     */\\r\\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return a.rawValue > b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds two `Signed`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.add(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return add(a, fromUnscaledInt(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts two `Signed`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.sub(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return sub(a, fromUnscaledInt(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return sub(fromUnscaledInt(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Signed`s, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\r\\n        // stored internally as an int256 ~10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\r\\n        // would round to 3, but this computation produces the result 2.\\r\\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\\r\\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Signed`s and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\\r\\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\r\\n        // Manual mod because SignedSafeMath doesn't support it.\\r\\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\\r\\n        if (mod != 0) {\\r\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\r\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\r\\n            return Signed(mulTowardsZero.add(valueToAdd));\\r\\n        } else {\\r\\n            return Signed(mulTowardsZero);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Signed` and an unscaled int256 and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\\r\\n        return Signed(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\r\\n        // 10^41 is stored internally as an int256 10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\r\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\r\\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b an int256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.div(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a an int256 numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return div(fromUnscaledInt(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an `Signed` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\r\\n        int256 divTowardsZero = aScaled.div(b.rawValue);\\r\\n        // Manual mod because SignedSafeMath doesn't support it.\\r\\n        int256 mod = aScaled % b.rawValue;\\r\\n        if (mod != 0) {\\r\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\r\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\r\\n            return Signed(divTowardsZero.add(valueToAdd));\\r\\n        } else {\\r\\n            return Signed(divTowardsZero);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an unscaled int256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b an int256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Signed(a.rawValue.div(b))\\\"\\r\\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\\r\\n        // This creates the possibility of overflow if b is very large.\\r\\n        return divAwayFromZero(a, fromUnscaledInt(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\r\\n     * @dev This will \\\"floor\\\" the result.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a uint256 (negative exponents are not allowed).\\r\\n     * @return output is `a` to the power of `b`.\\r\\n     */\\r\\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\\r\\n        output = fromUnscaledInt(1);\\r\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\r\\n            output = mul(output, a);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xd32e845210e20d367e4deaffbfd6115876e9bbd934ea073a1802f8bcb9c2b166\",\"license\":\"AGPL-3.0-only\"},\"contracts/common/implementation/Lockable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\\r\\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\\r\\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\\r\\n */\\r\\ncontract Lockable {\\r\\n    bool private _notEntered;\\r\\n\\r\\n    constructor() {\\r\\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\\r\\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\\r\\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\\r\\n        // refund coming into effect.\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\\r\\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\\r\\n     * function that does the actual state modification.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _preEntranceCheck();\\r\\n        _preEntranceSet();\\r\\n        _;\\r\\n        _postEntranceReset();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\\r\\n     */\\r\\n    modifier nonReentrantView() {\\r\\n        _preEntranceCheck();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\\r\\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\\r\\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\\r\\n    // then call `_postEntranceReset()`.\\r\\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\\r\\n    function _preEntranceCheck() internal view {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n    }\\r\\n\\r\\n    function _preEntranceSet() internal {\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _notEntered = false;\\r\\n    }\\r\\n\\r\\n    function _postEntranceReset() internal {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    // These functions are intended to be used by child contracts to temporarily disable and re-enable the guard.\\r\\n    // Intended use:\\r\\n    // _startReentrantGuardDisabled();\\r\\n    // ...\\r\\n    // _endReentrantGuardDisabled();\\r\\n    //\\r\\n    // IMPORTANT: these should NEVER be used in a method that isn't inside a nonReentrant block. Otherwise, it's\\r\\n    // possible to permanently lock your contract.\\r\\n    function _startReentrantGuardDisabled() internal {\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    function _endReentrantGuardDisabled() internal {\\r\\n        _notEntered = false;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x0d2de08951d2be32ceb242649e4b248508f43ce9184ee9ac69eedcef9f6afd8b\",\"license\":\"AGPL-3.0-only\"},\"contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/LongShortPairFinancialProductLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"../../../../common/implementation/FixedPoint.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\n\\r\\ninterface ExpiringContractInterface {\\r\\n    function expirationTimestamp() external view returns (uint256);\\r\\n}\\r\\n\\r\\nabstract contract LongShortPairFinancialProductLibrary {\\r\\n    function percentageLongCollateralAtExpiry(int256 expiryPrice) public view virtual returns (uint256);\\r\\n}\\r\\n\",\"keccak256\":\"0xd004c8c7b2b5b8b1d3d71b82bcdad0edb4c734963c19df86fe4a4e28462ac77c\",\"license\":\"AGPL-3.0-only\"},\"contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/SimpleSuccessTokenLongShortPairFinancialProductLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./LongShortPairFinancialProductLibrary.sol\\\";\\r\\nimport \\\"../../../../common/implementation/Lockable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Simple Success Token Long Short Pair Financial Product Library.\\r\\n * @notice Adds settlement logic to create success token LSPs. A success token pays out 50% of collateral as a\\r\\n * floor, with the remaining 50% functioning like an embedded covered call.\\r\\n * If the settlement is below the strike price then longs are worth 50% of collateral.\\r\\n * If the settlement is above the strike then the payout is equal to:\\r\\n * 0.5 + (0.5 * (expiryPrice - strikePrice) / expiryPrice)\\r\\n * For example, consider a covered call option collateralized in SUSHI, with a strike a price of $20,\\r\\n * and collateralPerPair of 2.\\r\\n * - If the price is less than $20 then the each long is worth 0.5 collateralPerPair and each short is worth 0.5\\r\\n * collateralPerPair. i.e., each long is worth 1 SUSHI (calls expire worthless).\\r\\n * - If the price is more than $20 then each long is worth 0.5 collateralPerPair plus 0.5 times the fraction of\\r\\n * collateralPerPair that was in the money, and each short is worth the remaining collateralPerPair.\\r\\n * - Say settlement price is $30.  Then expiryPercentLong = 0.5 + (0.5 * (30 - 20) / 30) = 0.6667.\\r\\n * If the collateralPerPair is 2, that means the long payout is 0.6667*2 = 1.3333 $SUSHI, which at a settlement\\r\\n * price of $30 is worth $40. This is equivalent to the value of 1 $SUSHI plus the value of the $20 strike\\r\\n * embedded call.\\r\\n */\\r\\ncontract SimpleSuccessTokenLongShortPairFinancialProductLibrary is LongShortPairFinancialProductLibrary, Lockable {\\r\\n    using FixedPoint for FixedPoint.Unsigned;\\r\\n\\r\\n    mapping(address => uint256) public longShortPairStrikePrices;\\r\\n    uint256 basePercentage = 500000000000000000; // 0.5 with 18 decimals\\r\\n    uint256 variablePercentage = uint256(1000000000000000000) - basePercentage;\\r\\n\\r\\n    /**\\r\\n     * @notice Enables any address to set the strike price for an associated LSP.\\r\\n     * @param longShortPair address of the LSP.\\r\\n     * @param strikePrice the strike price for the covered call for the associated LSP.\\r\\n     * @dev Note: a) Any address can set the initial strike price b) A strike price cannot be 0.\\r\\n     * c) A strike price can only be set once to prevent the deployer from changing the strike after the fact.\\r\\n     * d) For safety, a strike price should be set before depositing any synthetic tokens in a liquidity pool.\\r\\n     * e) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\\r\\n     */\\r\\n    function setLongShortPairParameters(address longShortPair, uint256 strikePrice) public nonReentrant() {\\r\\n        require(ExpiringContractInterface(longShortPair).expirationTimestamp() != 0, \\\"Invalid LSP address\\\");\\r\\n        require(longShortPairStrikePrices[longShortPair] == 0, \\\"Parameters already set\\\");\\r\\n\\r\\n        longShortPairStrikePrices[longShortPair] = strikePrice;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns a number between 0 and 1e18 to indicate how much collateral each long and short token are entitled\\r\\n     * to per collateralPerPair.\\r\\n     * @param expiryPrice price from the optimistic oracle for the LSP price identifier.\\r\\n     * @return expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\\r\\n     */\\r\\n    function percentageLongCollateralAtExpiry(int256 expiryPrice)\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        nonReentrantView()\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 contractStrikePrice = longShortPairStrikePrices[msg.sender];\\r\\n        require(contractStrikePrice != 0, \\\"Params not set for calling LSP\\\");\\r\\n\\r\\n        // If the expiry price is less than the strike price then the long options expire worthless (out of the money).\\r\\n        // In this case, return of value of 50% (half of collateral goes to long)\\r\\n        // Note we do not consider negative expiry prices in this call option implementation.\\r\\n        uint256 positiveExpiryPrice = expiryPrice > 0 ? uint256(expiryPrice) : 0;\\r\\n        if (positiveExpiryPrice == 0 || uint256(positiveExpiryPrice) <= contractStrikePrice) return basePercentage;\\r\\n\\r\\n        // Else, token expires to be worth the 0.5 of the collateral plus 0.5 * the fraction of a collateral token\\r\\n        // that's in the money.\\r\\n        // eg if SUSHI is $30 and strike is $20, long token is redeemable for 0.5 + 0.5*(30-20)/30 = 0.6667% which if the\\r\\n        // collateralPerPair is 2, is worth 1.3333 $SUSHI, which is worth $40 if 1 $SUSHI is worth $30.\\r\\n        // This return value is strictly < 1, tending to 1 as the expiryPrice tends to infinity.\\r\\n        return\\r\\n            (\\r\\n                FixedPoint.Unsigned(basePercentage).add(\\r\\n                    FixedPoint\\r\\n                        .Unsigned(variablePercentage)\\r\\n                        .mul(\\r\\n                        FixedPoint.Unsigned(uint256(positiveExpiryPrice)).sub(FixedPoint.Unsigned(contractStrikePrice))\\r\\n                    )\\r\\n                        .div(FixedPoint.Unsigned(uint256(positiveExpiryPrice)))\\r\\n                )\\r\\n            )\\r\\n                .rawValue;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xc47ca7664818579bef5bdae3f7805f7b6a2fce4e3123245d99c6ae90d1070d9a\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x6080806040523461003357600160ff1960005416176000556706f05b59d3b20000806002556003556104db90816100398239f35b600080fdfe6040608081526004908136101561001557600080fd5b600091823560e01c80632da52361146101e85780636cf3f769146101ac576371b0b3601461004257600080fd5b346101a857816003193601126101a85761005a61021a565b90610063610267565b835460ff1990811685558351634fa1eee960e11b815290926020926001600160a01b039091169183818381865afa90811561019e578791610143575b501561010a5781865260018352848620546100ce57506001929183918652526024358385205583541617825551f35b845162461bcd60e51b8152908101839052601660248201527514185c985b595d195c9cc8185b1c9958591e481cd95d60521b6044820152606490fd5b845162461bcd60e51b81529081018390526013602482015272496e76616c6964204c5350206164647265737360681b6044820152606490fd5b9050833d8511610197575b601f8101601f1916820167ffffffffffffffff811183821017610184578591839189528101031261018057513861009f565b8680fd5b634e487b7160e01b895260418452602489fd5b503d61014e565b86513d89823e3d90fd5b8280fd5b5050346101e45760203660031901126101e45760209181906001600160a01b036101d461021a565b1681526001845220549051908152f35b5080fd5b509134610217576020366003190112610217575061021060209261020a610267565b356102b9565b9051908152f35b80fd5b600435906001600160a01b038216820361023057565b600080fd5b6020810190811067ffffffffffffffff82111761025157604052565b634e487b7160e01b600052604160045260246000fd5b60ff600054161561027457565b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b6000338152600160205260409081812054928315610461578181131561045a575b80158015610450575b61044657600254908351916102f783610235565b825260035484519061030882610235565b8152845161031581610235565b82815285519661032488610235565b875284865161033281610235565b52519551860395861161041e5784519561034b87610235565b865283855161035981610235565b5251945190600019958087048311811515166104325785519061037b82610235565b670de0b6b3a76400009384910204815285519161039783610235565b82528486516103a581610235565b525180960482118615151661041e575190811561040a578451956103c887610235565b020484528183516103d881610235565b5251925183018093116103f657508190516103f281610235565b5290565b634e487b7160e01b81526011600452602490fd5b634e487b7160e01b84526012600452602484fd5b634e487b7160e01b84526011600452602484fd5b634e487b7160e01b85526011600452602485fd5b5050505060025490565b50838111156102e3565b50806102da565b825162461bcd60e51b815260206004820152601e60248201527f506172616d73206e6f742073657420666f722063616c6c696e67204c535000006044820152606490fdfea26469706673582212209906ad3f3974a667dfcaa0e35b6b31d4137031bb9d836e80be6ae1f52ac2fd2664736f6c63430008100033",
  "deployedBytecode": "0x6040608081526004908136101561001557600080fd5b600091823560e01c80632da52361146101e85780636cf3f769146101ac576371b0b3601461004257600080fd5b346101a857816003193601126101a85761005a61021a565b90610063610267565b835460ff1990811685558351634fa1eee960e11b815290926020926001600160a01b039091169183818381865afa90811561019e578791610143575b501561010a5781865260018352848620546100ce57506001929183918652526024358385205583541617825551f35b845162461bcd60e51b8152908101839052601660248201527514185c985b595d195c9cc8185b1c9958591e481cd95d60521b6044820152606490fd5b845162461bcd60e51b81529081018390526013602482015272496e76616c6964204c5350206164647265737360681b6044820152606490fd5b9050833d8511610197575b601f8101601f1916820167ffffffffffffffff811183821017610184578591839189528101031261018057513861009f565b8680fd5b634e487b7160e01b895260418452602489fd5b503d61014e565b86513d89823e3d90fd5b8280fd5b5050346101e45760203660031901126101e45760209181906001600160a01b036101d461021a565b1681526001845220549051908152f35b5080fd5b509134610217576020366003190112610217575061021060209261020a610267565b356102b9565b9051908152f35b80fd5b600435906001600160a01b038216820361023057565b600080fd5b6020810190811067ffffffffffffffff82111761025157604052565b634e487b7160e01b600052604160045260246000fd5b60ff600054161561027457565b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b6000338152600160205260409081812054928315610461578181131561045a575b80158015610450575b61044657600254908351916102f783610235565b825260035484519061030882610235565b8152845161031581610235565b82815285519661032488610235565b875284865161033281610235565b52519551860395861161041e5784519561034b87610235565b865283855161035981610235565b5251945190600019958087048311811515166104325785519061037b82610235565b670de0b6b3a76400009384910204815285519161039783610235565b82528486516103a581610235565b525180960482118615151661041e575190811561040a578451956103c887610235565b020484528183516103d881610235565b5251925183018093116103f657508190516103f281610235565b5290565b634e487b7160e01b81526011600452602490fd5b634e487b7160e01b84526012600452602484fd5b634e487b7160e01b84526011600452602484fd5b634e487b7160e01b85526011600452602485fd5b5050505060025490565b50838111156102e3565b50806102da565b825162461bcd60e51b815260206004820152601e60248201527f506172616d73206e6f742073657420666f722063616c6c696e67204c535000006044820152606490fdfea26469706673582212209906ad3f3974a667dfcaa0e35b6b31d4137031bb9d836e80be6ae1f52ac2fd2664736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "percentageLongCollateralAtExpiry(int256)": {
        "params": {
          "expiryPrice": "price from the optimistic oracle for the LSP price identifier."
        },
        "returns": {
          "_0": "expiryPercentLong to indicate how much collateral should be sent between long and short tokens."
        }
      },
      "setLongShortPairParameters(address,uint256)": {
        "details": "Note: a) Any address can set the initial strike price b) A strike price cannot be 0. c) A strike price can only be set once to prevent the deployer from changing the strike after the fact. d) For safety, a strike price should be set before depositing any synthetic tokens in a liquidity pool. e) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.",
        "params": {
          "longShortPair": "address of the LSP.",
          "strikePrice": "the strike price for the covered call for the associated LSP."
        }
      }
    },
    "title": "Simple Success Token Long Short Pair Financial Product Library.",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "percentageLongCollateralAtExpiry(int256)": {
        "notice": "Returns a number between 0 and 1e18 to indicate how much collateral each long and short token are entitled to per collateralPerPair."
      },
      "setLongShortPairParameters(address,uint256)": {
        "notice": "Enables any address to set the strike price for an associated LSP."
      }
    },
    "notice": "Adds settlement logic to create success token LSPs. A success token pays out 50% of collateral as a floor, with the remaining 50% functioning like an embedded covered call. If the settlement is below the strike price then longs are worth 50% of collateral. If the settlement is above the strike then the payout is equal to: 0.5 + (0.5 * (expiryPrice - strikePrice) / expiryPrice) For example, consider a covered call option collateralized in SUSHI, with a strike a price of $20, and collateralPerPair of 2. - If the price is less than $20 then the each long is worth 0.5 collateralPerPair and each short is worth 0.5 collateralPerPair. i.e., each long is worth 1 SUSHI (calls expire worthless). - If the price is more than $20 then each long is worth 0.5 collateralPerPair plus 0.5 times the fraction of collateralPerPair that was in the money, and each short is worth the remaining collateralPerPair. - Say settlement price is $30.  Then expiryPercentLong = 0.5 + (0.5 * (30 - 20) / 30) = 0.6667. If the collateralPerPair is 2, that means the long payout is 0.6667*2 = 1.3333 $SUSHI, which at a settlement price of $30 is worth $40. This is equivalent to the value of 1 $SUSHI plus the value of the $20 strike embedded call.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 16304,
        "contract": "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/SimpleSuccessTokenLongShortPairFinancialProductLibrary.sol:SimpleSuccessTokenLongShortPairFinancialProductLibrary",
        "label": "_notEntered",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 44591,
        "contract": "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/SimpleSuccessTokenLongShortPairFinancialProductLibrary.sol:SimpleSuccessTokenLongShortPairFinancialProductLibrary",
        "label": "longShortPairStrikePrices",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 44594,
        "contract": "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/SimpleSuccessTokenLongShortPairFinancialProductLibrary.sol:SimpleSuccessTokenLongShortPairFinancialProductLibrary",
        "label": "basePercentage",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 44602,
        "contract": "contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/SimpleSuccessTokenLongShortPairFinancialProductLibrary.sol:SimpleSuccessTokenLongShortPairFinancialProductLibrary",
        "label": "variablePercentage",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}